[{"path":"https://bdhitt.github.io/binGroup2/articles/Identification-through-group-testing.html","id":"operating-characteristics","dir":"Articles","previous_headings":"","what":"Operating characteristics","title":"Identification-through-group-testing","text":"opChar1() opChar2() functions compute operating characteristics, expected number tests, group testing algorithm. example opChar1() can used two-stage hierarchical testing (also known Dorfman testing) one-infection assay. example, use overall prevalence 0.01, sensitivity specificity 0.99 stage, initial group size 10. group membership matrix shows individual tested group 1 first stage. group tests positive, individual tested separately second stage. opChar1() function returns calculations list object summarized summary(). example, expected number tests 2.04 group. Additional functions, like ExpTests(), can access information available objects created opChar1() well. opChar2() function performs similar calculations two-infection assays. example using two-stage hierarchical testing . two infections, vector joint probabilities specified form (p−−,p+−,p−+,p++)(p_{--},p_{+-},p_{-+},p_{++}), pabp_{ab} probability positive/negative (+/−)(+/-) infections aa bb. continue using sensitivity specificity 0.99 stage initial group size 10. expected number tests 5.10 testing configuration.","code":"> # Group membership matrix > group.member <- GroupMembershipMatrix(stage1 = 10) > group.member #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> [1,]    1    1    1    1    1    1    1    1    1     1 #> [2,]    1    2    3    4    5    6    7    8    9    10 >  > # Compute operating characteristics for a one-infection assay > save1 <- opChar1(algorithm = \"D2\", p = 0.01, Se = 0.99, Sp = 0.99,                    hier.config = group.member, print.time = FALSE) > names(save1) #> [1] \"algorithm\" \"prob\"      \"Se\"        \"Sp\"        \"Config\"    \"p.vec\"     #> [7] \"ET\"        \"value\"     \"Accuracy\" > summary(save1) #>  #> Algorithm: Non-informative two-stage hierarchical testing  #>  #> Testing configuration: #> Stage 1: 10 #>  #> Expected number of tests: 2.04 #> Expected number of tests per individual: 0.2037 #>  #> Accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.9801 0.9991 0.9127 0.9998         All #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9801 0.9991 0.9127 0.9998 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value. > ExpTests(save1) #>   ExpTests ExpTestsPerIndividual PercentReductionTests PercentIncreaseTestCap #> 1   2.0371                0.2037                 79.63                 390.90 > # Compute operating characteristics for a two-infection assay > save2 <- opChar2(algorithm = \"D2\", p.vec = c(0.95, 0.02, 0.02, 0.01),                    Se = c(0.99, 0.99), Sp = c(0.99, 0.99),                    hier.config = group.member, print.time = FALSE) > names(save2) #> [1] \"algorithm\" \"prob.vec\"  \"Se\"        \"Sp\"        \"Config\"    \"p.mat\"     #> [7] \"ET\"        \"value\"     \"Accuracy\" > summary(save2) #>  #> Algorithm: Non-informative two-stage hierarchical testing  #>  #> Testing configuration: #> Stage 1: 10 #>  #> Expected number of tests: 5.10 #> Expected number of tests per individual: 0.5104 #>  #> Disease 1 accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.9850 0.9961 0.8859 0.9995         All #>  #> Disease 2 accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.9850 0.9961 0.8859 0.9995         All #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9850 0.9961 0.8859 0.9995 #> 2 0.9850 0.9961 0.8859 0.9995 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value. > ExpTests(save2) #>   ExpTests ExpTestsPerIndividual PercentReductionTests PercentIncreaseTestCap #> 1   5.1042                0.5104                 48.96                  95.92"},{"path":"https://bdhitt.github.io/binGroup2/articles/Identification-through-group-testing.html","id":"optimal-testing-configuration","dir":"Articles","previous_headings":"","what":"Optimal testing configuration","title":"Identification-through-group-testing","text":"OTC1() OTC2() functions find optimal testing configuration group testing algorithm. example OTC1() can used two-stage hierarchical testing one-infection assay. example, use overall prevalence 0.01 sensitivity specificity 0.99 stage. OTC searched group sizes 3 20. OTC group size 11 expected number tests per individual 0.2035. testing configuration slightly efficient using group size 10 specified previous example. can seen comparing summary() outputs Config() function results accesses information stored save3. OTC2() function works much way OTC1() main difference specification joint probabilities rather single-infection prevalence. example , search OTC group sizes 3 20 using two-stage hierarchical testing algorithm. OTC group size 5 expected number tests per individual 0.4399. determine much efficient OTC comparison previous two-infection example’s use group size 10, use CompareConfig() function. OTC 13.81% efficient using group size 10. vignette focuses two-stage hierarchical testing algorithm homogeneous population. Many group testing algorithms available! provide large number examples within help package illustrate algorithms. Bilder et al. (2023) paper also provides many examples. particular, appendix paper provides advanced uses functions package.","code":"> # Find OTC for a one-infection assay > save3 <- OTC1(algorithm = \"D2\", p = 0.01, Se = 0.99, Sp = 0.99,                 group.sz = 3:20, obj.fn = \"ET\", print.time = FALSE) #> Initial Group Size = 3 #> Initial Group Size = 4 #> Initial Group Size = 5 #> Initial Group Size = 6 #> Initial Group Size = 7 #> Initial Group Size = 8 #> Initial Group Size = 9 #> Initial Group Size = 10 #> Initial Group Size = 11 #> Initial Group Size = 12 #> Initial Group Size = 13 #> Initial Group Size = 14 #> Initial Group Size = 15 #> Initial Group Size = 16 #> Initial Group Size = 17 #> Initial Group Size = 18 #> Initial Group Size = 19 #> Initial Group Size = 20 > names(save3) #> [1] \"algorithm\" \"prob\"      \"Se\"        \"Sp\"        \"opt.ET\"    \"Configs\"   #> [7] \"group.sz\" > summary(save3) #>  #> Algorithm: Non-informative two-stage hierarchical testing  #>  #> Optimal testing configuration: #>    Stage 1 #> ET      11 #>  #> Expected number of tests: #>    E(T)  Value #> ET 2.24 0.2035 #>  #> E(T) denotes the expected number of tests. #> Value denotes the objective function value per individual. #>  #> Overall accuracy of the algorithm: #>       PSe    PSp   PPPV   PNPV #> ET 0.9801 0.9990 0.9052 0.9998 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value. > Config(save3) #>    I     ET  value    PSe    PSp   PPPV   PNPV #> 1 11 2.2383 0.2035 0.9801 0.9990 0.9052 0.9998 #> 2 10 2.0371 0.2037 0.9801 0.9991 0.9127 0.9998 #> 3 12 2.4561 0.2047 0.9801 0.9989 0.8979 0.9998 #> 4  9 1.8528 0.2059 0.9801 0.9991 0.9203 0.9998 #> 5 13 2.6904 0.2070 0.9801 0.9988 0.8908 0.9998 > # Find OTC for a two-infection assay > save4 <- OTC2(algorithm = \"D2\", p.vec = c(0.95, 0.02, 0.02, 0.01),                 Se = c(0.99, 0.99), Sp = c(0.99, 0.99),                 group.sz = 3:20, obj.fn = \"ET\", print.time = FALSE) #> Initial Group Size = 3 #> Initial Group Size = 4 #> Initial Group Size = 5 #> Initial Group Size = 6 #> Initial Group Size = 7 #> Initial Group Size = 8 #> Initial Group Size = 9 #> Initial Group Size = 10 #> Initial Group Size = 11 #> Initial Group Size = 12 #> Initial Group Size = 13 #> Initial Group Size = 14 #> Initial Group Size = 15 #> Initial Group Size = 16 #> Initial Group Size = 17 #> Initial Group Size = 18 #> Initial Group Size = 19 #> Initial Group Size = 20 > names(save4) #> [1] \"algorithm\" \"prob.vec\"  \"Se\"        \"Sp\"        \"opt.ET\"    \"Configs\"   #> [7] \"group.sz\" > summary(save4) #>  #> Algorithm: Non-informative two-stage hierarchical testing  #>  #> Optimal testing configuration: #>    Stage 1 #> ET       5 #>  #> Expected number of tests: #>    E(T)  Value #> ET 2.20 0.4399 #>  #> E(T) denotes the expected number of tests. #> Value denotes the objective function value per individual. #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9842 0.9978 0.9336 0.9995 #> 2 0.9842 0.9978 0.9336 0.9995 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value. > Config(save4) #>   I     ET  value   PSe1   PSp1  PPPV1  PNPV1   PSe2   PSp2  PPPV2  PNPV2 #> 1 5 2.1996 0.4399 0.9842 0.9978 0.9336 0.9995 0.9842 0.9978 0.9336 0.9995 #> 2 6 2.6655 0.4443 0.9843 0.9974 0.9226 0.9995 0.9843 0.9974 0.9226 0.9995 #> 3 4 1.8012 0.4503 0.9840 0.9982 0.9454 0.9995 0.9840 0.9982 0.9454 0.9995 #> 4 7 3.1937 0.4562 0.9845 0.9971 0.9124 0.9995 0.9845 0.9971 0.9124 0.9995 #> 5 8 3.7791 0.4724 0.9847 0.9967 0.9029 0.9995 0.9847 0.9967 0.9029 0.9995 > # Compare testing configurations > group.member.OTC <- GroupMembershipMatrix(stage1 = 5) > save5 <- opChar2(algorithm = \"D2\", p.vec = c(0.95, 0.02, 0.02, 0.01),                    Se = c(0.99, 0.99), Sp = c(0.99, 0.99),                    hier.config = group.member.OTC, print.time = FALSE) > CompareConfig(save2, save5) #> Testing configurations compared to individual testing:  #>   ExpTests ExpTestsPerIndividual PercentReductionTests PercentIncreaseTestCap #> 1   5.1042                0.5104                 48.96                  95.92 #> 2   2.1996                0.4399                 56.01                 127.31 #>  #> Percent reduction in tests when using the second testing #>      configuration rather than the first: 13.81  #>   #> Percent increase in testing capacity when using the second testing #>      configuration rather than the first: 16.02 #>"},{"path":"https://bdhitt.github.io/binGroup2/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Brianna Hitt. Author, maintainer. Christopher Bilder. Author. Frank Schaarschmidt. Author. Brad Biggerstaff. Author. Christopher McMahan. Author. Joshua Tebbs. Author. Boan Zhang. Contributor. Michael Black. Contributor. Peijie Hou. Contributor. Peng Chen. Contributor. Minh Nguyen. Contributor.","code":""},{"path":"https://bdhitt.github.io/binGroup2/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hitt B, Bilder C, Schaarschmidt F, Biggerstaff B, McMahan C, Tebbs J (2025). binGroup2: Identification Estimation using Group Testing. R package version 1.3.2, https://github.com/bdhitt/binGroup2.","code":"@Manual{,   title = {binGroup2: Identification and Estimation using Group Testing},   author = {Brianna Hitt and Christopher Bilder and Frank Schaarschmidt and Brad Biggerstaff and Christopher McMahan and Joshua Tebbs},   year = {2025},   note = {R package version 1.3.2},   url = {https://github.com/bdhitt/binGroup2}, }"},{"path":"https://bdhitt.github.io/binGroup2/index.html","id":"bingroup2","dir":"","previous_headings":"","what":"Identification and Estimation using Group Testing","title":"Identification and Estimation using Group Testing","text":"goal binGroup2 provide methods group testing identification estimation problems. Methods group testing identification problem: 1) Operating characteristics (e.g., expected number tests) commonly used hierarchical array-based algorithms, 2) Optimal testing configurations algorithms. Methods group testing estimation problem: 1) Estimation inference procedures overall prevalence, 2) Regression modeling commonly used hierarchical array-based algorithms.","code":""},{"path":"https://bdhitt.github.io/binGroup2/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Identification and Estimation using Group Testing","text":"can install development version binGroup2 GitHub :","code":"# install.packages(\"pak\") pak::pak(\"bdhitt/binGroup2\")"},{"path":"https://bdhitt.github.io/binGroup2/reference/Accuracy.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the accuracy measures from group testing results — Accuracy","title":"Extract the accuracy measures from group testing results — Accuracy","text":"Extract accuracy measures objects class \"opchar\" returned operatingCharacteristics1 (opChar1) operatingCharacteristics2 (opChar2).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Accuracy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the accuracy measures from group testing results — Accuracy","text":"","code":"Accuracy(object, individual = TRUE, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/Accuracy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the accuracy measures from group testing results — Accuracy","text":"object object class \"opChar\", accuracy measures extracted. individual logical argument determines whether accuracy measures individual (individual=TRUE) included. ... Additional arguments passed Accuracy (e.g., digits passed round signif appropriate rounding).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Accuracy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the accuracy measures from group testing results — Accuracy","text":"list containing: Individual matrix detailing accuracy measures individual object (objects returned opChar1). Disease 1 Individual matrix detailing accuracy measures pertaining disease 1 individual object (objects returned opChar2). Disease 2 Individual matrix detailing accuracy measures pertaining disease 2 individual object (objects returned opChar2). Overall matrix detailing overall accuracy measures algorithm object.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Accuracy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract the accuracy measures from group testing results — Accuracy","text":"Accuracy function gives individual accuracy measures individual object overall accuracy measures algorithm. individual=TRUE, individual accuracy measures provided individual specified argument call operatingCharacteristics1 (opChar1) operatingCharacteristics2 (opChar2). Accuracy measures included pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value. overall accuracy measures displayed weighted averages corresponding individual accuracy measures individuals algorithm. Expressions averages provided Supplementary Material Hitt et al. (2019). information, see Details' section operatingCharacteristics1 (opChar1) operatingCharacteristics2 (opChar2) function. rows matrices individual accuracy measures correspond unique set accuracy measures algorithm. Individuals set accuracy measures displayed together single row matrix. columns correspond pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value, indices individuals row matrix. Individual accuracy measures provided individual=TRUE.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Accuracy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract the accuracy measures from group testing results — Accuracy","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Accuracy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract the accuracy measures from group testing results — Accuracy","text":"","code":"config.mat <- matrix(data = c(rep(1, 10), 1:10),                      nrow = 2, ncol = 10, byrow = TRUE) res1 <- opChar1(algorithm = \"D2\", p = 0.05, Se = 0.99, Sp = 0.99,         hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   Accuracy(res1, individual = FALSE) #> $Overall #>         PSe    PSp   PPPV   PNPV #> [1,] 0.9801 0.9963 0.9327 0.9989 #>  Accuracy(res1, individual = TRUE) #> $Individual #>      PSe    PSp   PPPV   PNPV individuals #> 1 0.9801 0.9963 0.9327 0.9989         All #>  #> $Overall #>         PSe    PSp   PPPV   PNPV #> [1,] 0.9801 0.9963 0.9327 0.9989 #>   res2 <- opChar2(algorithm = \"A2M\",                 p.vec = c(0.92, 0.05, 0.02, 0.01),                 Se = rep(0.95, 2), Sp = rep(0.99, 2),                 rowcol.sz = 8) #>  #>  Number of minutes running:  0  #>   Accuracy(res2) #> $`Disease 1 Individual` #>      PSe    PSp   PPPV   PNPV individuals #> 1 0.8704 0.9983 0.9709 0.9918         All #>  #> $`Disease 2 Individual` #>      PSe    PSp   PPPV   PNPV individuals #> 1 0.9004 0.9981 0.9366 0.9969         All #>  #> $Overall #>         #> Disease    PSe    PSp   PPPV   PNPV #>       1 0.8704 0.9983 0.9709 0.9918 #>       2 0.9004 0.9981 0.9366 0.9969 #>"},{"path":"https://bdhitt.github.io/binGroup2/reference/CompareConfig.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare group testing results — CompareConfig","title":"Compare group testing results — CompareConfig","text":"Compare group testing results objects class \"opchar\" returned operatingCharacteristics1 (opChar1) operatingCharacteristics2 (opChar2).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/CompareConfig.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare group testing results — CompareConfig","text":"","code":"CompareConfig(object1, object2)"},{"path":"https://bdhitt.github.io/binGroup2/reference/CompareConfig.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare group testing results — CompareConfig","text":"object1 object class \"opChar\" containing group testing results. object2 second object class \"opChar\" containing group testing results.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/CompareConfig.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare group testing results — CompareConfig","text":"data frame expected percent reduction tests (PercentReductionTests) expected increase testing capacity (PercentIncreaseTestCap) using second testing configuration rather first testing configuration. Positive values quantities indicate second testing configuration efficient first.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/CompareConfig.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compare group testing results — CompareConfig","text":"CompareConfig function compares group testing results two objects class \"opChar\". function creates data frame comparisons.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/CompareConfig.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compare group testing results — CompareConfig","text":"Brianna D. Hitt Christopher R. Bilder","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/CompareConfig.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare group testing results — CompareConfig","text":"","code":"config.mat1 <- matrix(data = c(rep(1, 10), rep(1:2, each = 5), 1:10),                       nrow = 3, ncol = 10, byrow = TRUE) res1 <- opChar1(algorithm = \"D3\", p = 0.05, Se = 0.99, Sp = 0.99,                 hier.config = config.mat1) #>  #>  Number of minutes running:  0  #>   config.mat2 <- matrix(data = c(rep(1, 10), 1:10),                       nrow = 2, ncol = 10, byrow = TRUE) res2 <- opChar1(algorithm = \"D2\", p = 0.05, Se = 0.99, Sp = 0.99,         hier.config = config.mat2) #>  #>  Number of minutes running:  0  #>   CompareConfig(res2, res1) #> Testing configurations compared to individual testing:  #>   ExpTests ExpTestsPerIndividual PercentReductionTests PercentIncreaseTestCap #> 1   5.0324                0.5032                 49.68                  98.71 #> 2   4.0416                0.4042                 59.58                 147.43 #>  #> Percent reduction in tests when using the second testing #>      configuration rather than the first: 19.69  #>   #> Percent increase in testing capacity when using the second testing #>      configuration rather than the first: 24.52 #>    config.mat3 <- matrix(data = c(rep(1, 10), rep(1, 5),                                rep(2, 4), 3, 1:9, NA),                       nrow = 3, ncol = 10, byrow = TRUE) Se <- matrix(data = rep(0.95, 6), nrow = 2, ncol = 3,              dimnames = list(Infection = 1:2, Stage = 1:3)) Sp <- matrix(data = rep(0.99, 6), nrow = 2, ncol = 3,              dimnames = list(Infection = 1:2, Stage = 1:3)) res3 <- opChar2(algorithm = \"D3\", p.vec = c(0.95, 0.02, 0.02, 0.01),                 Se = Se, Sp = Sp, hier.config = config.mat3) #>  #>  Number of minutes running:  0  #>   config.mat4 <- matrix(data = c(rep(1, 12), rep(1, 6), rep(2, 6),                                rep(1, 4), rep(2, 2), rep(3, 3),                                rep(4, 3), 1:12),                     nrow = 4, ncol = 12, byrow = TRUE) Se <- matrix(data = rep(0.95, 8), nrow = 2, ncol = 4,              dimnames = list(Infection = 1:2, Stage = 1:4)) Sp <- matrix(data = rep(0.99, 8), nrow = 2, ncol = 4,              dimnames = list(Infection = 1:2, Stage = 1:4)) res4 <- opChar2(algorithm = \"D4\", p.vec = c(0.92, 0.05, 0.02, 0.01),                 Se = Se, Sp = Sp, hier.config = config.mat4) #>  #>  Number of minutes running:  0  #>   CompareConfig(res4, res3) #> Testing configurations compared to individual testing:  #>   ExpTests ExpTestsPerIndividual PercentReductionTests PercentIncreaseTestCap #> 1   6.2334                0.5195                 48.05                  92.51 #> 2   3.9765                0.3977                 60.23                 151.48 #>  #> Percent reduction in tests when using the second testing #>      configuration rather than the first: 23.45  #>   #> Percent increase in testing capacity when using the second testing #>      configuration rather than the first: 30.63 #>"},{"path":"https://bdhitt.github.io/binGroup2/reference/Config.OTC.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the testing configuration from group testing results — Config.OTC","title":"Extract the testing configuration from group testing results — Config.OTC","text":"Extract testing configuration objects class \"OTC\" returned OTC1 (OTC1) OTC2 (OTC2).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Config.OTC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the testing configuration from group testing results — Config.OTC","text":"","code":"# S3 method for class 'OTC' Config(object, n = 5, top.overall = FALSE, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/Config.OTC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the testing configuration from group testing results — Config.OTC","text":"object object class \"OTC\", testing configuration extracted. n Number testing configurations. top.overall logical; TRUE, best overall testing configurations; FALSE, best testing configurations initial group size ... currently used.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Config.OTC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the testing configuration from group testing results — Config.OTC","text":"data frame providing best testing configurations.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Config.OTC.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract the testing configuration from group testing results — Config.OTC","text":"Christopher R. Bilder","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Config.OTC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract the testing configuration from group testing results — Config.OTC","text":"","code":"res1 <- OTC1(algorithm = \"D3\", p = 0.05, Se = 0.99, Sp = 0.99,              group.sz = 3:15, obj.fn = \"ET\") #> Initial Group Size = 3 #> Initial Group Size = 4 #> Initial Group Size = 5 #> Initial Group Size = 6 #> Initial Group Size = 7 #> Initial Group Size = 8 #> Initial Group Size = 9 #> Initial Group Size = 10 #> Initial Group Size = 11 #> Initial Group Size = 12 #> Initial Group Size = 13 #> Initial Group Size = 14 #> Initial Group Size = 15 #>  #>  Number of minutes running:  0  #>   Config(res1) #>    I  config     ET  value    PSe    PSp   PPPV   PNPV #> 1  9   3,3,3 3.3960 0.3773 0.9703 0.9990 0.9812 0.9984 #> 2 12 3,3,3,3 4.5575 0.3798 0.9703 0.9990 0.9810 0.9984 #> 3 10   4,3,3 3.8001 0.3800 0.9703 0.9988 0.9778 0.9984 #> 4 11   4,4,3 4.2002 0.3818 0.9703 0.9987 0.9751 0.9984 #> 5 13 4,3,3,3 4.9762 0.3828 0.9703 0.9989 0.9784 0.9984"},{"path":"https://bdhitt.github.io/binGroup2/reference/Config.html","id":null,"dir":"Reference","previous_headings":"","what":"Access the testing configurations returned from an object — Config","title":"Access the testing configurations returned from an object — Config","text":"Config generic function extracts testing configurations object","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Config.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access the testing configurations returned from an object — Config","text":"","code":"Config(object, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/Config.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access the testing configurations returned from an object — Config","text":"object object testing configurations extracted. ... Additional arguments passed Config.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/Config.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Access the testing configurations returned from an object — Config","text":"Christopher R. Bilder","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Config.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Access the testing configurations returned from an object — Config","text":"","code":"# Find the optimal testing configuration for #   non-informative two-stage hierarchical testing. res1 <- OTC1(algorithm = \"D2\", p = 0.01, Se = 0.99, Sp = 0.99,              group.sz = 2:100, obj.fn = c(\"ET\", \"MAR\", \"GR1\"),              weights = matrix(data = c(1,1), nrow = 1, ncol = 2)) #> Initial Group Size = 2 #> Initial Group Size = 3 #> Initial Group Size = 4 #> Initial Group Size = 5 #> Initial Group Size = 6 #> Initial Group Size = 7 #> Initial Group Size = 8 #> Initial Group Size = 9 #> Initial Group Size = 10 #> Initial Group Size = 11 #> Initial Group Size = 12 #> Initial Group Size = 13 #> Initial Group Size = 14 #> Initial Group Size = 15 #> Initial Group Size = 16 #> Initial Group Size = 17 #> Initial Group Size = 18 #> Initial Group Size = 19 #> Initial Group Size = 20 #> Initial Group Size = 21 #> Initial Group Size = 22 #> Initial Group Size = 23 #> Initial Group Size = 24 #> Initial Group Size = 25 #> Initial Group Size = 26 #> Initial Group Size = 27 #> Initial Group Size = 28 #> Initial Group Size = 29 #> Initial Group Size = 30 #> Initial Group Size = 31 #> Initial Group Size = 32 #> Initial Group Size = 33 #> Initial Group Size = 34 #> Initial Group Size = 35 #> Initial Group Size = 36 #> Initial Group Size = 37 #> Initial Group Size = 38 #> Initial Group Size = 39 #> Initial Group Size = 40 #> Initial Group Size = 41 #> Initial Group Size = 42 #> Initial Group Size = 43 #> Initial Group Size = 44 #> Initial Group Size = 45 #> Initial Group Size = 46 #> Initial Group Size = 47 #> Initial Group Size = 48 #> Initial Group Size = 49 #> Initial Group Size = 50 #> Initial Group Size = 51 #> Initial Group Size = 52 #> Initial Group Size = 53 #> Initial Group Size = 54 #> Initial Group Size = 55 #> Initial Group Size = 56 #> Initial Group Size = 57 #> Initial Group Size = 58 #> Initial Group Size = 59 #> Initial Group Size = 60 #> Initial Group Size = 61 #> Initial Group Size = 62 #> Initial Group Size = 63 #> Initial Group Size = 64 #> Initial Group Size = 65 #> Initial Group Size = 66 #> Initial Group Size = 67 #> Initial Group Size = 68 #> Initial Group Size = 69 #> Initial Group Size = 70 #> Initial Group Size = 71 #> Initial Group Size = 72 #> Initial Group Size = 73 #> Initial Group Size = 74 #> Initial Group Size = 75 #> Initial Group Size = 76 #> Initial Group Size = 77 #> Initial Group Size = 78 #> Initial Group Size = 79 #> Initial Group Size = 80 #> Initial Group Size = 81 #> Initial Group Size = 82 #> Initial Group Size = 83 #> Initial Group Size = 84 #> Initial Group Size = 85 #> Initial Group Size = 86 #> Initial Group Size = 87 #> Initial Group Size = 88 #> Initial Group Size = 89 #> Initial Group Size = 90 #> Initial Group Size = 91 #> Initial Group Size = 92 #> Initial Group Size = 93 #> Initial Group Size = 94 #> Initial Group Size = 95 #> Initial Group Size = 96 #> Initial Group Size = 97 #> Initial Group Size = 98 #> Initial Group Size = 99 #> Initial Group Size = 100 #>  #>  Number of minutes running:  0  #>   Config(res1) #>    I     ET  value    PSe    PSp   PPPV   PNPV #> 1 11 2.2383 0.2035 0.9801 0.9990 0.9052 0.9998 #> 2 10 2.0371 0.2037 0.9801 0.9991 0.9127 0.9998 #> 3 12 2.4561 0.2047 0.9801 0.9989 0.8979 0.9998 #> 4  9 1.8528 0.2059 0.9801 0.9991 0.9203 0.9998 #> 5 13 2.6904 0.2070 0.9801 0.9988 0.8908 0.9998"},{"path":"https://bdhitt.github.io/binGroup2/reference/Config.opChar.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the testing configuration from group testing results — Config.opChar","title":"Extract the testing configuration from group testing results — Config.opChar","text":"Extract testing configuration objects class \"opchar\" returned operatingCharacteristics1 (opChar1) operatingCharacteristics2 (opChar2).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Config.opChar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the testing configuration from group testing results — Config.opChar","text":"","code":"# S3 method for class 'opChar' Config(object, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/Config.opChar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the testing configuration from group testing results — Config.opChar","text":"object object class \"opChar\", testing configuration extracted. ... currently used.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Config.opChar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the testing configuration from group testing results — Config.opChar","text":"data frame specifying elements testing configuration.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Config.opChar.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract the testing configuration from group testing results — Config.opChar","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Config.opChar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract the testing configuration from group testing results — Config.opChar","text":"","code":"config.mat <- matrix(data = c(rep(1, 10), 1:10),                      nrow = 2, ncol = 10, byrow = TRUE) res1 <- opChar1(algorithm = \"D2\", p = 0.05, Se = 0.99, Sp = 0.99,         hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   Config(res1) #>   Stage1 #> 1     10  config.mat <- matrix(data = c(rep(1, 20), rep(1, 10), rep(2, 10),                              rep(c(1, 2, 3, 4), each = 5),                              rep(1, 3), rep(2, 2), rep(3, 3),                              rep(4, 2), rep(5, 3), rep(6, 2),                              rep(7, 3), rep(8, 2), 1:20),                     nrow = 5, ncol = 20, byrow = TRUE) Se <- matrix(data = rep(0.95, 10), nrow = 2, ncol = 5,              dimnames = list(Infection = 1:2, Stage = 1:5)) Sp <- matrix(data = rep(0.99, 10), nrow = 2, ncol = 5,              dimnames = list(Infection = 1:2, Stage = 1:5)) res2 <- opChar2(algorithm = \"ID5\",                 alpha = c(18.25, 0.75, 0.75, 0.25),                 Se = Se, Sp = Sp, hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   Config(res2) #>   Stage1 Stage2  Stage3          Stage4 #> 1     20  10,10 5,5,5,5 3,2,3,2,3,2,3,2"},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.OTC.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the expected number of tests from optimal testing configuration results — ExpTests.OTC","title":"Extract the expected number of tests from optimal testing configuration results — ExpTests.OTC","text":"Extract expected number tests expected number tests per individual objects class \"OTC\" returned OTC1 OTC2.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.OTC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the expected number of tests from optimal testing configuration results — ExpTests.OTC","text":"","code":"# S3 method for class 'OTC' ExpTests(object, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.OTC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the expected number of tests from optimal testing configuration results — ExpTests.OTC","text":"object object class \"OTC\", expected number tests expected number tests per individual extracted. ... Additional arguments passed ExpTests (e.g., digits passed round appropriate rounding).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.OTC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the expected number of tests from optimal testing configuration results — ExpTests.OTC","text":"data frame containing columns: ExpTests expected number tests required optimal testing configuration. ExpTestsPerInd expected number tests per individual optimal testing configuration. PercentReductionTests percent reduction number tests; 100 * (1 - ExpTestsPerIndividual). PercentIncreaseTestCap percent increase testing capacity algorithm   applied continuous stream specimens; 100 * (1/ExpTestsPerIndividual - 1). row data frame represents objective function specified call OTC1 OTC2.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.OTC.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extract the expected number of tests from optimal testing configuration results — ExpTests.OTC","text":"Bilder, C., Iwen, P., Abdalhamid, B., Tebbs, J., McMahan, C. (2020). “Tests short supply? Try group testing.” Significance, 17, 15.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.OTC.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract the expected number of tests from optimal testing configuration results — ExpTests.OTC","text":"Brianna D. Hitt Christopher R. Bilder","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.OTC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract the expected number of tests from optimal testing configuration results — ExpTests.OTC","text":"","code":"res1 <- OTC1(algorithm = \"D2\", p = 0.05, Se = 0.99, Sp = 0.99,              group.sz = 2:100, obj.fn = c(\"ET\", \"MAR\"),              trace = TRUE) #> Initial Group Size = 2 #> Initial Group Size = 3 #> Initial Group Size = 4 #> Initial Group Size = 5 #> Initial Group Size = 6 #> Initial Group Size = 7 #> Initial Group Size = 8 #> Initial Group Size = 9 #> Initial Group Size = 10 #> Initial Group Size = 11 #> Initial Group Size = 12 #> Initial Group Size = 13 #> Initial Group Size = 14 #> Initial Group Size = 15 #> Initial Group Size = 16 #> Initial Group Size = 17 #> Initial Group Size = 18 #> Initial Group Size = 19 #> Initial Group Size = 20 #> Initial Group Size = 21 #> Initial Group Size = 22 #> Initial Group Size = 23 #> Initial Group Size = 24 #> Initial Group Size = 25 #> Initial Group Size = 26 #> Initial Group Size = 27 #> Initial Group Size = 28 #> Initial Group Size = 29 #> Initial Group Size = 30 #> Initial Group Size = 31 #> Initial Group Size = 32 #> Initial Group Size = 33 #> Initial Group Size = 34 #> Initial Group Size = 35 #> Initial Group Size = 36 #> Initial Group Size = 37 #> Initial Group Size = 38 #> Initial Group Size = 39 #> Initial Group Size = 40 #> Initial Group Size = 41 #> Initial Group Size = 42 #> Initial Group Size = 43 #> Initial Group Size = 44 #> Initial Group Size = 45 #> Initial Group Size = 46 #> Initial Group Size = 47 #> Initial Group Size = 48 #> Initial Group Size = 49 #> Initial Group Size = 50 #> Initial Group Size = 51 #> Initial Group Size = 52 #> Initial Group Size = 53 #> Initial Group Size = 54 #> Initial Group Size = 55 #> Initial Group Size = 56 #> Initial Group Size = 57 #> Initial Group Size = 58 #> Initial Group Size = 59 #> Initial Group Size = 60 #> Initial Group Size = 61 #> Initial Group Size = 62 #> Initial Group Size = 63 #> Initial Group Size = 64 #> Initial Group Size = 65 #> Initial Group Size = 66 #> Initial Group Size = 67 #> Initial Group Size = 68 #> Initial Group Size = 69 #> Initial Group Size = 70 #> Initial Group Size = 71 #> Initial Group Size = 72 #> Initial Group Size = 73 #> Initial Group Size = 74 #> Initial Group Size = 75 #> Initial Group Size = 76 #> Initial Group Size = 77 #> Initial Group Size = 78 #> Initial Group Size = 79 #> Initial Group Size = 80 #> Initial Group Size = 81 #> Initial Group Size = 82 #> Initial Group Size = 83 #> Initial Group Size = 84 #> Initial Group Size = 85 #> Initial Group Size = 86 #> Initial Group Size = 87 #> Initial Group Size = 88 #> Initial Group Size = 89 #> Initial Group Size = 90 #> Initial Group Size = 91 #> Initial Group Size = 92 #> Initial Group Size = 93 #> Initial Group Size = 94 #> Initial Group Size = 95 #> Initial Group Size = 96 #> Initial Group Size = 97 #> Initial Group Size = 98 #> Initial Group Size = 99 #> Initial Group Size = 100 #>  #>  Number of minutes running:  0  #>   ExpTests.OTC(res1) #>         ExpTests ExpTestsPerInd PercentReductionTests PercentIncreaseTestCap #> opt.ET    2.1585         0.4317                 56.83                 131.65 #> opt.MAR   2.1585         0.4317                 56.83                 131.65"},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.Sterrett.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the expected number of tests from testing configuration results — ExpTests.Sterrett","title":"Extract the expected number of tests from testing configuration results — ExpTests.Sterrett","text":"Extract expected number tests objects class \"Sterrett\" returned Sterrett (Sterrett).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.Sterrett.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the expected number of tests from testing configuration results — ExpTests.Sterrett","text":"","code":"# S3 method for class 'Sterrett' ExpTests(object, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.Sterrett.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the expected number of tests from testing configuration results — ExpTests.Sterrett","text":"object object class \"Sterrett\", expected number tests extracted. ... Additional arguments passed ExpTests (e.g., digits passed round appropriate rounding).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.Sterrett.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the expected number of tests from testing configuration results — ExpTests.Sterrett","text":"data frame containing columns: ExpTests expected number tests required decode individuals algorithm. ExpTestsPerIndividual expected number tests per individual. PercentReductionTests percent reduction number tests; 100 * (1 - ExpTestsPerIndividual). PercentIncreaseTestCap percent increase testing capacity algorithm   applied continuous stream specimens; 100 * (1/ExpTestsPerIndividual - 1).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.Sterrett.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extract the expected number of tests from testing configuration results — ExpTests.Sterrett","text":"Bilder, C., Iwen, P., Abdalhamid, B., Tebbs, J., McMahan, C. (2020). “Tests short supply? Try group testing.” Significance, 17, 15.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.Sterrett.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract the expected number of tests from testing configuration results — ExpTests.Sterrett","text":"Christopher R. Bilder","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.Sterrett.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract the expected number of tests from testing configuration results — ExpTests.Sterrett","text":"","code":"set.seed(1231) p.vec1 <- rbeta(n = 8, shape1 = 1, shape2 = 10) save.it1 <- Sterrett(p = p.vec1, Sp = 0.90, Se = 0.95) ExpTests(save.it1) #>    Method ExpTests ExpTestsPerIndividual PercentReductionTests #> 1    1SIS   3.9808                0.4976                 50.24 #> 2    2SIS   3.6693                0.4587                 54.13 #> 3     FIS   3.6123                0.4515                 54.85 #> 4 Dorfman   5.0932                0.6366                 36.34 #>   PercentIncreaseTestCap #> 1                 100.96 #> 2                 118.01 #> 3                 121.48 #> 4                  57.08"},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.TOD.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the expected number of tests from testing configuration results — ExpTests.TOD","title":"Extract the expected number of tests from testing configuration results — ExpTests.TOD","text":"Extract expected number tests objects class \"TOD\" returned TOD (TOD).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.TOD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the expected number of tests from testing configuration results — ExpTests.TOD","text":"","code":"# S3 method for class 'TOD' ExpTests(object, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.TOD.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the expected number of tests from testing configuration results — ExpTests.TOD","text":"object object class \"TOD\", expected number tests extracted. ... Additional arguments passed ExpTests (e.g., digits passed round appropriate rounding).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.TOD.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the expected number of tests from testing configuration results — ExpTests.TOD","text":"data frame containing columns: ExpTests expected number tests required decode individuals algorithm. ExpTestsPerIndividual expected number tests per individual. PercentReductionTests percent reduction number tests; 100 * (1 - ExpTestsPerIndividual). PercentIncreaseTestCap percent increase testing capacity algorithm   applied continuous stream specimens; 100 * (1/ExpTestsPerIndividual - 1).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.TOD.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extract the expected number of tests from testing configuration results — ExpTests.TOD","text":"Bilder, C., Iwen, P., Abdalhamid, B., Tebbs, J., McMahan, C. (2020). “Tests short supply? Try group testing.” Significance, 17, 15.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.TOD.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract the expected number of tests from testing configuration results — ExpTests.TOD","text":"Christopher R. Bilder","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.TOD.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract the expected number of tests from testing configuration results — ExpTests.TOD","text":"","code":"set.seed(1002) p.vec <- expectOrderBeta(p = 0.01, alpha = 2, size = 20) save.it1 <- TOD(p = p.vec, Se = 0.95, Sp = 0.95, max = 5, threshold = 0.015) ExpTests(save.it1) #>   ExpTests ExpTestsPerIndividual PercentReductionTests PercentIncreaseTestCap #> 1   9.2189                0.4609                 53.91                 116.97"},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.halving.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the expected number of tests from testing configuration results — ExpTests.halving","title":"Extract the expected number of tests from testing configuration results — ExpTests.halving","text":"Extract expected number tests objects class \"halving\" returned halving (halving).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.halving.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the expected number of tests from testing configuration results — ExpTests.halving","text":"","code":"# S3 method for class 'halving' ExpTests(object, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.halving.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the expected number of tests from testing configuration results — ExpTests.halving","text":"object object class \"halving\", expected number tests extracted. ... Additional arguments passed ExpTests (e.g., digits passed round appropriate rounding).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.halving.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the expected number of tests from testing configuration results — ExpTests.halving","text":"data frame containing columns: ExpTests expected number tests required decode individuals algorithm. ExpTestsPerIndividual expected number tests per individual. PercentReductionTests percent reduction number tests; 100 * (1 - ExpTestsPerIndividual). PercentIncreaseTestCap percent increase testing capacity algorithm   applied continuous stream specimens; 100 * (1/ExpTestsPerIndividual - 1).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.halving.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extract the expected number of tests from testing configuration results — ExpTests.halving","text":"Bilder, C., Iwen, P., Abdalhamid, B., Tebbs, J., McMahan, C. (2020). “Tests short supply? Try group testing.” Significance, 17, 15.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.halving.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract the expected number of tests from testing configuration results — ExpTests.halving","text":"Christopher R. Bilder","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.halving.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract the expected number of tests from testing configuration results — ExpTests.halving","text":"","code":"save.it1 <- halving(p = rep(0.01, 10), Sp = 1, Se = 1, stages = 2,         order.p = TRUE) ExpTests(save.it1) #>   ExpTests ExpTestsPerIndividual PercentReductionTests PercentIncreaseTestCap #> 1   1.9562                0.1956                 80.44                 411.25"},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.html","id":null,"dir":"Reference","previous_headings":"","what":"Access the expected number of tests from an object — ExpTests","title":"Access the expected number of tests from an object — ExpTests","text":"ExpTests generic function extracts expected   number tests object contains information   aboout testing configuration.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access the expected number of tests from an object — ExpTests","text":"","code":"ExpTests(object, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access the expected number of tests from an object — ExpTests","text":"object object summary expected number tests desired. ... Additional arguments passed ExpTests.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Access the expected number of tests from an object — ExpTests","text":"value return depends class object. See documentation   corresponding method functions.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Access the expected number of tests from an object — ExpTests","text":"Christopher R. Bilder","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Access the expected number of tests from an object — ExpTests","text":"","code":"# Find the optimal testing configuration for #   non-informative two-stage hierarchical testing. res1 <- OTC1(algorithm = \"D2\", p = 0.01, Se = 0.99, Sp = 0.99,              group.sz = 2:100, obj.fn = c(\"ET\", \"MAR\", \"GR1\"),              weights = matrix(data = c(1,1), nrow = 1, ncol = 2)) #> Initial Group Size = 2 #> Initial Group Size = 3 #> Initial Group Size = 4 #> Initial Group Size = 5 #> Initial Group Size = 6 #> Initial Group Size = 7 #> Initial Group Size = 8 #> Initial Group Size = 9 #> Initial Group Size = 10 #> Initial Group Size = 11 #> Initial Group Size = 12 #> Initial Group Size = 13 #> Initial Group Size = 14 #> Initial Group Size = 15 #> Initial Group Size = 16 #> Initial Group Size = 17 #> Initial Group Size = 18 #> Initial Group Size = 19 #> Initial Group Size = 20 #> Initial Group Size = 21 #> Initial Group Size = 22 #> Initial Group Size = 23 #> Initial Group Size = 24 #> Initial Group Size = 25 #> Initial Group Size = 26 #> Initial Group Size = 27 #> Initial Group Size = 28 #> Initial Group Size = 29 #> Initial Group Size = 30 #> Initial Group Size = 31 #> Initial Group Size = 32 #> Initial Group Size = 33 #> Initial Group Size = 34 #> Initial Group Size = 35 #> Initial Group Size = 36 #> Initial Group Size = 37 #> Initial Group Size = 38 #> Initial Group Size = 39 #> Initial Group Size = 40 #> Initial Group Size = 41 #> Initial Group Size = 42 #> Initial Group Size = 43 #> Initial Group Size = 44 #> Initial Group Size = 45 #> Initial Group Size = 46 #> Initial Group Size = 47 #> Initial Group Size = 48 #> Initial Group Size = 49 #> Initial Group Size = 50 #> Initial Group Size = 51 #> Initial Group Size = 52 #> Initial Group Size = 53 #> Initial Group Size = 54 #> Initial Group Size = 55 #> Initial Group Size = 56 #> Initial Group Size = 57 #> Initial Group Size = 58 #> Initial Group Size = 59 #> Initial Group Size = 60 #> Initial Group Size = 61 #> Initial Group Size = 62 #> Initial Group Size = 63 #> Initial Group Size = 64 #> Initial Group Size = 65 #> Initial Group Size = 66 #> Initial Group Size = 67 #> Initial Group Size = 68 #> Initial Group Size = 69 #> Initial Group Size = 70 #> Initial Group Size = 71 #> Initial Group Size = 72 #> Initial Group Size = 73 #> Initial Group Size = 74 #> Initial Group Size = 75 #> Initial Group Size = 76 #> Initial Group Size = 77 #> Initial Group Size = 78 #> Initial Group Size = 79 #> Initial Group Size = 80 #> Initial Group Size = 81 #> Initial Group Size = 82 #> Initial Group Size = 83 #> Initial Group Size = 84 #> Initial Group Size = 85 #> Initial Group Size = 86 #> Initial Group Size = 87 #> Initial Group Size = 88 #> Initial Group Size = 89 #> Initial Group Size = 90 #> Initial Group Size = 91 #> Initial Group Size = 92 #> Initial Group Size = 93 #> Initial Group Size = 94 #> Initial Group Size = 95 #> Initial Group Size = 96 #> Initial Group Size = 97 #> Initial Group Size = 98 #> Initial Group Size = 99 #> Initial Group Size = 100 #>  #>  Number of minutes running:  0  #>   ExpTests(res1) #>         ExpTests ExpTestsPerInd PercentReductionTests PercentIncreaseTestCap #> opt.ET    2.2383         0.2035                 79.65                 391.45 #> opt.MAR   2.2383         0.2035                 79.65                 391.45 #> opt.GR1   2.2383         0.2035                 79.65                 391.45"},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.opChar.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the expected number of tests from testing configuration results — ExpTests.opChar","title":"Extract the expected number of tests from testing configuration results — ExpTests.opChar","text":"Extract expected number tests expected number tests per individual objects class \"opchar\" returned operatingCharacteristics1 (opChar1) operatingCharacteristics2 (opChar2).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.opChar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the expected number of tests from testing configuration results — ExpTests.opChar","text":"","code":"# S3 method for class 'opChar' ExpTests(object, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.opChar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the expected number of tests from testing configuration results — ExpTests.opChar","text":"object object class \"opChar\", expected number tests expected number tests per individual extracted. ... Additional arguments passed ExpTests (e.g., digits passed round appropriate rounding).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.opChar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the expected number of tests from testing configuration results — ExpTests.opChar","text":"data frame containing columns: ExpTests expected number tests required decode individuals algorithm. ExpTestsPerIndividual expected number tests per individual. PercentReductionTests percent reduction number tests; 100 * (1 - ExpTestsPerIndividual). PercentIncreaseTestCap percent increase testing capacity algorithm   applied continuous stream specimens; 100 * (1/ExpTestsPerIndividual - 1).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.opChar.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extract the expected number of tests from testing configuration results — ExpTests.opChar","text":"Bilder, C., Iwen, P., Abdalhamid, B., Tebbs, J., McMahan, C. (2020). “Tests short supply? Try group testing.” Significance, 17, 15.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.opChar.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract the expected number of tests from testing configuration results — ExpTests.opChar","text":"Brianna D. Hitt Christopher R. Bilder","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/ExpTests.opChar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract the expected number of tests from testing configuration results — ExpTests.opChar","text":"","code":"config.mat <- matrix(data = c(rep(1, 10), 1:10),                      nrow = 2, ncol = 10, byrow = TRUE) res1 <- opChar1(algorithm = \"D2\", p = 0.05, Se = 0.99, Sp = 0.99,                 hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   ExpTests(res1) #>   ExpTests ExpTestsPerIndividual PercentReductionTests PercentIncreaseTestCap #> 1   5.0324                0.5032                 49.68                  98.71  res2 <- opChar2(algorithm = \"A2M\", p.vec = c(0.92, 0.05, 0.02, 0.01),                 Se = rep(0.95, 2), Sp = rep(0.99, 2), rowcol.sz = 8) #>  #>  Number of minutes running:  0  #>   ExpTests(res2) #>   ExpTests ExpTestsPerIndividual PercentReductionTests PercentIncreaseTestCap #> 1  30.2892                0.4733                 52.67                 111.30"},{"path":"https://bdhitt.github.io/binGroup2/reference/GroupMembershipMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a group membership matrix for hierarchical algorithms — GroupMembershipMatrix","title":"Construct a group membership matrix for hierarchical algorithms — GroupMembershipMatrix","text":"Construct group membership matrix two-, three-, four-stage hierarchical algorithms.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/GroupMembershipMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a group membership matrix for hierarchical algorithms — GroupMembershipMatrix","text":"","code":"GroupMembershipMatrix(stage1, stage2 = NULL, stage3 = NULL, stage4 = NULL)"},{"path":"https://bdhitt.github.io/binGroup2/reference/GroupMembershipMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a group membership matrix for hierarchical algorithms — GroupMembershipMatrix","text":"stage1 group size stage one testing. also corresponds number individuals tested specify number columns resulting group membership matrix. stage2 vector group sizes stage two testing. group sizes specified sum number individuals/group size specified stage1. NULL, group membership matrix constructed two-stage hierarchical algorithm. details given 'Details'. stage3 vector group sizes stage three testing. group sizes specified sum number individuals/group size specified stage1. group sizes provided stage2 stage3 NULL, group membership matrix constructed three-stage hierarchical algorithm. details given 'Details'. stage4 vector group sizes stage four testing. group sizes specified sum number individuals/group size specified stage1. group sizes provided stage3 stage4 NULL, group membership matrix constructed four-stage hierarchical algorithm. details given 'Details'.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/GroupMembershipMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a group membership matrix for hierarchical algorithms — GroupMembershipMatrix","text":"matrix specifying group membership individual. rows matrix correspond stages testing columns matrix correspond individuals tested.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/GroupMembershipMatrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct a group membership matrix for hierarchical algorithms — GroupMembershipMatrix","text":"function constructs group membership matrix two-, three-, four-, five-stage hierarchical algorithms. resulting group membership matrix rows corresponding number stages testing columns corresponding individual tested. value specified stage1 corresponds number individuals tested. group membership matrices stage1 specified, two-stage hierarchical algorithm used second stage consist individual testing. group membership matrices stage1 stage2 specified, three-stage hierarchical algorithm used third stage consist individual testing. Group membership matrices four- five-stage hierarchical algorithms follow similar structure. never group sizes specified later stages testing without also providing group sizes earlier stages testing (.e., provide group sizes stage3, group sizes must also provided stage1 stage2).","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/GroupMembershipMatrix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Construct a group membership matrix for hierarchical algorithms — GroupMembershipMatrix","text":"Minh Nguyen Christopher Bilder","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/GroupMembershipMatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a group membership matrix for hierarchical algorithms — GroupMembershipMatrix","text":"","code":"# Generate a group membership matrix for a two-stage #   hierarchical algorithm, within the opChar1() function #   and calculate operating characteristics opChar1(algorithm = \"D2\", p = 0.0193, Se = 0.99, Sp = 0.99,         hier.config = GroupMembershipMatrix(stage1 = 16),         print.time = FALSE) #>  #> Algorithm: Non-informative two-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1 #> 1     16 #>  #> Expected number of tests: 5.3605 #> Expected number of tests per individual: 0.3350 #>  #> Accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.9801 0.9974 0.8819 0.9996         All #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9801 0.9974 0.8819 0.9996  # Generate a group membership matrix for a five-stage #   hierarchical algorithm and calculate the #   operating characteristics for a two-disease assay config.mat <- GroupMembershipMatrix(stage1 = 16,                                     stage2 = c(8,8),                                     stage3 = c(4,4,4,4),                                     stage4 = rep(2, times = 8)) Se <- matrix(data = rep(0.95, 10), nrow = 2, ncol = 5,              dimnames = list(Infection = 1:2, Stage = 1:5)) Sp <- matrix(data = rep(0.99, 10), nrow = 2, ncol = 5,              dimnames = list(Infection = 1:2, Stage = 1:5)) opChar2(algorithm = \"D5\", p.vec = c(0.92, 0.05, 0.02, 0.01),         Se = Se, Sp = Sp, hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Non-informative five-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1 Stage2  Stage3          Stage4 #> 1     16    8,8 4,4,4,4 2,2,2,2,2,2,2,2 #>  #> Expected number of tests: 8.5165 #> Expected number of tests per individual: 0.5323 #>  #> Disease 1 accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.8253 0.9991 0.9835 0.9890         All #>  #> Disease 2 accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.8619 0.9989 0.9599 0.9957         All #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8253 0.9991 0.9835 0.9890 #> 2 0.8619 0.9989 0.9599 0.9957"},{"path":"https://bdhitt.github.io/binGroup2/reference/IndProb.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the individual probabilities used to calculate group testing results — IndProb","title":"Extract the individual probabilities used to calculate group testing results — IndProb","text":"Extract individual probabilities objects class \"opchar\" returned operatingCharacteristics1 (opChar1) operatingCharacteristics2 (opChar2).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/IndProb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the individual probabilities used to calculate group testing results — IndProb","text":"","code":"IndProb(object, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/IndProb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the individual probabilities used to calculate group testing results — IndProb","text":"object object class \"opChar\", individual probabilities extracted. ... Additional arguments passed IndProb (e.g., digits passed signif appropriate rounding).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/IndProb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the individual probabilities used to calculate group testing results — IndProb","text":"Either p.vec, sorted vector individual probabilities (hierarchical group testing algorithms) p.mat, sorted matrix individual probabilities gradient arrangement (array testing algorithms). details given 'Details' section operatingCharacteristics1 (opChar1) operatingCharacteristics2 (opChar2) functions.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/IndProb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract the individual probabilities used to calculate group testing results — IndProb","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/IndProb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract the individual probabilities used to calculate group testing results — IndProb","text":"","code":"config.mat <- matrix(data = c(rep(1, 10), 1:10),                      nrow = 2, ncol = 10, byrow = TRUE) res1 <- opChar1(algorithm = \"D2\", p = 0.05, Se = 0.99, Sp = 0.99,         hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   IndProb(res1) #>  [1] 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05  config.mat <- matrix(data = c(rep(1, 20), rep(1, 10), rep(2, 10),                              rep(c(1, 2, 3, 4), each = 5),                              rep(1, 3), rep(2, 2), rep(3, 3),                              rep(4, 2), rep(5, 3), rep(6, 2),                              rep(7, 3), rep(8, 2), 1:20),                     nrow = 5, ncol = 20, byrow = TRUE) Se <- matrix(data = rep(0.95, 10), nrow = 2, ncol = 5,              dimnames = list(Infection = 1:2, Stage = 1:5)) Sp <- matrix(data = rep(0.99, 10), nrow = 2, ncol = 5,              dimnames = list(Infection = 1:2, Stage = 1:5)) res2 <- opChar2(algorithm = \"ID5\",                 alpha = c(18.25, 0.75, 0.75, 0.25),                 Se = Se, Sp = Sp, hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   IndProb(res2) #>            1        2        3        4        5       6         7        8 #> 00 9.823e-01 0.975000 0.972100 0.971300 0.965400 0.96000 9.402e-01 0.935900 #> 10 1.072e-02 0.002383 0.003461 0.006162 0.016610 0.01073 1.045e-02 0.006992 #> 01 7.018e-03 0.020260 0.017850 0.002381 0.003716 0.02621 4.930e-02 0.055970 #> 11 7.081e-07 0.002310 0.006601 0.020190 0.014290 0.00301 4.435e-05 0.001105 #>           9       10      11       12        13       14        15      16 #> 00 0.933500 0.930400 0.92390 0.918500 9.150e-01 0.905000 0.8931000 0.88750 #> 10 0.023290 0.045030 0.01421 0.028830 3.605e-02 0.009667 0.0766600 0.01287 #> 01 0.034070 0.018470 0.04475 0.048250 4.897e-02 0.016530 0.0299900 0.07005 #> 11 0.009114 0.006096 0.01717 0.004427 3.375e-06 0.068800 0.0003022 0.02959 #>           17       18        19       20 #> 00 0.8792000 0.876000 0.7799000 0.741300 #> 10 0.1032000 0.076680 0.0052100 0.031930 #> 01 0.0172400 0.003444 0.2139000 0.224700 #> 11 0.0004045 0.043840 0.0009579 0.002132"},{"path":"https://bdhitt.github.io/binGroup2/reference/OTC1.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the optimal testing configuration for group testing algorithms that use a single-disease assay — OTC1","title":"Find the optimal testing configuration for group testing algorithms that use a single-disease assay — OTC1","text":"Find optimal testing configuration (OTC) using non-informative informative hierarchical array-based group testing algorithms. Single-disease assays used stage algorithms.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/OTC1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the optimal testing configuration for group testing algorithms that use a single-disease assay — OTC1","text":"","code":"OTC1(   algorithm,   p = NULL,   probabilities = NULL,   Se = 0.99,   Sp = 0.99,   group.sz,   obj.fn = \"ET\",   weights = NULL,   alpha = 2,   trace = TRUE,   print.time = TRUE,   ... )"},{"path":"https://bdhitt.github.io/binGroup2/reference/OTC1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the optimal testing configuration for group testing algorithms that use a single-disease assay — OTC1","text":"algorithm character string defining group testing algorithm used. Non-informative testing options include two-stage hierarchical (\"D2\"), three-stage hierarchical (\"D3\"), square array testing without master pooling (\"A2\"), square array testing master pooling (\"A2M\"). Informative testing options include two-stage hierarchical (\"ID2\"), three-stage hierarchical (\"ID3\"), square array testing without master pooling (\"IA2\"). p overall probability disease used generate vector/matrix individual probabilities. non-informative algorithms, homogeneous set probabilities used. informative algorithms, expectOrderBeta function used generate heterogeneous set probabilities. details given 'Details'. Either p probabilities specified, . probabilities vector individual probabilities, homogeneous non-informative testing algorithms heterogeneous informative testing algorithms. Either  p probabilities specified, . Se vector sensitivity values, one value given stage testing (order). single value provided, sensitivity values assumed equal value stages testing. details given 'Details'. Sp vector specificity values, one value given stage testing (order). single value provided, specificity values assumed equal value stages testing. details given 'Details'. group.sz single group size range group sizes calculate operating characteristics /find OTC. details group size specification given 'Details'. obj.fn list objective functions minimized find OTC. expected number tests per individual, \"ET\", always calculated. Additional options include \"MAR\" (expected number tests divided expected number correct classifications, described Malinovsky et al. (2016)), \"GR\" (linear combination expected number tests, number misclassified negatives, number misclassified positives, described Graff & Roeloffs (1972)). See Hitt et al. (2019) additional details. first objective function specified list used determine results top configurations. details given 'Details'. weights matrix six sets weights GR function. set weights specified row matrix. alpha shape parameter betadistribution specifies degree heterogeneity generated probability vector (informative testing ). trace logical value indicating whether progress calculations printed initial group size provided user. default TRUE. print.time logical value indicating whether length time calculations printed. default TRUE. ... arguments passed expectOrderBeta function, generates vector probabilities informative testing algorithms. details given 'Details'.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/OTC1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the optimal testing configuration for group testing algorithms that use a single-disease assay — OTC1","text":"list containing: algorithm group testing algorithm used calculations. prob probability disease vector individual probabilities, specified user. alpha level heterogeneity generated probability vector (informative testing ). Se vector sensitivity values stage testing. Sp vector specificity values stage testing. opt.ET, opt.MAR, opt.GR list results objective function specified user, containing: OTC list specifying elements optimal testing configuration, may include: Stage1 group size first stage hierarchical testing, applicable. Stage2 group sizes second stage hierarchical testing, applicable. Block.sz block size/initial group size informative Dorfman testing, tested. pool.szs group sizes first stage testing informative Dorfman testing. Array.dim row/column size array testing. Array.sz overall array size array testing (square row/column size). p.vec sorted vector individual probabilities, applicable. p.mat sorted matrix individual probabilities gradient arrangement, applicable. details given 'Details'. ET expected testing expenditure decode individuals algorithm; includes individuals groups hierarchical algorithms entire array array testing. value value objective function per individual. Accuracy matrix overall accuracy measures algorithm. columns correspond pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value overall algorithm. details given 'Details'. Configs data frame containing results best configuration initial group size provided user. columns correspond initial group size, configuration (applicable), overall array size (applicable), expected number tests, value objective function per individual, pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value. results displayed single group.sz provided. details given 'Details'. Top.Configs data frame containing results top overall configurations across initial group sizes provided user. columns correspond initial group size, configuration, expected number tests, value objective function per individual, pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value. results displayed non-informative two-stage hierarchical testing array testing algorithms. details given 'Details'. group.sz Initial group (block) sizes examined find OTC.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/OTC1.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find the optimal testing configuration for group testing algorithms that use a single-disease assay — OTC1","text":"function finds OTC group testing algorithms assay tests one disease computes associated operating characteristics, described Hitt et al. (2019). Available algorithms include two- three-stage hierarchical testing array testing without master pooling. non-informative informative group testing settings allowed algorithm, except informative array testing master pooling unavailable method appeared group testing literature. Operating characteristics calculated expected number tests, pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value individual. informative algorithms p argument specified, expected value order statistics beta distribution found. values used represent disease risk probabilities individual tested. beta distribution two parameters: mean parameter p (overall disease prevalence) shape parameter alpha (heterogeneity level). Depending specified p, alpha, overall group size, simulation may necessary generate vector individual probabilities. done using expectOrderBeta requires user set seed reproduce results. Informative two-stage hierarchical (Dorfman) testing implemented via pool-specific optimal Dorfman (PSOD) method described McMahan et al. (2012a), greedy algorithm proposed PSOD replaced considering possible testing configurations. Informative array testing implemented via gradient method (efficient array design), higher-risk individuals grouped left-columns array. additional details gradient arrangement method informative array testing, see McMahan et al. (2012b). sensitivity/specificity values allowed vary across stages testing. hierarchical testing, different sensitivity/specificity value may used stage testing. array testing, different sensitivity/specificity value may used master pool testing (included), row/column testing, individual testing. values must specified order testing performed. example, values specified (stage 1, stage 2, stage 3) three-stage hierarchical testing (master pool testing, row/column testing, individual testing) array testing master pooling. single sensitivity/specificity value may specified instead. situation, sensitivity/specificity values stages assumed equal. value(s) specified group.sz represent initial (stage 1) group size hierarchical testing row/column size array testing. informative two-stage hierarchical testing, group.sz specified represents block size used pool-specific optimal Dorfman (PSOD) method, initial group (block) tested. details informative two-stage hierarchical testing implemented via PSOD method, see Hitt et al. (2019) McMahan et al. (2012a). single value provided group.sz array testing non-informative two-stage hierarchical testing, operating characteristics calculated optimization performed. single value provided group.sz three-stage hierarchical informative two-stage hierarchical, OTC found possible configurations. range group sizes specified, OTC found group sizes. addition OTC, operating characteristics configurations corresponding initial group size provided user displayed. additional configurations determined whichever objective function (\"ET\", \"MAR\", \"GR\") specified first function call. \"GR\" objective function listed first, first set corresponding weights used. algorithms one configuration initial group size (non-informative two-stage hierarchical array testing algorithms), results initial group size provided. algorithms one possible configuration initial group size (informative two-stage hierarchical three-stage hierarchical algorithms), two sets configurations provided: 1) best configuration initial group size, 2) top 10 configurations initial group size provided user. single value provided group.sz array testing non-informative two-stage hierarchical testing, operating characteristics provided configurations specified user. Results sorted value objective function per individual, value. displayed overall pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value weighted averages corresponding individual accuracy measures individuals within initial group (block) hierarchical algorithm, within entire array array-based algorithm. Expressions averages provided Supplementary Material Hitt et al. (2019). expressions based accuracy definitions given Altman Bland (1994a, 1994b). Individual accuracy measures can calculated using operatingCharacteristics1 (opChar1) function. OTC1 function accepts additional arguments, namely num.sim, passed expectOrderBeta function, generates vector probabilities informative group testing algorithms. num.sim argument specifies number simulations beta distribution simulation used. default, 10,000 simulations used.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/OTC1.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Find the optimal testing configuration for group testing algorithms that use a single-disease assay — OTC1","text":"function returns pooling positive negative predictive values individuals even though measures diagnostic specific; e.g., pooling positive predictive value considered individuals tested positive. Additionally, stage dependent sensitivity specificity values allowed within program (group within stage dependent values allowed). See Bilder et al. (2019) additional information.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/OTC1.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Find the optimal testing configuration for group testing algorithms that use a single-disease assay — OTC1","text":"Altman, D., Bland, J. (1994). “Diagnostic tests 1: Sensitivity specificity.” BMJ, 308, 1552. Altman, D., Bland, J. (1994). “Diagnostic tests 2: Predictive values.” BMJ, 309, 102. Bilder, C., Tebbs, J., McMahan, C. (2019). “Informative group testing multiplex assays.” Biometrics, 75, 278–288. Graff, L., Roeloffs, R. (1972). “Group testing presence test error; extension Dorfman procedure.” Technometrics, 14, 113–122. Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2019). “objective function controversy group testing: Much ado nothing?” Statistics Medicine, 38, 4912–4923. Malinovsky, Y., Albert, P., Roy, . (2016). “Reader reaction: note evaluation group testing algorithms presence misclassification.” Biometrics, 72, 299–302. McMahan, C., Tebbs, J., Bilder, C. (2012a). “Informative Dorfman Screening.” Biometrics, 68, 287–296. McMahan, C., Tebbs, J., Bilder, C. (2012b). “Two-Dimensional Informative Array Testing.” Biometrics, 68, 793–804.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/OTC1.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find the optimal testing configuration for group testing algorithms that use a single-disease assay — OTC1","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/OTC1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the optimal testing configuration for group testing algorithms that use a single-disease assay — OTC1","text":"","code":"# Find the OTC for non-informative #   two-stage hierarchical (Dorfman) testing. OTC1(algorithm = \"D2\", p = 0.05, Se = 0.99, Sp = 0.99,      group.sz = 2:100, obj.fn = \"ET\",      trace = TRUE, print.time = TRUE) #> Initial Group Size = 2 #> Initial Group Size = 3 #> Initial Group Size = 4 #> Initial Group Size = 5 #> Initial Group Size = 6 #> Initial Group Size = 7 #> Initial Group Size = 8 #> Initial Group Size = 9 #> Initial Group Size = 10 #> Initial Group Size = 11 #> Initial Group Size = 12 #> Initial Group Size = 13 #> Initial Group Size = 14 #> Initial Group Size = 15 #> Initial Group Size = 16 #> Initial Group Size = 17 #> Initial Group Size = 18 #> Initial Group Size = 19 #> Initial Group Size = 20 #> Initial Group Size = 21 #> Initial Group Size = 22 #> Initial Group Size = 23 #> Initial Group Size = 24 #> Initial Group Size = 25 #> Initial Group Size = 26 #> Initial Group Size = 27 #> Initial Group Size = 28 #> Initial Group Size = 29 #> Initial Group Size = 30 #> Initial Group Size = 31 #> Initial Group Size = 32 #> Initial Group Size = 33 #> Initial Group Size = 34 #> Initial Group Size = 35 #> Initial Group Size = 36 #> Initial Group Size = 37 #> Initial Group Size = 38 #> Initial Group Size = 39 #> Initial Group Size = 40 #> Initial Group Size = 41 #> Initial Group Size = 42 #> Initial Group Size = 43 #> Initial Group Size = 44 #> Initial Group Size = 45 #> Initial Group Size = 46 #> Initial Group Size = 47 #> Initial Group Size = 48 #> Initial Group Size = 49 #> Initial Group Size = 50 #> Initial Group Size = 51 #> Initial Group Size = 52 #> Initial Group Size = 53 #> Initial Group Size = 54 #> Initial Group Size = 55 #> Initial Group Size = 56 #> Initial Group Size = 57 #> Initial Group Size = 58 #> Initial Group Size = 59 #> Initial Group Size = 60 #> Initial Group Size = 61 #> Initial Group Size = 62 #> Initial Group Size = 63 #> Initial Group Size = 64 #> Initial Group Size = 65 #> Initial Group Size = 66 #> Initial Group Size = 67 #> Initial Group Size = 68 #> Initial Group Size = 69 #> Initial Group Size = 70 #> Initial Group Size = 71 #> Initial Group Size = 72 #> Initial Group Size = 73 #> Initial Group Size = 74 #> Initial Group Size = 75 #> Initial Group Size = 76 #> Initial Group Size = 77 #> Initial Group Size = 78 #> Initial Group Size = 79 #> Initial Group Size = 80 #> Initial Group Size = 81 #> Initial Group Size = 82 #> Initial Group Size = 83 #> Initial Group Size = 84 #> Initial Group Size = 85 #> Initial Group Size = 86 #> Initial Group Size = 87 #> Initial Group Size = 88 #> Initial Group Size = 89 #> Initial Group Size = 90 #> Initial Group Size = 91 #> Initial Group Size = 92 #> Initial Group Size = 93 #> Initial Group Size = 94 #> Initial Group Size = 95 #> Initial Group Size = 96 #> Initial Group Size = 97 #> Initial Group Size = 98 #> Initial Group Size = 99 #> Initial Group Size = 100 #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Non-informative two-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1 #> 1      5 #>  #> Expected number of tests: 2.1585 #> Objective function value: 0.4317 #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9801 0.9981 0.9642 0.9990  # Find the OTC for informative two-stage hierarchical #   (Dorfman) testing. # A vector of individual probabilities is generated using #   the expected value of order statistics from a beta #   distribution with p = 0.01 and a heterogeneity level #   of alpha = 0.5. set.seed(52613) OTC1(algorithm = \"ID2\", p = 0.01, Se = 0.95, Sp = 0.95,      group.sz = 50, obj.fn = c(\"ET\", \"MAR\", \"GR\"),      weights = matrix(data = c(1, 1, 10, 10, 0.5, 0.5),      nrow = 3, ncol = 2, byrow = TRUE), alpha = 0.5,      trace = FALSE, print.time = TRUE, num.sim = 10000) #> Note: Because the maximum group size is 50 or larger, this function may take a significant amount of time to run. Press 'ESC' if you wish to cancel the submitted statements. #>  #>  Number of minutes running:  1.88  #>   #>  #> Algorithm: Informative two-stage hierarchical testing  #>  #> Testing configuration:  #>   Block.sz  pool.szs #> 1       50 25,12,8,5 #>  #> Expected number of tests: 10.0932 #> Objective function value: 0.2019 #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9025 0.9943 0.6115 0.9990  # Find the OTC over all possible testing configurations #   for non-informative three-stage hierarchical testing #   with a specified group size. OTC1(algorithm = \"D3\", p = 0.001, Se = 0.95, Sp = 0.95,      group.sz = 18, obj.fn = \"ET\",      trace = FALSE, print.time = FALSE) #>  #> Algorithm: Non-informative three-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1 Stage2 #> 1     18    9,9 #>  #> Expected number of tests: 1.3295 #> Objective function value: 0.0739 #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8574 0.9995 0.6301 0.9999  # Find the OTC for non-informative three-stage #   hierarchical testing. OTC1(algorithm = \"D3\", p = 0.06, Se = 0.90, Sp = 0.90,      group.sz = 3:30, obj.fn = c(\"ET\", \"MAR\", \"GR\"),      weights = matrix(data = c(1, 1, 10, 10, 100, 100),      nrow = 3, ncol = 2, byrow = TRUE)) #> Initial Group Size = 3 #> Initial Group Size = 4 #> Initial Group Size = 5 #> Initial Group Size = 6 #> Initial Group Size = 7 #> Initial Group Size = 8 #> Initial Group Size = 9 #> Initial Group Size = 10 #> Initial Group Size = 11 #> Initial Group Size = 12 #> Initial Group Size = 13 #> Initial Group Size = 14 #> Initial Group Size = 15 #> Initial Group Size = 16 #> Initial Group Size = 17 #> Initial Group Size = 18 #> Initial Group Size = 19 #> Initial Group Size = 20 #> Initial Group Size = 21 #> Initial Group Size = 22 #> Initial Group Size = 23 #> Initial Group Size = 24 #> Initial Group Size = 25 #> Initial Group Size = 26 #> Initial Group Size = 27 #> Initial Group Size = 28 #> Initial Group Size = 29 #> Initial Group Size = 30 #>  #>  Number of minutes running:  0.26  #>   #>  #> Algorithm: Non-informative three-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1 Stage2 #> 1     12  4,4,4 #>  #> Expected number of tests: 5.0752 #> Objective function value: 0.4229 #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.7290 0.9829 0.7307 0.9827  # Find the OTC over all possible configurations #   for informative three-stage hierarchical testing #   with a specified group size and a heterogeneous #   vector of probabilities. set.seed(1234) OTC1(algorithm = \"ID3\",      probabilities = c(0.012, 0.014, 0.011,                        0.012, 0.010, 0.015),      Se = 0.99, Sp = 0.99, group.sz = 6,      obj.fn = \"ET\",      alpha = 0.5, num.sim = 5000, trace = FALSE) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Informative three-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1 Stage2 #> 1      6    3,3 #>  #> Expected number of tests: 1.3782 #> Objective function value: 0.2297 #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9703 0.9998 0.9802 0.9996  # Calculate the operating characteristics for #   non-informative array testing without master pooling #   with a specified array size. OTC1(algorithm = \"A2\", p = 0.005, Se = 0.95, Sp = 0.95,      group.sz = 8, obj.fn = \"ET\", trace = FALSE) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Non-informative array testing without master pooling  #>  #> Testing configuration:  #>   Array.dim Array.sz #> 1         8       64 #>  #> Expected number of tests: 19.9643 #> Objective function value: 0.3119 #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9057 0.9971 0.6130 0.9995  # Find the OTC for informative array testing without #   master pooling. # A vector of individual probabilities is generated using #   the expected value of order statistics from a beta #   distribution with p = 0.03 and a heterogeneity level #   of alpha = 2. The probabilities are then arranged in #   a matrix using the gradient method. set.seed(1002) OTC1(algorithm = \"IA2\", p = 0.03, Se = 0.95, Sp = 0.95,      group.sz = 2:20, obj.fn = c(\"ET\", \"MAR\", \"GR\"),      weights = matrix(data = c(1, 1, 10, 10, 100, 100),                       nrow = 3, ncol = 2, byrow = TRUE),      alpha = 2) #> Row/Column Size = 2, Array Size = 4 #> Row/Column Size = 3, Array Size = 9 #> Row/Column Size = 4, Array Size = 16 #> Row/Column Size = 5, Array Size = 25 #> Row/Column Size = 6, Array Size = 36 #> Row/Column Size = 7, Array Size = 49 #> Row/Column Size = 8, Array Size = 64 #> Row/Column Size = 9, Array Size = 81 #> Using simulation #> Row/Column Size = 10, Array Size = 100 #> Row/Column Size = 11, Array Size = 121 #> Row/Column Size = 12, Array Size = 144 #> Using simulation #> Row/Column Size = 13, Array Size = 169 #> Using simulation #> Row/Column Size = 14, Array Size = 196 #> Using simulation #> Row/Column Size = 15, Array Size = 225 #> Using simulation #> Row/Column Size = 16, Array Size = 256 #> Using simulation #> Row/Column Size = 17, Array Size = 289 #> Using simulation #> Row/Column Size = 18, Array Size = 324 #> Using simulation #> Row/Column Size = 19, Array Size = 361 #> Using simulation #> Row/Column Size = 20, Array Size = 400 #>  #>  Number of minutes running:  0.35  #>   #>  #> Algorithm: Informative array testing without master pooling  #>  #> Testing configuration:  #>   Array.dim Array.sz #> 1        12      144 #>  #> Expected number of tests: 39.3354 #> Objective function value: 0.2732 #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8589 0.9959 0.8603 0.9958  # Find the OTC for non-informative array testing #   with master pooling. The calculations may not #   be completed instantaneously. OTC1(algorithm = \"A2M\", p = 0.04, Se = 0.90, Sp = 0.90,      group.sz = 2:20, obj.fn = \"ET\") #> Row/Column Size = 2, Array Size = 4 #> Row/Column Size = 3, Array Size = 9 #> Row/Column Size = 4, Array Size = 16 #> Row/Column Size = 5, Array Size = 25 #> Row/Column Size = 6, Array Size = 36 #> Row/Column Size = 7, Array Size = 49 #> Row/Column Size = 8, Array Size = 64 #> Row/Column Size = 9, Array Size = 81 #> Row/Column Size = 10, Array Size = 100 #> Row/Column Size = 11, Array Size = 121 #> Row/Column Size = 12, Array Size = 144 #> Row/Column Size = 13, Array Size = 169 #> Row/Column Size = 14, Array Size = 196 #> Row/Column Size = 15, Array Size = 225 #> Row/Column Size = 16, Array Size = 256 #> Row/Column Size = 17, Array Size = 289 #> Row/Column Size = 18, Array Size = 324 #> Row/Column Size = 19, Array Size = 361 #> Row/Column Size = 20, Array Size = 400 #>  #>  Number of minutes running:  0.24  #>   #>  #> Algorithm: Non-informative array testing with master pooling  #>  #> Testing configuration:  #>   Array.dim Array.sz #> 1        12      144 #>  #> Expected number of tests: 45.6655 #> Objective function value: 0.3171 #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.6565 0.9863 0.6666 0.9857"},{"path":"https://bdhitt.github.io/binGroup2/reference/OTC2.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the optimal testing configuration for group testing algorithms that use a multiplex assay for two diseases — OTC2","title":"Find the optimal testing configuration for group testing algorithms that use a multiplex assay for two diseases — OTC2","text":"Find optimal testing configuration (OTC) using non-informative informative hierarchical array-based group testing algorithms. Multiplex assays two diseases used stage algorithms.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/OTC2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the optimal testing configuration for group testing algorithms that use a multiplex assay for two diseases — OTC2","text":"","code":"OTC2(   algorithm,   p.vec = NULL,   probabilities = NULL,   alpha = NULL,   Se,   Sp,   ordering = matrix(data = c(0, 1, 0, 1, 0, 0, 1, 1), nrow = 4, ncol = 2),   group.sz,   trace = TRUE,   print.time = TRUE,   ... )"},{"path":"https://bdhitt.github.io/binGroup2/reference/OTC2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the optimal testing configuration for group testing algorithms that use a multiplex assay for two diseases — OTC2","text":"algorithm character string defining group testing algorithm used. Non-informative testing options include two-stage hierarchical (\"D2\"), three-stage hierarchical (\"D3\"), square array testing without master pooling (\"A2\"), square array testing master pooling (\"A2M\"). Informative testing options include two-stage hierarchical (\"ID2\") three-stage hierarchical (\"ID3\") testing. p.vec vector overall joint probabilities. joint probabilities assumed equal individuals algorithm (non-informative testing ). four joint probabilities consider: \\(p_{00}\\), probability individual tests negative diseases; \\(p_{10}\\), probability individual tests positive first disease; \\(p_{01}\\), probability individual tests positive second disease; \\(p_{11}\\), probability individual tests positive diseases. joint probabilities must sum 1. one p.vec, probabilities, alpha specified. probabilities matrix joint probabilities individual, rows correspond four joint probabilities columns correspond individual algorithm. one p.vec, probabilities, alpha specified. alpha vector containing positive shape parameters Dirichlet distribution (informative testing ). vector used generate heterogeneous matrix joint probabilities individual. vector must length 4. details given 'Details'. one p.vec, probabilities, alpha specified. Se matrix sensitivity values, one value given disease (infection) stage testing. rows matrix correspond disease \\(k=1,2\\), columns matrix correspond stage testing \\(s=1,...,S\\). vector 2 values provided, sensitivity values associated disease \\(k\\) assumed equal \\(k\\)th value vector stages testing. details given 'Details'. Sp matrix specificity values, one value given disease (infection) stage testing. rows matrix correspond disease \\(k=1,2\\), columns matrix correspond stage testing \\(s=1,...,S\\). vector 2 values provided, specificity values associated disease \\(k\\) assumed equal \\(k\\)th value vector stages testing. details given 'Details'. ordering matrix detailing ordering binary responses diseases. columns matrix correspond disease rows matrix correspond 4 sets binary responses two diseases. ordering used joint probabilities. default ordering (p_00, p_10, p_01, p_11). group.sz single group size range group sizes calculate operating characteristics /find OTC. details group size specification given 'Details'. trace logical value indicating whether progress calculations printed initial group size provided user. default TRUE. print.time logical value indicating whether length time calculations printed. default TRUE. ... additional arguments passed functions hierarchical testing multiplex assays two diseases.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/OTC2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the optimal testing configuration for group testing algorithms that use a multiplex assay for two diseases — OTC2","text":"list containing: algorithm group testing algorithm used calculations. prob.vec vector joint probabilities provided user, applicable (non-informative algorithms ). joint.p matrix joint probabilities individual provided user, applicable. alpha.vec alpha vector provided user, applicable (informative algorithms ). Se matrix sensitivity values disease stage testing. Sp matrix specificity values disease stage testing. opt.ET list containing: OTC list specifying elements optimal testing configuration, may include: Stage1 group size first stage hierarchical testing, applicable. Stage2 group sizes second stage hierarchical testing, applicable. Block.sz block size/initial group size informative Dorfman testing, tested. pool.szs group sizes first stage testing informative Dorfman testing. Array.dim row/column size array testing. Array.sz overall array size array testing (square row/column size). p.mat matrix joint probabilities individual algorithm. row corresponds one four joint probabilities. column corresponds individual testing algorithm. ET expected testing expenditure OTC. value value expected number tests per individual. Accuracy matrix overall accuracy measures algorithm. rows correspond disease. columns correspond pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value overall algorithm. details given 'Details'. Configs data frame containing results best configuration initial group size provided user. columns correspond initial group size, configuration (applicable), overall array size (applicable), expected number tests, value objective function per individual, accuracy measures disease. Accuracy measures include pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value. results displayed single group.sz provided. details given 'Details'. Top.Configs data frame containing results top configurations initial group size provided user. columns correspond initial group size, configuration, expected number tests, value objective function per individual, accuracy measures disease. Accuracy measures include pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value. results displayed non-informative two-stage hierarchical testing array testing algorithms. details given 'Details'. group.sz Initial group (block) sizes examined find OTC.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/OTC2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find the optimal testing configuration for group testing algorithms that use a multiplex assay for two diseases — OTC2","text":"function finds OTC standard group testing algorithms multiplex assay tests two diseases computes associated operating characteristics. Calculations hierarchical group testing algorithms performed described Bilder et al. (2019) calculations array-based group testing algorithms performed described Hou et al. (2019). Available algorithms include two- three-stage hierarchical testing array testing without master pooling. non-informative informative group testing settings allowed hierarchical algorithms. non-informative group testing settings allowed array testing algorithms. Operating characteristics calculated expected number tests, pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value individual. informative algorithms alpha argument specified, heterogeneous matrix joint probabilities individual generated using Dirichlet distribution. done using rBeta2009::rdirichlet requires user set seed reproduce results. See Bilder et al. (2019) additional details use Dirichlet distribution purpose. sensitivity/specificity values allowed vary across stages testing. hierarchical testing, different sensitivity/specificity value may used stage testing. array testing, different sensitivity/specificity value may used master pool testing (included), row/column testing, individual testing. values must specified order testing performed. example, values specified (stage 1, stage 2, stage 3) three-stage hierarchical testing (master pool testing, row/column testing, individual testing) array testing master pooling. vector 2 sensitivity/specificity values may specified, sensitivity/specificity values stages testing assumed equal. first value vector used stage testing first disease, second value vector used stage testing second disease. value(s) specified group.sz represent initial (stage 1) group size hierarchical testing row/column size array testing. single value provided group.sz two-stage hierarchical array testing, operating characteristics calculated optimization performed. single value provided group.sz three-stage hierarchical, OTC found possible configurations initial group size. range group sizes specified, OTC found group sizes. addition OTC, operating characteristics configurations corresponding initial group size provided user displayed. algorithms one configuration initial group size (non-informative two-stage hierarchical array testing algorithms), results initial group size provided. algorithms one possible configuration initial group size (informative two-stage hierarchical three-stage hierarchical algorithms), two sets configurations provided: 1) best configuration initial group size, 2) top 10 configurations initial group size provided user. single value provided group.sz array testing non-informative two-stage hierarchical testing, operating characteristics provided configurations specified user. Results sorted value objective function per individual, value. displayed overall pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value weighted averages corresponding individual accuracy measures individuals within initial group (block) hierarchical algorithm, within entire array array-based algorithm. Expressions averages provided Supplementary Material Hitt et al. (2019). expressions based accuracy definitions given Altman Bland (1994a, 1994b). Individual accuracy measures can calculated using operatingCharacteristics2 (opChar2) function.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/OTC2.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Find the optimal testing configuration for group testing algorithms that use a multiplex assay for two diseases — OTC2","text":"function returns pooling positive negative predictive values individuals even though measures diagnostic specific; e.g., pooling positive predictive value considered individuals tested positive. Additionally, stage dependent sensitivity specificity values allowed within program (group within stage dependent values allowed). See Bilder et al. (2019) additional information.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/OTC2.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Find the optimal testing configuration for group testing algorithms that use a multiplex assay for two diseases — OTC2","text":"Altman, D., Bland, J. (1994). “Diagnostic tests 1: Sensitivity specificity.” BMJ, 308, 1552. Altman, D., Bland, J. (1994). “Diagnostic tests 2: Predictive values.” BMJ, 309, 102. Bilder, C., Tebbs, J., McMahan, C. (2019). “Informative group testing multiplex assays.” Biometrics, 75, 278–288. Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2019). “objective function controversy group testing: Much ado nothing?” Statistics Medicine, 38, 4912–4923. Hou, P., Tebbs, J., Wang, D., McMahan, C., Bilder, C. (2021). “Array testing multiplex assays.” Biostatistics, 21, 417–431. McMahan, C., Tebbs, J., Bilder, C. (2012a). “Informative Dorfman Screening.” Biometrics, 68, 287–296.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/OTC2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find the optimal testing configuration for group testing algorithms that use a multiplex assay for two diseases — OTC2","text":"function written Brianna D. Hitt. calls ET..stages.new PSePSpAllStages, originally written Christopher Bilder Bilder et al. (2019), ARRAY, originally written Peijie Hou Hou et al. (2020). functions ET..stages.new, PSePSpAllStages, ARRAY obtained http://chrisbilder.com/grouptesting/. Minor modifications made functions inclusion binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/OTC2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the optimal testing configuration for group testing algorithms that use a multiplex assay for two diseases — OTC2","text":"","code":"# Find the OTC for non-informative two-stage #   hierarchical (Dorfman) testing Se <- matrix(data = c(0.95, 0.95, 0.99, 0.99), nrow = 2, ncol = 2,              dimnames = list(Infection = 1:2, Stage = 1:2)) Sp <- matrix(data = c(0.96, 0.96, 0.98, 0.98), nrow = 2, ncol = 2,              dimnames = list(Infection = 1:2, Stage = 1:2)) OTC2(algorithm = \"D2\", p.vec = c(0.90, 0.04, 0.04, 0.02),      Se = Se, Sp = Sp, group.sz = 2:10) #> Initial Group Size = 2 #> Initial Group Size = 3 #> Initial Group Size = 4 #> Initial Group Size = 5 #> Initial Group Size = 6 #> Initial Group Size = 7 #> Initial Group Size = 8 #> Initial Group Size = 9 #> Initial Group Size = 10 #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Non-informative two-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1 #> 1      4 #>  #> Expected number of tests: 2.5325 #> Objective function value: 0.6331 #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9626 0.9931 0.8989 0.9976 #> 2 0.9626 0.9931 0.8989 0.9976  # Find the OTC over all possible testing configurations #   for informative two-stage hierarchical (Dorfman) #   testing with a specified group size. # A matrix of joint probabilities for each individual is #   generated using the Dirichlet distribution. Se <- matrix(data = rep(0.95, 4), nrow = 2, ncol = 2,              dimnames = list(Infection = 1:2, Stage = 1:2)) Sp <- matrix(data = rep(0.99, 4), nrow = 2, ncol = 2,              dimnames = list(Infection = 1:2, Stage = 1:2)) set.seed(1002) OTC2(algorithm = \"ID2\", alpha = c(18.25, 0.75, 0.75, 0.25),      Se = Se, Sp = Sp, group.sz = 18:22) #> Block Size = 18 #> Block Size = 19 #> Block Size = 20 #> Block Size = 21 #> Block Size = 22 #>  #>  Number of minutes running:  0.46  #>   #>  #> Algorithm: Informative two-stage hierarchical testing  #>  #> Testing configuration:  #>   Block.sz  pool.szs #> 1       21 6,5,4,3,3 #>  #> Expected number of tests: 10.6045 #> Objective function value: 0.5050 #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9311 0.8848 0.2652 0.9965 #> 2 0.9325 0.8895 0.2555 0.9969  # Find the OTC for non-informative three-stage #   hierarchical testing. Se <- matrix(data = rep(0.95, 6), nrow = 2, ncol = 3,              dimnames = list(Infection = 1:2, Stage = 1:3)) Sp <- matrix(data = rep(0.99, 6), nrow = 2, ncol = 3,              dimnames = list(Infection = 1:2, Stage = 1:3)) OTC2(algorithm = \"D3\", p.vec = c(0.91, 0.04, 0.04, 0.01),      Se = Se, Sp = Sp, group.sz = 3:12) #> Initial Group Size = 3 #> Initial Group Size = 4 #> Initial Group Size = 5 #> Initial Group Size = 6 #> Initial Group Size = 7 #> Initial Group Size = 8 #> Initial Group Size = 9 #> Initial Group Size = 10 #> Initial Group Size = 11 #> Initial Group Size = 12 #>  #>  Number of minutes running:  0.04  #>   #>  #> Algorithm: Non-informative three-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1 Stage2 #> 1      9  3,3,3 #>  #> Expected number of tests: 4.7958 #> Objective function value: 0.5329 #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8906 0.9980 0.9595 0.9943 #> 2 0.8906 0.9980 0.9595 0.9943  # Find the OTC over all possible configurations #   for informative three-stage hierarchical #   testing with a specified group size #   and a heterogeneous matrix of joint #   probabilities for each individual. set.seed(8791) Se <- matrix(data = rep(0.95, 6), nrow = 2, ncol = 3,              dimnames = list(Infection = 1:2, Stage = 1:3)) Sp <- matrix(data = rep(0.99, 6), nrow = 2, ncol = 3,              dimnames = list(Infection = 1:2, Stage = 1:3)) p.unordered <- t(rBeta2009::rdirichlet(n = 8,                             shape = c(18.25, 0.75, 0.75, 0.25))) p.ordered <- p.unordered[, order(1 - p.unordered[1,])] OTC2(algorithm = \"ID3\", probabilities = p.ordered,          Se = Se, Sp = Sp, group.sz = 8,          trace = FALSE, print.time = FALSE) #>  #> Algorithm: Informative three-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1  Stage2 #> 1      8 4,2,1,1 #>  #> Expected number of tests: 4.2845 #> Objective function value: 0.5356 #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9211 0.9977 0.9640 0.9948 #> 2 0.9155 0.9977 0.9609 0.9947  # Find the OTC for non-informative array testing #   without master pooling. Se <- matrix(data = rep(0.95, 4), nrow = 2, ncol = 2,              dimnames = list(Infection = 1:2, Stage = 1:2)) Sp <- matrix(data = rep(0.99, 4), nrow = 2, ncol = 2,              dimnames = list(Infection = 1:2, Stage = 1:2)) OTC2(algorithm = \"A2\", p.vec = c(0.90, 0.04, 0.04, 0.02),      Se = Se, Sp = Sp, group.sz = 2:10) #> Row/Column Size = 2, Array Size = 4 #> Row/Column Size = 3, Array Size = 9 #> Row/Column Size = 4, Array Size = 16 #> Row/Column Size = 5, Array Size = 25 #> Row/Column Size = 6, Array Size = 36 #> Row/Column Size = 7, Array Size = 49 #> Row/Column Size = 8, Array Size = 64 #> Row/Column Size = 9, Array Size = 81 #> Row/Column Size = 10, Array Size = 100 #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Non-informative array testing without master pooling  #>  #> Testing configuration:  #>   Array.dim Array.sz #> 1         8       64 #>  #> Expected number of tests: 33.9130 #> Objective function value: 0.5299 #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8947 0.9976 0.9601 0.9933 #> 2 0.8947 0.9976 0.9601 0.9933  # Find the OTC for non-informative array testing #   with master pooling. Se <- matrix(data = rep(0.95, 6), nrow = 2, ncol = 3,              dimnames = list(Infection = 1:2, Stage = 1:3)) Sp <- matrix(data = rep(0.99, 6), nrow = 2, ncol = 3,              dimnames = list(Infection = 1:2, Stage = 1:3)) OTC2(algorithm = \"A2M\", p.vec = c(0.90, 0.04, 0.04, 0.02),      Se = Se, Sp = Sp, group.sz = 10,      trace = FALSE, print.time = FALSE) #>  #> Algorithm: Non-informative array testing with master pooling  #>  #> Testing configuration:  #>   Array.dim Array.sz #> 1        10      100 #>  #> Expected number of tests: 56.2898 #> Objective function value: 0.5629 #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8937 0.9968 0.9475 0.9932 #> 2 0.8937 0.9968 0.9475 0.9932"},{"path":"https://bdhitt.github.io/binGroup2/reference/Sterrett.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary measures for Sterrett algorithms — Sterrett","title":"Summary measures for Sterrett algorithms — Sterrett","text":"Summary measures Sterrett algorithms.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Sterrett.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary measures for Sterrett algorithms — Sterrett","text":"","code":"Sterrett(   p,   Sp,   Se,   plot = FALSE,   plot.cut.dorf = FALSE,   cond.prob.plot = FALSE,   font.name = \"sans\" )"},{"path":"https://bdhitt.github.io/binGroup2/reference/Sterrett.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary measures for Sterrett algorithms — Sterrett","text":"p vector individual risk probabilities. Sp specificity diagnostic test. Se sensitivity diagnostic test. plot logical; TRUE, plot informative Sterrett CDFs displayed. details given 'Details'. plot.cut.dorf logical; TRUE, cut-tree Dorfman testing displayed. details given 'Details'. cond.prob.plot logical; TRUE, second axis conditional probability plot displayed right side plot. font.name name font used plots.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Sterrett.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary measures for Sterrett algorithms — Sterrett","text":"list containing: mean.sd data frame containing mean standard deviation expected number tests one-stage informative Sterrett (1SIS), two-stage informative Sterrett (2SIS), full informative Sterrett (FIS), Dorfman testing. PMF data frame containing probability mass function number tests possible one-stage informative Sterrett (1SIS), two-stage informative Sterrett (2SIS), full informative Sterrett (FIS), Dorfman testing. CDF data frame containing cumulative distribution function number tests possible one-stage informative Sterrett (1SIS), two-stage informative Sterrett (2SIS), full informative Sterrett (FIS), Dorfman testing. cond.PMF data frame containing conditional probability mass function number tests possible one-stage informative Sterrett (1SIS), two-stage informative Sterrett (2SIS), full informative Sterrett (FIS) testing. cond.moments data frame containing mean standard deviation conditional moments one-stage informative Sterrett (1SIS), two-stage informative Sterrett (2SIS), full informative Sterrett (FIS) testing. save.diff.CDF data frame containing sum differences cumulative distribution function pairwise comparison one-stage informative Sterrett (1SIS), two-stage informative Sterrett (2SIS), full informative Sterrett (FIS), Dorfman testing. p vector containing probabilities positivity individual.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Sterrett.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summary measures for Sterrett algorithms — Sterrett","text":"function calculates summary measures informative Sterrett algorithms. Informative algorithms include one-stage informative Sterrett (1SIS), two-stage informative Sterrett (2SIS), full informative Sterrett (FIS), Dorfman (two-stage hierarchical testing). mean standard deviation number tests, probability mass function (PMF), cumulative distribution function (CDF) calculated informative Sterrett algorithms Dorfman testing. Conditional PMFs conditional moments calculated informative Sterrett algorithms. Subtracting mean number tests two procedures gives area difference CDFs. area difference calculated pairwise comparison 1SIS, 2SIS, FIS, Dorfman testing. CDF plots provide visualization probabilities distributed number tests. CDFs increase rapidly 1 correspond efficient retesting procedures. Non-informative Sterrett (NIS) decodes positive groups retesting individuals random, \\(!\\) different possible NIS implementations. CDFs found permuting elements vector individual risk probabilities using FIS CDF expression without reordering individual probabilities. , FIS procedure uses efficient NIS implementation, retest individuals order descending probabilities. implementing informative Sterrett algorithms large number individuals, algorithm used compute PMF number tests FIS. done automatically Sterrett \\(>12\\). algorithm described detail Appendix Bilder et al. (2010).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Sterrett.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Summary measures for Sterrett algorithms — Sterrett","text":"Bilder, C., Tebbs, J., Chen, P. (2010). “Informative retesting.” Journal American Statistical Association, 105, 942–955.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/Sterrett.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summary measures for Sterrett algorithms — Sterrett","text":"function originally written info.gt Christopher Bilder Bilder et al. (2010). function obtained http://chrisbilder.com/grouptesting/. Minor modifications made inclusion function binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/Sterrett.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary measures for Sterrett algorithms — Sterrett","text":"","code":"# Example 1: FIS provides the smallest mean #   number of tests and the smallest standard #   deviation. 2SIS has slightly larger mean #   and standard deviation than FIS, but #   its performance is comparable, indicating #   2SIS may be preferred because it is #   easier to implement. set.seed(1231) p.vec1 <- rbeta(n = 8, shape1 = 1, shape2 = 10) save.it1 <- Sterrett(p = p.vec1, Sp = 0.90, Se = 0.95) save.it1 #>  #>  PMF  #>    tests one.stage.IS.PMF two.stage.IS.PMF  full.IS.PMF Dorfman.PMF #> 1      1       0.48835471       0.48835471 4.883547e-01   0.4883547 #> 2      3       0.09599437       0.09599437 9.599437e-02          NA #> 3      4       0.07394624       0.07394624 7.394624e-02          NA #> 4      5       0.04488706       0.06729731 6.729731e-02          NA #> 5      6       0.03972361       0.06516755 6.516755e-02          NA #> 6      7       0.02005756       0.05073281 5.444685e-02          NA #> 7      8       0.01199658       0.03078615 3.887818e-02          NA #> 8      9       0.04084418       0.05308898 6.080128e-02   0.5116453 #> 9     10       0.18419568       0.03045444 3.711694e-02          NA #> 10    11               NA       0.04417744 1.426534e-02          NA #> 11    12               NA               NA 3.262503e-03          NA #> 12    13               NA               NA 4.362291e-04          NA #> 13    14               NA               NA 3.151575e-05          NA #> 14    15               NA               NA 9.742431e-07          NA #>  #>  Mean and standard deviation  #>    Method     mean       sd #> 1    1SIS 3.980830 3.566401 #> 2    2SIS 3.669331 3.201135 #> 3     FIS 3.612345 3.095739 #> 4 Dorfman 5.093162 3.998915  # Example 2: One individual is \"high risk\" and #   the others are \"low risk\". Since there is #   only one high-risk individual, the three #   informative Sterrett procedures perform #   similarly. All three informative Sterrett #   procedures offer large improvements over #   Dorfman testing. p.vec2 <- c(rep(x = 0.01, times = 9), 0.5) save.it2 <- Sterrett(p = p.vec2, Sp = 0.99, Se = 0.99) save.it2 #>  #>  PMF  #>    tests one.stage.IS.PMF two.stage.IS.PMF  full.IS.PMF Dorfman.PMF #> 1      1      0.457623451      0.457623451 4.576235e-01   0.4576235 #> 2      3      0.443665745      0.443665745 4.436657e-01          NA #> 3      4      0.004573797      0.004573797 4.573797e-03          NA #> 4      5      0.004527994      0.009011738 9.011738e-03          NA #> 5      6      0.004482659      0.009010726 9.010726e-03          NA #> 6      7      0.004437787      0.009008842 9.097171e-03          NA #> 7      8      0.004393373      0.009006102 9.182748e-03          NA #> 8      9      0.004349413      0.009002524 9.269199e-03          NA #> 9     10      0.004305902      0.008998125 9.356497e-03          NA #> 10    11      0.017294239      0.022024328 2.247606e-02   0.5423765 #> 11    12      0.050345641      0.014470169 1.501690e-02          NA #> 12    13               NA      0.003604455 1.619568e-03          NA #> 13    14               NA               NA 9.329207e-05          NA #> 14    15               NA               NA 3.048583e-06          NA #> 15    16               NA               NA 6.026634e-08          NA #> 16    17               NA               NA 7.178150e-10          NA #> 17    18               NA               NA 4.761248e-12          NA #> 18    19               NA               NA 1.355528e-14          NA #>  #>  Mean and standard deviation  #>    Method     mean       sd #> 1    1SIS 2.799251 2.754353 #> 2    2SIS 2.674921 2.433704 #> 3     FIS 2.670015 2.416430 #> 4 Dorfman 6.423765 4.982010  # Example 3: Two individuals are at higher #   risk than the others. All three informative #   Sterrett procedures provide large #   improvements over Dorfman testing. # Due to the large initial group size, an #   algorithm (described in the Appendix of #   Bilder et al. (2010)) is used for FIS. #   The Sterrett() function does this #   automatically for I>12. p.vec3 <- c(rep(x = 0.01, times = 98), 0.1, 0.1) save.it3 <- Sterrett(p = p.vec3, Sp = 0.99, Se = 0.99) save.it3 #>  #>  PMF  #>     tests one.stage.IS.PMF two.stage.IS.PMF   full.IS.PMF Dorfman.PMF #> 1       1      0.306455946      0.306455946  3.064559e-01   0.3064559 #> 2       3      0.033353253      0.033353253  3.335325e-02          NA #> 3       4      0.032954071      0.032954071  3.295407e-02          NA #> 4       5      0.003045396      0.006994767  6.994767e-03          NA #> 5       6      0.003013996      0.003742329  3.742329e-03          NA #> 6       7      0.002982934      0.003763610  3.807238e-03          NA #> 7       8      0.002952208      0.003784067  3.841593e-03          NA #> 8       9      0.002921811      0.003803714  3.876891e-03          NA #> 9      10      0.002891742      0.003822568  3.912522e-03          NA #> 10     11      0.002861996      0.003840643  3.948500e-03          NA #> 11     12      0.002832569      0.003857954  3.984829e-03          NA #> 12     13      0.002803457      0.003874515  4.021513e-03          NA #> 13     14      0.002774658      0.003890339  4.058554e-03          NA #> 14     15      0.002746168      0.003905442  4.095957e-03          NA #> 15     16      0.002717982      0.003919836  4.133724e-03          NA #> 16     17      0.002690097      0.003933535  4.171859e-03          NA #> 17     18      0.002662511      0.003946552  4.210366e-03          NA #> 18     19      0.002635219      0.003958900  4.249249e-03          NA #> 19     20      0.002608218      0.003970592  4.288510e-03          NA #> 20     21      0.002581505      0.003981640  4.328154e-03          NA #> 21     22      0.002555077      0.003992058  4.368185e-03          NA #> 22     23      0.002528930      0.004001856  4.408605e-03          NA #> 23     24      0.002503061      0.004011047  4.449420e-03          NA #> 24     25      0.002477468      0.004019643  4.490632e-03          NA #> 25     26      0.002452146      0.004027655  4.532246e-03          NA #> 26     27      0.002427093      0.004035094  4.574265e-03          NA #> 27     28      0.002402305      0.004041973  4.616694e-03          NA #> 28     29      0.002377780      0.004048301  4.659536e-03          NA #> 29     30      0.002353516      0.004054090  4.702795e-03          NA #> 30     31      0.002329507      0.004059350  4.746476e-03          NA #> 31     32      0.002305753      0.004064092  4.790582e-03          NA #> 32     33      0.002282250      0.004068326  4.835118e-03          NA #> 33     34      0.002258996      0.004072062  4.880088e-03          NA #> 34     35      0.002235986      0.004075310  4.925495e-03          NA #> 35     36      0.002213220      0.004078081  4.971345e-03          NA #> 36     37      0.002190693      0.004080383  5.017641e-03          NA #> 37     38      0.002168404      0.004082226  5.064388e-03          NA #> 38     39      0.002146349      0.004083619  5.111590e-03          NA #> 39     40      0.002124526      0.004084573  5.159252e-03          NA #> 40     41      0.002102933      0.004085095  5.207378e-03          NA #> 41     42      0.002081567      0.004085194  5.255973e-03          NA #> 42     43      0.002060425      0.004084880  5.305040e-03          NA #> 43     44      0.002039505      0.004084161  5.354585e-03          NA #> 44     45      0.002018805      0.004083045  5.404613e-03          NA #> 45     46      0.001998321      0.004081541  5.455127e-03          NA #> 46     47      0.001978052      0.004079656  5.506134e-03          NA #> 47     48      0.001957995      0.004077400  5.557636e-03          NA #> 48     49      0.001938148      0.004074779  5.609640e-03          NA #> 49     50      0.001918508      0.004071802  5.662150e-03          NA #> 50     51      0.001899074      0.004068477  5.715171e-03          NA #> 51     52      0.001879843      0.004064810  5.768709e-03          NA #> 52     53      0.001860812      0.004060809  5.822767e-03          NA #> 53     54      0.001841980      0.004056481  5.877351e-03          NA #> 54     55      0.001823344      0.004051835  5.932466e-03          NA #> 55     56      0.001804902      0.004046876  5.988118e-03          NA #> 56     57      0.001786653      0.004041611  6.044311e-03          NA #> 57     58      0.001768593      0.004036048  6.101051e-03          NA #> 58     59      0.001750722      0.004030193  6.158343e-03          NA #> 59     60      0.001733036      0.004024052  6.216193e-03          NA #> 60     61      0.001715533      0.004017633  6.274605e-03          NA #> 61     62      0.001698213      0.004010942  6.333586e-03          NA #> 62     63      0.001681072      0.004003984  6.393140e-03          NA #> 63     64      0.001664109      0.003996766  6.453274e-03          NA #> 64     65      0.001647322      0.003989294  6.513992e-03          NA #> 65     66      0.001630709      0.003981574  6.575302e-03          NA #> 66     67      0.001614269      0.003973611  6.637207e-03          NA #> 67     68      0.001597998      0.003965413  6.699715e-03          NA #> 68     69      0.001581895      0.003956983  6.762831e-03          NA #> 69     70      0.001565960      0.003948328  6.826561e-03          NA #> 70     71      0.001550189      0.003939454  6.890911e-03          NA #> 71     72      0.001534580      0.003930365  6.955886e-03          NA #> 72     73      0.001519133      0.003921067  7.021494e-03          NA #> 73     74      0.001503846      0.003911565  7.087739e-03          NA #> 74     75      0.001488716      0.003901865  7.154629e-03          NA #> 75     76      0.001473742      0.003891971  7.222169e-03          NA #> 76     77      0.001458923      0.003881888  7.290366e-03          NA #> 77     78      0.001444256      0.003871621  7.359227e-03          NA #> 78     79      0.001429740      0.003861174  7.428757e-03          NA #> 79     80      0.001415373      0.003850554  7.498963e-03          NA #> 80     81      0.001401155      0.003839763  7.569851e-03          NA #> 81     82      0.001387082      0.003828808  7.641430e-03          NA #> 82     83      0.001373155      0.003817691  7.713704e-03          NA #> 83     84      0.001359370      0.003806418  7.786680e-03          NA #> 84     85      0.001345727      0.003794992  7.860367e-03          NA #> 85     86      0.001332224      0.003783419  7.934770e-03          NA #> 86     87      0.001318859      0.003771702  8.009896e-03          NA #> 87     88      0.001305632      0.003759845  8.085753e-03          NA #> 88     89      0.001292540      0.003747853  8.162347e-03          NA #> 89     90      0.001279582      0.003735729  8.239686e-03          NA #> 90     91      0.001266757      0.003723477  8.317776e-03          NA #> 91     92      0.001254063      0.003711101  8.396626e-03          NA #> 92     93      0.001241499      0.003698605  8.476243e-03          NA #> 93     94      0.001229064      0.003685992  8.556633e-03          NA #> 94     95      0.001216756      0.003673266  8.637805e-03          NA #> 95     96      0.001204573      0.003660430  8.719766e-03          NA #> 96     97      0.001192516      0.003647489  8.802524e-03          NA #> 97     98      0.001180581      0.003634445  8.886086e-03          NA #> 98     99      0.001168768      0.003621303  8.970461e-03          NA #> 99    100      0.001157076      0.003608064  9.055656e-03          NA #> 100   101      0.004782683      0.007231913  1.277886e-02   0.6935441 #> 101   102      0.435432747      0.007652733  1.329996e-02          NA #> 102   103               NA      0.231736159  1.068667e-02          NA #> 103   104               NA               NA  6.511757e-03          NA #> 104   105               NA               NA  3.108059e-03          NA #> 105   106               NA               NA  1.203933e-03          NA #> 106   107               NA               NA  3.894191e-04          NA #> 107   108               NA               NA  1.075320e-04          NA #> 108   109               NA               NA  2.579244e-05          NA #> 109   110               NA               NA  5.448610e-06          NA #> 110   111               NA               NA  1.025161e-06          NA #> 111   112               NA               NA  1.733941e-07          NA #> 112   113               NA               NA  2.656919e-08          NA #> 113   114               NA               NA  3.712601e-09          NA #> 114   115               NA               NA  4.757506e-10          NA #> 115   116               NA               NA  5.618201e-11          NA #> 116   117               NA               NA  6.140131e-12          NA #> 117   118               NA               NA  6.233651e-13          NA #> 118   119               NA               NA  5.898293e-14          NA #> 119   120               NA               NA  5.216813e-15          NA #> 120   121               NA               NA  4.324339e-16          NA #> 121   122               NA               NA  3.367395e-17          NA #> 122   123               NA               NA  2.468602e-18          NA #> 123   124               NA               NA  1.706968e-19          NA #> 124   125               NA               NA  1.115254e-20          NA #> 125   126               NA               NA  6.895809e-22          NA #> 126   127               NA               NA  4.040977e-23          NA #> 127   128               NA               NA  2.247242e-24          NA #> 128   129               NA               NA  1.187406e-25          NA #> 129   130               NA               NA  5.967784e-27          NA #> 130   131               NA               NA  2.855818e-28          NA #> 131   132               NA               NA  1.302426e-29          NA #> 132   133               NA               NA  5.665645e-31          NA #> 133   134               NA               NA  2.352644e-32          NA #> 134   135               NA               NA  9.332165e-34          NA #> 135   136               NA               NA  3.538425e-35          NA #> 136   137               NA               NA  1.283205e-36          NA #> 137   138               NA               NA  4.453230e-38          NA #> 138   139               NA               NA  1.479650e-39          NA #> 139   140               NA               NA  4.709123e-41          NA #> 140   141               NA               NA  1.436118e-42          NA #> 141   142               NA               NA  4.198203e-44          NA #> 142   143               NA               NA  1.176782e-45          NA #> 143   144               NA               NA  3.163783e-47          NA #> 144   145               NA               NA  8.160154e-49          NA #> 145   146               NA               NA  2.019565e-50          NA #> 146   147               NA               NA  4.796855e-52          NA #> 147   148               NA               NA  1.093580e-53          NA #> 148   149               NA               NA  2.393213e-55          NA #> 149   150               NA               NA  5.027772e-57          NA #> 150   151               NA               NA  1.014017e-58          NA #> 151   152               NA               NA  1.963305e-60          NA #> 152   153               NA               NA  3.649106e-62          NA #> 153   154               NA               NA  6.510431e-64          NA #> 154   155               NA               NA  1.114836e-65          NA #> 155   156               NA               NA  1.832014e-67          NA #> 156   157               NA               NA  2.888593e-69          NA #> 157   158               NA               NA  4.369089e-71          NA #> 158   159               NA               NA  6.337728e-73          NA #> 159   160               NA               NA  8.814315e-75          NA #> 160   161               NA               NA  1.174931e-76          NA #> 161   162               NA               NA  1.500527e-78          NA #> 162   163               NA               NA  1.835276e-80          NA #> 163   164               NA               NA  2.148740e-82          NA #> 164   165               NA               NA  2.406958e-84          NA #> 165   166               NA               NA  2.578158e-86          NA #> 166   167               NA               NA  2.638983e-88          NA #> 167   168               NA               NA  2.579605e-90          NA #> 168   169               NA               NA  2.406214e-92          NA #> 169   170               NA               NA  2.140051e-94          NA #> 170   171               NA               NA  1.813149e-96          NA #> 171   172               NA               NA  1.461964e-98          NA #> 172   173               NA               NA 1.120644e-100          NA #> 173   174               NA               NA 8.156741e-103          NA #> 174   175               NA               NA 5.630204e-105          NA #> 175   176               NA               NA 3.680238e-107          NA #> 176   177               NA               NA 2.274557e-109          NA #> 177   178               NA               NA 1.326912e-111          NA #> 178   179               NA               NA 7.292705e-114          NA #> 179   180               NA               NA 3.768112e-116          NA #> 180   181               NA               NA 1.826130e-118          NA #> 181   182               NA               NA 8.278994e-121          NA #> 182   183               NA               NA 3.500954e-123          NA #> 183   184               NA               NA 1.376320e-125          NA #> 184   185               NA               NA 5.011191e-128          NA #> 185   186               NA               NA 1.682597e-130          NA #> 186   187               NA               NA 5.184140e-133          NA #> 187   188               NA               NA 1.457182e-135          NA #> 188   189               NA               NA 3.711276e-138          NA #> 189   190               NA               NA 8.494911e-141          NA #> 190   191               NA               NA 1.730261e-143          NA #> 191   192               NA               NA 3.097718e-146          NA #> 192   193               NA               NA 4.799140e-149          NA #> 193   194               NA               NA 6.303391e-152          NA #> 194   195               NA               NA 6.824821e-155          NA #> 195   196               NA               NA 5.848385e-158          NA #> 196   197               NA               NA 3.719024e-161          NA #> 197   198               NA               NA 1.560148e-164          NA #> 198   199               NA               NA 3.238585e-168          NA #>  #>  Mean and standard deviation  #>    Method     mean       sd #> 1    1SIS 53.81318 46.86916 #> 2    2SIS 45.57633 42.89603 #> 3     FIS 39.79628 37.32272 #> 4 Dorfman 70.35441 46.10214"},{"path":"https://bdhitt.github.io/binGroup2/reference/TOD.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary measures for the Thresholded Optimal Dorfman (TOD) algorithm — TOD","title":"Summary measures for the Thresholded Optimal Dorfman (TOD) algorithm — TOD","text":"Summary measures Thresholded Optimal Dorfman (TOD) algorithm.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/TOD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary measures for the Thresholded Optimal Dorfman (TOD) algorithm — TOD","text":"","code":"TOD(p.vec, Se, Sp, max = 15, init.group.sz = NULL, threshold = NULL)"},{"path":"https://bdhitt.github.io/binGroup2/reference/TOD.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary measures for the Thresholded Optimal Dorfman (TOD) algorithm — TOD","text":"p.vec vector individual risk probabilities. Se sensitivity diagnostic test. Sp specificity diagnostic test. max maximum allowable group size. details given 'Details'. init.group.sz initial group size used TOD, threshold specified. details given 'Details'. threshold threshold value TOD. threshold specified, one found algorithmically. details given 'Details'.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/TOD.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary measures for the Thresholded Optimal Dorfman (TOD) algorithm — TOD","text":"list containing: prob vector individual risk probabilities, specified user. Se sensitivity diagnostic test, specified user. Sp specificity diagnostic test, specified user. group.sz initial group size used TOD, applicable. thresh.val threshold value used TOD, applicable. OTC list specifying elements optimal testing configuration, may include: Block.sz block size/initial group size informative Dorfman testing, tested. pool.szs group sizes first stage testing informative Dorfman testing. ET expected testing expenditure decode individuals algorithm. Var variance testing expenditure decode individuals algorithm. Accuracy list containing: Individual matrix accuracy measures individual. rows correspond unique set accuracy measures algorithm. Individuals set accuracy measures displayed together single row matrix. columns correspond pool index, individual risk probability, pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value individuals row matrix. Overall matrix overall accuracy measures algorithm. columns correspond pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value overall algorithm. details given 'Details'.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/TOD.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summary measures for the Thresholded Optimal Dorfman (TOD) algorithm — TOD","text":"function finds characteristics informative two-stage hierarchical (Dorfman) decoding process. Characteristics found include expected expenditure decoding process, variance expenditure decoding process, pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value individual overall algorithm. Calculations characteristics done using equations presented McMahan et al. (2012). Thresholded Optimal Dorfman (TOD) informative Dorfman algorithm \\(N\\) individuals partitioned two classes, low-risk high-risk individuals. threshold can specified using optional threshold argument. Alternatively, TOD algorithm can identify optimal threshold value. low-risk individuals tested using optimal common pool size, high-risk individuals tested individually. desired, user can add constraint maximum allowable group size (max), group contain maximum allowable number individuals. displayed overall pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value weighted averages corresponding individual accuracy measures individuals within initial group (block) hierarchical algorithm, within entire array array-based algorithm. Expressions averages provided Supplementary Material Hitt et al. (2019). expressions based accuracy definitions given Altman Bland (1994a, 1994b).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/TOD.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Summary measures for the Thresholded Optimal Dorfman (TOD) algorithm — TOD","text":"Altman, D., Bland, J. (1994). “Diagnostic tests 1: Sensitivity specificity.” BMJ, 308, 1552. Altman, D., Bland, J. (1994). “Diagnostic tests 2: Predictive values.” BMJ, 309, 102. Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2019). “objective function controversy group testing: Much ado nothing?” Statistics Medicine, 38, 4912–4923. McMahan, C., Tebbs, J., Bilder, C. (2012a). “Informative Dorfman Screening.” Biometrics, 68, 287–296.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/TOD.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summary measures for the Thresholded Optimal Dorfman (TOD) algorithm — TOD","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/TOD.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary measures for the Thresholded Optimal Dorfman (TOD) algorithm — TOD","text":"","code":"# Example 1: Find the characteristics of an informative #   Dorfman algorithm, using the TOD procedure. set.seed(1002) p.vec <- expectOrderBeta(p = 0.01, alpha = 2, size = 20) TOD(p = p.vec, Se = 0.95, Sp = 0.95, max = 5,     threshold = 0.015) #> Overall block size: 20  #> Ordered individual probabilities of positivity:  #>  0.0016 0.0025 0.0033 0.004 0.0047 0.0053 0.006 0.0067 0.0074 0.0082 0.0089 0.0098 0.0107 0.0117 0.0129 0.0143 0.0159 0.018 0.0211 0.027  #> Group sizes for individuals ordered by probabilities of positivity:  #>  4 4 4 4 1 1 1 1  #>   #> Expected number of tests: 9.22  #> Variance for the number of tests: 4.49   # Example 2: Find the threshold value for the TOD #   procedure algorithmically. Then, find #   characteristics of the algorithm. TOD(p = p.vec, Se = 0.95, Sp = 0.95, max = 5,     init.group.sz = 10) #> Overall block size: 20  #> Ordered individual probabilities of positivity:  #>  0.0016 0.0025 0.0033 0.004 0.0047 0.0053 0.006 0.0067 0.0074 0.0082 0.0089 0.0098 0.0107 0.0117 0.0129 0.0143 0.0159 0.018 0.0211 0.027  #> Group sizes for individuals ordered by probabilities of positivity:  #>  5 5 5 5  #>   #> Expected number of tests: 5.88  #> Variance for the number of tests: 8.43"},{"path":"https://bdhitt.github.io/binGroup2/reference/binGroup2.html","id":null,"dir":"Reference","previous_headings":"","what":"binGroup2: Identification and Estimation using Group Testing — binGroup2","title":"binGroup2: Identification and Estimation using Group Testing — binGroup2","text":"Methods group testing identification estimation problems.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/binGroup2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"binGroup2: Identification and Estimation using Group Testing — binGroup2","text":"Methods identification positive items group testing designs: Operating characteristics (e.g., expected number tests) calculated commonly used hierarchical array-based algorithms. Optimal testing configurations algorithm can found well. Please see Hitt et al. (2019) specific details. Methods estimation inference proportions group testing designs: estimating one proportion difference proportions, confidence interval methods included account different pool sizes. Functions hypothesis testing proportions, calculation power, calculation expected width confidence intervals also included. Furthermore, regression methods simulation group testing data implemented simple pooling (Dorfman testing without retests), halving, array testing designs. binGroup2 package based upon binGroup package originally designed group testing estimation problem. time, additional functions estimation group testing identification problem included. Due diverse styles resulting additions, created binGroup2 way unify functions coherent structure incorporate additional functions identification. binGroup2 package provides main functionality binGroup package, can used place binGroup package. name “binGroup” originates assumption basic estimation group testing number positive groups binomial distribution. advanced estimation methods longer make assumption, continue binGroup name consistency. Bilder (2019a,b) provide introductions group testing. papers additional details group testing available http://chrisbilder.com/grouptesting/. research supported National Institutes Health grant R01 AI121351.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/binGroup2.html","id":"identification","dir":"Reference","previous_headings":"","what":"Identification","title":"binGroup2: Identification and Estimation using Group Testing — binGroup2","text":"binGroup2 package focuses group testing identification problem using hierarchical array-based group testing algorithms. OTC1 function implements number group testing algorithms, described Hitt et al. (2019), calculate operating characteristics find optimal testing configuration range possible initial group sizes /testing configurations (sets subsequent group sizes). OTC2 function multiplex assay tests two diseases. operatingCharacteristics1 (opChar1) operatingCharacteristics2 (opChar2) functions calculate operating characteristics specified testing configuration assays test one two diseases, respectively. functions allow sensitivity specificity differ across stages testing. means accuracy diagnostic test can differ stages hierarchical testing algorithm row/column testing individual testing array testing algorithm.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/binGroup2.html","id":"estimation","dir":"Reference","previous_headings":"","what":"Estimation","title":"binGroup2: Identification and Estimation using Group Testing — binGroup2","text":"binGroup2 package also provides functions estimation inference proportions group testing designs. propCI function calculates point estimate confidence intervals single proportion group testing data. propDiffCI function difference proportions. number confidence interval methods available groups equal different sizes. gtWidth function calculates expected width confidence intervals group testing. gtTest function calculates p-values hypothesis tests single proportions. gtPower function calculates power reject hypothesis. designPower function iterates either number groups group size one-parameter group testing design pre-specified power level achieved. designEst function finds optimal group size corresponding minimal mean-squared error point estimator. gtReg function implements regression methods gtSim function simulates group testing data simple pooling, halving, array testing designs.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/binGroup2.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"binGroup2: Identification and Estimation using Group Testing — binGroup2","text":"Altman, D., Bland, J. (1994). “Diagnostic tests 1: Sensitivity specificity.” BMJ, 308, 1552. Altman, D., Bland, J. (1994). “Diagnostic tests 2: Predictive values.” BMJ, 309, 102. Biggerstaff, B. (2008). “Confidence intervals difference proportions estimated pooled samples.” Journal Agricultural, Biological, Environmental Statistics, 13, 478–496. Bilder, C., Tebbs, J., Chen, P. (2010). “Informative retesting.” Journal American Statistical Association, 105, 942–955. Bilder, C., Tebbs, J., McMahan, C. (2019). “Informative group testing multiplex assays.” Biometrics, 75, 278–288. Bilder, C. (2019a). “Group Testing Estimation.” Wiley StatsRef: Statistics Reference Online. Bilder, C. (2019b). “Group Testing Identification.” Wiley StatsRef: Statistics Reference Online. Bilder, C., Iwen, P., Abdalhamid, B., Tebbs, J., McMahan, C. (2020). “Tests short supply? Try group testing.” Significance, 17, 15. Black, M., Bilder, C., Tebbs, J. (2012). “Group testing heterogeneous populations using halving algorithms.” Journal Royal Statistical Society. Series C: Applied Statistics, 61, 277–290. Black, M., Bilder, C., Tebbs, J. (2015). “Optimal retesting configurations hierarchical group testing.” Journal Royal Statistical Society. Series C: Applied Statistics, 64, 693–710. Graff, L., Roeloffs, R. (1972). “Group testing presence test error; extension Dorfman procedure.” Technometrics, 14, 113–122. Hepworth, G. (1996). “Exact confidence intervals proportions estimated group testing.” Biometrics, 52, 1134–1146. Hepworth, G., Biggerstaff, B. (2017). “Bias correction estimating proportions pooled testing.” Journal Agricultural, Biological, Environmental Statistics, 22, 602–614. Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2019). “objective function controversy group testing: Much ado nothing?” Statistics Medicine, 38, 4912–4923. Hou, P., Tebbs, J., Wang, D., McMahan, C., Bilder, C. (2021). “Array testing multiplex assays.” Biostatistics, 21, 417–431. Malinovsky, Y., Albert, P., Roy, . (2016). “Reader reaction: note evaluation group testing algorithms presence misclassification.” Biometrics, 72, 299–302. McMahan, C., Tebbs, J., Bilder, C. (2012a). “Informative Dorfman Screening.” Biometrics, 68, 287–296. McMahan, C., Tebbs, J., Bilder, C. (2012b). “Two-Dimensional Informative Array Testing.” Biometrics, 68, 793–804. Schaarschmidt, F. (2007). “Experimental design one-sided confidence intervals hypothesis tests binomial group testing.” Communications Biometry Crop Science, 2, 32–40. ISSN 1896-0782. Swallow, W. (1985). “Group testing estimating infection rates probabilities disease transmission.” Phytopathology, 75, 882–889. Tebbs, J., Bilder, C. (2004). “Confidence interval procedures probability disease transmission multiple-vector-transfer designs.” Journal Agricultural, Biological, Environmental Statistics, 9, 75–90. Vansteelandt, S., Goetghebeur, E., Verstraeten, T. (2000). “Regression models disease prevalence diagnostic tests pools serum samples.” Biometrics, 56, 1126–1133. Verstraeten, T., Farah, B., Duchateau, L., Matu, R. (1998). “Pooling sera reduce cost HIV surveillance: feasibility study rural Kenyan district.” Tropical Medicine & International Health, 3, 747–750. Xie, M. (2001). “Regression analysis group testing samples.” Statistics Medicine, 20, 1957–1969.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/binGroup2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"binGroup2: Identification and Estimation using Group Testing — binGroup2","text":"Maintainer: Brianna Hitt brianna.hitt@afacademy.af.edu (ORCID) Authors: Christopher Bilder (ORCID) Frank Schaarschmidt (ORCID) Brad Biggerstaff (ORCID) Christopher McMahan (ORCID) Joshua Tebbs (ORCID) contributors: Boan Zhang [contributor] Michael Black [contributor] Peijie Hou [contributor] Peng Chen [contributor] Minh Nguyen [contributor]","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/binGroup2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"binGroup2: Identification and Estimation using Group Testing — binGroup2","text":"","code":"# 1) Identification using hierarchical and array-based #   group testing algorithms with an assay that tests #   for one disease.  # 1.1) Find the optimal testing configuration over a #   range of initial group sizes, using informative #   three-stage hierarchical testing, where #   p denotes the overall prevalence of disease (mean #    parameter of a beta distribution); #   Se denotes the sensitivity of the diagnostic test; #   Sp denotes the specificity of the diagnostic test; #   group.sz denotes the range of initial pool sizes #   for consideration; #   obj.fn specifies the objective functions for which #   to find results; and #   alpha is the heterogeneity level. set.seed(1002) results1 <- OTC1(algorithm = \"ID3\", p = 0.025, Se = 0.95,                  Sp = 0.95, group.sz = 3:20,                  obj.fn = \"ET\", alpha = 2) #> Initial Group Size = 3 #> Initial Group Size = 4 #> Initial Group Size = 5 #> Initial Group Size = 6 #> Initial Group Size = 7 #> Initial Group Size = 8 #> Initial Group Size = 9 #> Initial Group Size = 10 #> Initial Group Size = 11 #> Initial Group Size = 12 #> Initial Group Size = 13 #> Initial Group Size = 14 #> Initial Group Size = 15 #> Initial Group Size = 16 #> Initial Group Size = 17 #> Initial Group Size = 18 #> Initial Group Size = 19 #> Initial Group Size = 20 #>  #>  Number of minutes running:  0.02  #>   summary(results1) #>  #> Algorithm: Informative three-stage hierarchical testing  #>  #> Optimal testing configuration: #>    Stage 1 Stage 2 #> ET      17 6,4,4,3 #>  #> Expected number of tests: #>    E(T)  Value #> ET 4.14 0.2436 #>  #> E(T) denotes the expected number of tests. #> Value denotes the objective function value per individual. #>  #> Overall accuracy of the algorithm: #>       PSe    PSp   PPPV   PNPV #> ET 0.8574 0.9961 0.8493 0.9963 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value.  # 1.2) Find the optimal testing configuration using #   non-informative array testing without master pooling. # The sensitivity and specificity differ for row/column #   testing and individual testing. results2 <- OTC1(algorithm = \"A2\", p = 0.05,                  Se = c(0.95, 0.99), Sp = c(0.95, 0.98),                  group.sz = 3:15, obj.fn = \"ET\") #> Row/Column Size = 3, Array Size = 9 #> Row/Column Size = 4, Array Size = 16 #> Row/Column Size = 5, Array Size = 25 #> Row/Column Size = 6, Array Size = 36 #> Row/Column Size = 7, Array Size = 49 #> Row/Column Size = 8, Array Size = 64 #> Row/Column Size = 9, Array Size = 81 #> Row/Column Size = 10, Array Size = 100 #> Row/Column Size = 11, Array Size = 121 #> Row/Column Size = 12, Array Size = 144 #> Row/Column Size = 13, Array Size = 169 #> Row/Column Size = 14, Array Size = 196 #> Row/Column Size = 15, Array Size = 225 #>  #>  Number of minutes running:  0.07  #>   summary(results2) #>  #> Algorithm: Non-informative array testing without master pooling  #>  #> Optimal testing configuration: #>    Row/column size Array size #> ET              10        100 #>  #> Expected number of tests: #>     E(T)  Value #> ET 38.52 0.3852 #>  #> E(T) denotes the expected number of tests. #> Value denotes the objective function value per individual. #>  #> Overall accuracy of the algorithm: #>       PSe    PSp   PPPV   PNPV #> ET 0.8943 0.9971 0.9411 0.9945 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value.  # 1.3) Calculate the operating characteristics using #   informative two-stage hierarchical (Dorfman) testing, #   implemented via the pool-specific optimal Dorfman #   (PSOD) method described in McMahan et al. (2012a). # Hierarchical testing configurations are specified by #   a matrix in the hier.config argument. The rows of #   the matrix correspond to the stages of the #   hierarchical testing algorithm, the columns #   correspond to the individuals to be tested, and the #   cell values correspond to the group number of each #   individual at each stage. config.mat <- matrix(data = c(rep(1, 5), rep(2, 4), 3, 1:10),                      nrow = 2, ncol = 10, byrow = TRUE) set.seed(8791) results3 <- opChar1(algorithm = \"ID2\", p = 0.02,                     Se = 0.95, Sp = 0.99,                     hier.config = config.mat, alpha = 0.5) #>  #>  Number of minutes running:  0  #>   summary(results3) #>  #> Algorithm: Informative two-stage hierarchical testing  #>  #> Testing configuration: #> Block size: 10 #> Group sizes: 5,4,1 #>  #> Expected number of tests: 3.57 #> Expected number of tests per individual: 0.3566 #>  #> Accuracy for individuals: #>       PSe    PSp   PPPV   PNPV Individuals #> 1  0.9025 0.9997 0.6329 0.9999           1 #> 2  0.9025 0.9997 0.8426 0.9998           2 #> 3  0.9025 0.9997 0.9190 0.9997           3 #> 4  0.9025 0.9998 0.9562 0.9994           4 #> 5  0.9025 0.9998 0.9758 0.9991           5 #> 6  0.9025 0.9991 0.9291 0.9987           6 #> 7  0.9025 0.9991 0.9535 0.9980           7 #> 8  0.9025 0.9992 0.9708 0.9971           8 #> 9  0.9025 0.9993 0.9839 0.9956           9 #> 10 0.9500 0.9900 0.8843 0.9960          10 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9202 0.9986 0.9306 0.9984 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value.  # 1.4) Calculate the operating characteristics using #   non-informative four-stage hierarchical testing. config.mat <- matrix(data = c(rep(1, 15), rep(c(1, 2, 3), each = 5),                               rep(1, 3), rep(2, 2),                               rep(3, 3), rep(4, 2),                               rep(5, 4), 6, 1:15),                      nrow = 4, ncol = 15, byrow = TRUE) results4 <- opChar1(algorithm = \"D4\", p = 0.008,                     Se = 0.96, Sp = 0.98,                     hier.config = config.mat,                     a = c(1, 4, 6, 9, 11, 15)) #>  #>  Number of minutes running:  0  #>   summary(results4) #>  #> Algorithm: Non-informative four-stage hierarchical testing  #>  #> Testing configuration: #> Stage 1: 15 #> Stage 2: 5,5,5 #> Stage 3: 3,2,3,2,4,1 #>  #> Expected number of tests: 1.91 #> Expected number of tests per individual: 0.1272 #>  #> Accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.8493 0.9997 0.9596 0.9988         1,6 #> 2 0.8493 0.9998 0.9784 0.9988         4,9 #> 3 0.8493 0.9996 0.9416 0.9988          11 #> 4 0.8847 0.9994 0.9202 0.9991          15 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8517 0.9997 0.9568 0.9988 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value.   # 2) Identification using hierarchical and array-based #   group testing algorithms with a multiplex assay that #   tests for two diseases.  # 2.1) Find the optimal testing configuration using #   non-informative two-stage hierarchical testing, given #   p.vec, a vector of overall joint probabilities of disease; #   Se, a vector of sensitivity values for each disease; and #   Sp, a vector of specificity values for each disease. # Se and Sp can also be specified as a matrix, where one #   value is specified for each disease at each stage of #   testing. results5 <- OTC2(algorithm = \"D2\",                  p.vec = c(0.90, 0.04, 0.04, 0.02),                  Se = c(0.99, 0.99), Sp = c(0.99, 0.99),                  group.sz = 3:20) #> Initial Group Size = 3 #> Initial Group Size = 4 #> Initial Group Size = 5 #> Initial Group Size = 6 #> Initial Group Size = 7 #> Initial Group Size = 8 #> Initial Group Size = 9 #> Initial Group Size = 10 #> Initial Group Size = 11 #> Initial Group Size = 12 #> Initial Group Size = 13 #> Initial Group Size = 14 #> Initial Group Size = 15 #> Initial Group Size = 16 #> Initial Group Size = 17 #> Initial Group Size = 18 #> Initial Group Size = 19 #> Initial Group Size = 20 #>  #>  Number of minutes running:  0  #>   summary(results5) #>  #> Algorithm: Non-informative two-stage hierarchical testing  #>  #> Optimal testing configuration: #>    Stage 1 #> ET       4 #>  #> Expected number of tests: #>    E(T)  Value #> ET 2.42 0.6045 #>  #> E(T) denotes the expected number of tests. #> Value denotes the objective function value per individual. #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9845 0.9969 0.9525 0.9990 #> 2 0.9845 0.9969 0.9525 0.9990 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value.  # 2.2) Calculate the operating characteristics for #   informative five-stage hierarchical testing, given #   alpha.vec, a vector of shape parameters for the #   Dirichlet distribution; #   Se, a matrix of sensitivity values; and #   Sp, a matrix of specificity values. Se <- matrix(data = rep(0.95, 10), nrow = 2, ncol = 5, byrow = TRUE) Sp <- matrix(data = rep(0.99, 10), nrow = 2, ncol = 5, byrow = TRUE) config.mat <- matrix(data = c(rep(1, 24), rep(1, 18),                               rep(2, 6), rep(1, 9),                               rep(2, 9), rep(3, 4), 4, 5,                               rep(1, 6), rep(2, 3),                               rep(3, 5), rep(4, 4),                               rep(5, 3), 6, rep(NA, 2),                               1:21, rep(NA, 3)),                      nrow = 5, ncol = 24, byrow = TRUE) results6 <- opChar2(algorithm = \"ID5\",                     alpha = c(18.25, 0.75, 0.75, 0.25),                     Se = Se, Sp = Sp,                     hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   summary(results6) #>  #> Algorithm: Informative five-stage hierarchical testing  #>  #> Testing configuration: #> Stage 1: 24 #> Stage 2: 18,6 #> Stage 3: 9,9,4,1,1 #> Stage 4: 6,3,5,4,3,1 #>  #> Expected number of tests: 12.41 #> Expected number of tests per individual: 0.5169 #>  #> Disease 1 accuracy for individuals: #>   PSe PSp PPPV PNPV Individuals #> 1  NA  NA   NA   NA        <NA> #>  #> Disease 2 accuracy for individuals: #>   PSe PSp PPPV PNPV Individuals #> 1  NA  NA   NA   NA        <NA> #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8808 0.9978 0.9584 0.9933 #> 2 0.8950 0.9978 0.9437 0.9956 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value.  # 3) Estimation of the overall disease prevalence and #   calculation of confidence intervals.  # 3.1) Suppose 3 groups out of 24 test positively. #   Each group has a size of 7. propCI(x = 3, m = 7, n = 24, ci.method = \"CP\") #>  #> 95 percent Clopper-Pearson confidence interval: #>  [ 0.003838, 0.05432 ] #> Point estimate (Maximum Likelihood): 0.0189 propCI(x = 3, m = 7, n = 24, ci.method = \"Blaker\") #>  #> 95 percent Blaker confidence interval: #>  [ 0.005056, 0.0513 ] #> Point estimate (Maximum Likelihood): 0.0189 propCI(x = 3, m = 7, n = 24, ci.method = \"score\") #>  #> 95 percent Wilson score confidence interval: #>  [ 0.006325, 0.05164 ] #> Point estimate (Maximum Likelihood): 0.0189 propCI(x = 3, m = 7, n = 24, ci.method = \"soc\") #>  #> 95 percent Second-Order Corrected confidence interval: #>  [ 0.003365, 0.04737 ] #> Point estimate (Maximum Likelihood): 0.0189  # 3.2) Consider the following situation: #   0 out of 5 groups test positively with groups #   of size 1 (individual testing), #   0 out of 5 groups test positively with groups of size 5, #   1 out of 5 groups test positively with groups of size 10, #   2 out of 5 groups test positively with groups of size 50 propCI(x = c(0, 0, 1, 2), m = c(1, 5, 10, 50),        n = c(5, 5, 5, 5), pt.method = \"Gart\",        ci.method = \"skew-score\") #>  #> 95 percent Skew-Corrected score (Gart) confidence interval: #>  [ 0.002806, 0.02879 ] #> Point estimate (Gart's Correction): 0.01027  # 4) Estimate a group testing regression model.  # 4.1) Fit a group testing regression model with #   simple pooling using the \"hivsurv\" dataset. data(hivsurv) fit1 <- gtReg(type = \"sp\",               formula = groupres ~ AGE + EDUC.,               data = hivsurv, groupn = gnum,               sens = 0.9, spec = 0.9, method = \"Xie\") #>  #>  Number of minutes running: 0  #>   summary(fit1) #>  #> Call: #> gtReg(type = \"sp\", formula = groupres ~ AGE + EDUC., data = hivsurv,  #>     groupn = gnum, sens = 0.9, spec = 0.9, method = \"Xie\") #>  #> Deviance Residuals:  #>     Min       1Q   Median       3Q      Max   #> -1.1729  -0.9406  -0.8281   1.3386   1.6497   #>  #> Coefficients: #>             Estimate Std. Error z value Pr(>|z|)   #> (Intercept) -3.11976    1.84816  -1.688   0.0914 . #> AGE         -0.05692    0.07777  -0.732   0.4642   #> EDUC.        0.82833    0.50717   1.633   0.1024   #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #>     Null deviance: 154.3  on 85  degrees of freedom #> Residual deviance: 109.5  on 83  degrees of freedom #> AIC: 115.5 #>  #> Number of iterations in EM: 43 #>   # 4.2) Simulate data for the halving protocol, and #   fit a group testing regression model. set.seed(46) gt.data <- gtSim(type = \"halving\", par = c(-6, 0.1),                  gshape = 17, gscale = 1.4,                  size1 = 1000, size2 = 5,                  sens = 0.95, spec = 0.95) fit2 <- gtReg(type = \"halving\", formula = gres ~ x,               data = gt.data, groupn = groupn,               subg = subgroup, retest = retest,               sens = 0.95, spec = 0.95,               start = c(-6, 0.1), trace = TRUE) #> beta is -5.729041 0.09475251 \tdiff is 0.05247494  #> beta is -5.681919 0.09362653 \tdiff is 0.0118833  #> beta is -5.673643 0.09340603 \tdiff is 0.002355171  #> beta is -5.672209 0.09336529 \tdiff is 0.0004361546  #> beta is -5.671964 0.09335803 \tdiff is 7.774958e-05  #>  #>  Number of minutes running: 0  #>   summary(fit2) #>  #> Call: #> gtReg(type = \"halving\", formula = gres ~ x, data = gt.data, groupn = groupn,  #>     subg = subgroup, retest = retest, sens = 0.95, spec = 0.95,  #>     start = c(-6, 0.1), trace = TRUE) #>  #> Deviance Residuals:  #>     Min       1Q   Median       3Q      Max   #> -0.9189  -0.6950  -0.6348  -0.5744   1.9966   #>  #> Coefficients: #>             Estimate Std. Error z value Pr(>|z|)     #> (Intercept) -5.67196    0.80874  -7.013 2.33e-12 *** #> x            0.09336    0.02866   3.258  0.00112 **  #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #> AIC: 365.9 #>  #> Number of iterations in EM: 5 #>"},{"path":"https://bdhitt.github.io/binGroup2/reference/coef.gtReg.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract coefficients from a fitted group testing model — coef.gtReg","title":"Extract coefficients from a fitted group testing model — coef.gtReg","text":"Extract coefficients objects class \"gtReg\" returned gtReg.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/coef.gtReg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract coefficients from a fitted group testing model — coef.gtReg","text":"","code":"# S3 method for class 'gtReg' coef(object, digits = max(3, getOption(\"digits\") - 3), ...)  # S3 method for class 'gtReg' coefficients(object, digits = max(3, getOption(\"digits\") - 3), ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/coef.gtReg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract coefficients from a fitted group testing model — coef.gtReg","text":"object object class \"gtReg\", created gtReg, coefficients extracted. digits digits rounding. ... currently used.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/coef.gtReg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract coefficients from a fitted group testing model — coef.gtReg","text":"Model coefficients extracted object object.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/coef.gtReg.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract coefficients from a fitted group testing model — coef.gtReg","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/coef.gtReg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract coefficients from a fitted group testing model — coef.gtReg","text":"","code":"data(hivsurv) fit1 <- gtReg(formula = groupres ~ AGE * EDUC.,               data = hivsurv, groupn = gnum,               linkf = \"probit\") coefficients(object = fit1) #> (Intercept)         AGE       EDUC.   AGE:EDUC.  #>    -2.53000     0.01300     0.79650    -0.01794"},{"path":"https://bdhitt.github.io/binGroup2/reference/designEst.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimal group size determination based on minimal MSE when estimating an overall prevalence — designEst","title":"Optimal group size determination based on minimal MSE when estimating an overall prevalence — designEst","text":"Find group size s fixed number groups n assumed true proportion p.tr, mean squared error (MSE) point estimator minimal bias within restriction.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/designEst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimal group size determination based on minimal MSE when estimating an overall prevalence — designEst","text":"","code":"designEst(n, smax, p.tr, biasrest = 0.05)"},{"path":"https://bdhitt.github.io/binGroup2/reference/designEst.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimal group size determination based on minimal MSE when estimating an overall prevalence — designEst","text":"n integer specifying fixed number groups. smax integer specifying maximum group size allowed planning design. p.tr assumed true proportion \"positive\" trait population, specified value 0 1. biasrest value 0 1 specifying absolute bias maximally allowed.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/designEst.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimal group size determination based on minimal MSE when estimating an overall prevalence — designEst","text":"list containing: call function call result data frame containing: mse mean squared error estimator. sout group size s MSE estimator minimal given n p.tr bias restriction biasrest violated. case minimum MSE achieved group size \\(s>=smax\\), value smax returned. exp expected value estimator. varp variance estimator. bias bias estimator. bias.reached logical value indicating whether bias restriction biasrest violated. smax.reached logical value indicating whether maximum group size allowed smax reached.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/designEst.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Optimal group size determination based on minimal MSE when estimating an overall prevalence — designEst","text":"Swallow (1985) recommends use upper bound expected range true proportion p.tr optimization design. details, see Swallow (1985). Note specified number groups must less \\(n=1020\\).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/designEst.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Optimal group size determination based on minimal MSE when estimating an overall prevalence — designEst","text":"Swallow, W. (1985). “Group testing estimating infection rates probabilities disease transmission.” Phytopathology, 75, 882–889.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/designEst.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Optimal group size determination based on minimal MSE when estimating an overall prevalence — designEst","text":"function originally written Frank Schaarschmidt estDesign function binGroup package. Minor modifications made inclusion binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/designEst.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimal group size determination based on minimal MSE when estimating an overall prevalence — designEst","text":"","code":"# Compare to Table 1 in Swallow (1985): designEst(n = 10, smax = 100, p.tr = 0.001) #>  #> The minimum MSE of 1.202e-06 is achieved with a group size of s >= 100  #> The estimator has expected value = 0.001056 and variance = 1.199e-06, #>    with bias = 5.633e-05  #>  designEst(n = 10, smax = 100, p.tr = 0.01) #>  #> The minimum MSE of 4.58e-05 is achieved with a group size of 33  #> The estimator has expected value = 0.01064 and variance = 4.539e-05, #>    with bias = 0.0006418  #>  designEst(n = 25, smax = 100, p.tr = 0.05) #>  #> The minimum MSE of 0.0001998 is achieved with a group size of 18  #> The estimator has expected value = 0.05165 and variance = 0.0001971, #>    with bias = 0.001647  #>  designEst(n = 40, smax = 100, p.tr = 0.25) #>  #> The minimum MSE of 0.002056 is achieved with a group size of 4  #> The estimator has expected value = 0.254 and variance = 0.00204, #>    with bias = 0.004003  #>  designEst(n = 200, smax = 100, p.tr = 0.30) #>  #> The minimum MSE of 0.0004943 is achieved with a group size of 4  #> The estimator has expected value = 0.3011 and variance = 0.0004932, #>    with bias = 0.001052  #>"},{"path":"https://bdhitt.github.io/binGroup2/reference/designPower.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of groups or group size needed to achieve a power level in one parameter group testing — designPower","title":"Number of groups or group size needed to achieve a power level in one parameter group testing — designPower","text":"fixed number groups (group size), determine group size (number groups) needed obtain specified power level reject hypothesis proportion one parameter group testing.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/designPower.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of groups or group size needed to achieve a power level in one parameter group testing — designPower","text":"","code":"designPower(   n,   s,   fixed = \"s\",   delta,   p.hyp,   conf.level = 0.95,   power = 0.8,   alternative = \"two.sided\",   method = \"CP\",   biasrest = 0.05 )"},{"path":"https://bdhitt.github.io/binGroup2/reference/designPower.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of groups or group size needed to achieve a power level in one parameter group testing — designPower","text":"n integer specifying maximum number groups n allowed fixed=\"s\" fixed number groups fixed=\"n\". fixed=\"s\", vector two integers giving range n power shall iterated also allowed. s integer specifying fixed group size (number units per group) fixed=\"s\" maximum group size allowed planning design fixed=\"n\". fixed character string specifying whether number groups \"n\" group size \"s\" held fixed value. delta absolute difference true proportion hypothesized proportion shall detectable specified power. p.hyp proportion hypotheses, specified value 0 1. conf.level confidence level decision. default confidence level 0.95. power level power achieved, specified probability 0 1. alternative character string defining alternative hypothesis, either \"two.sided\", \"less\", \"greater\". method character string specifying confidence interval method (see propCI) used. biasrest value 0 1, specifying absolute bias maximally allowed point estimate.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/designPower.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of groups or group size needed to achieve a power level in one parameter group testing — designPower","text":"list containing: nout number groups necessary reach power specified parameters, fixed=\"s\" . sout group size necessary meet conditions, fixed=\"n\" . powerout power specified parameters selected number groups n fixed=\"s\" selected group size s fixed=\"n\". biasout bias specified parameters selected number groups n fixed=\"s\" selected group size s fixed=\"n\". power.reached logical value indicating whether specified level power reached. bias.reached logical value indicating whether maximum allowed bias reached. nit number groups iteration. sit group size iteration. powerit power achieved iteration. biasit bias iteration. maxit iteration maximum power reached, total number iterations. alternative alternative hypothesis specified user. p.hyp hypothesized proportion specified user. delta absolute difference true proportion hypothesized proportion specified user. power desired power specified user. biasrest maximum absolute bias specified user.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/designPower.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Number of groups or group size needed to achieve a power level in one parameter group testing — designPower","text":"power hypothesis test performed confidence interval defined probability confidence interval excludes threshold parameter (p.hyp) hypothesis. fixed=\"s\", function increases number groups pre-specified level power reached maximum number groups n reached. Since power increase monotonically increasing n single proportions oscillates local maxima minima, simple iteration given generally result selecting n given confidence interval method shows local minimum coverage null hypothesis true. Bias decreases monotonically increasing number groups (parameters fixed). resulting problems choosing number groups results satisfactory power solved following manner: case pre-specified power reached within given range n, smallest n returned least power reached, well actual power n. case pre-specified power reached within given value, n returned maximum power achieved, corresponding value power. case bias restriction violated even largest n within given range n, simply n returned power largest given range. Especially large n, calculation time may become large (particularly Blaker interval). Alternatively, function gtPower might used calculate power bias particular combinations input arguments. fixed=\"n\", function increases size groups pre-specified level power reached. Since power increase monotonically increasing s single proportions oscillates local maxima minima, simple iteration given generally result selecting s given confidence interval method shows local minimum coverage null hypothesis true. Since positive bias estimator group testing increases increasing group size, function checks whether bias smaller pre-specified level (bias.rest). bias violates restriction given combination n, s, delta, s increased actual power last acceptable group size s returned.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/designPower.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Number of groups or group size needed to achieve a power level in one parameter group testing — designPower","text":"Swallow, W. (1985). “Group testing estimating infection rates probabilities disease transmission.” Phytopathology, 75, 882–889.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/designPower.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Number of groups or group size needed to achieve a power level in one parameter group testing — designPower","text":"nDesign sDesign functions originally written Frank Schaarschmidt binGroup package. Minor modifications made inclusion binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/designPower.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of groups or group size needed to achieve a power level in one parameter group testing — designPower","text":"","code":"# Assume the objective is to show that a proportion is #   smaller than 0.005 (i.e. 0.5 percent) with a power #   of 0.80 (i.e. 80 percent) if the unknown proportion #   in the population is 0.003 (i.e. 0.3 percent); #   thus, a delta of 0.002 shall be detected. # A 95% Clopper Pearson CI shall be used. # The maximum group size because of limited sensitivity #   of the diagnostic test might be s=20 and we can #   only afford to perform maximally 100 tests: designPower(n = 100, s = 20, delta = 0.002,             p.hyp = 0.005, fixed = \"s\",             alternative = \"less\", method = \"CP\",             power = 0.8) #> Power was not reached in the range of n = 4 to 100  #> Maximal power was reached for n = 94 with power = 0.3533  #>   and bias = 1.572e-05  #> Alternative hypothesis: true proportion is less than 0.005  #> Assumed true proportion = 0.003   # One might accept to detect delta=0.004, #   i.e. reject H0: p>=0.005 with power 80 percent #   when the true proportion is 0.001: designPower(n = 100, s = 20, delta = 0.004, p.hyp = 0.005, fixed = \"s\",              alternative = \"less\", method = \"CP\", power = 0.8) #> Power was reached without violating bias restriction #>   for n = 64 with power = 0.8661 and bias = 7.572e-06  #> Alternative hypothesis: true proportion is less than 0.005  #> Assumed true proportion = 0.001   # Power for a design with a fixed group size of s = 1 #   (individual testing). designPower(n = 200, s = 1, delta = 0.05, p.hyp = 0.10,             fixed = \"s\", method = \"CP\", power = 0.80) #> Power was not reached in the range of n = 4 to 200  #> Maximal power was reached for n = 198 with power = 0.5858  #>   and bias = 3.469e-17  #> Alternative hypothesis: true proportion is not equal to 0.1  #> Assumed true proportion = 0.05 or 0.15   # Assume that objective is to show that a proportion #   is smaller than 0.005 (i.e. 0.5%) with a #   power of 0.80 (i.e. 80%) if the unknown proportion #   in the population is 0.003 (i.e. 0.3%); thus, a #   delta = 0.002 shall be detected. # A 95% Clopper-Pearson CI shall be used. # The maximum number of groups might be 30, where the #   overall sensitivity is not limited until group #   size s=100. designPower(s = 100, n = 30, delta = 0.002, p.hyp = 0.005, fixed = \"n\",              alternative = \"less\", method = \"CP\", power = 0.8) #> Power was not reached in the range of s = 2 , 100  #> Maximal power was reached for s = 100 with power = 0.4662  #>   and bias = 5.957802e-05  #> Alternative hypothesis: true proportion is less than 0.005  #> Assumed true proportion = 0.003   # One might accept to detect delta=0.004, #   i.e. reject H0: p>=0.005 with power 80 percent #   when the true proportion is 0.001: designPower(s = 100, n = 30, delta = 0.004, p.hyp = 0.005, fixed = \"n\",              alternative = \"less\", method = \"CP\", power = 0.8) #> Power was reached without violating bias restriction  #>   for s = 44 with power = 0.8626 and bias = 1.704e-05  #> Alternative hypothesis: true proportion is less than 0.005  #> Assumed true proportion = 0.001  designPower(s = 100, n = 30, delta = 0.004, p.hyp = 0.005, fixed = \"n\",              alternative = \"less\", method = \"score\", power = 0.8) #> Power was reached without violating bias restriction  #>   for s = 41 with power = 0.8819 and bias = 1.698e-05  #> Alternative hypothesis: true proportion is less than 0.005  #> Assumed true proportion = 0.001"},{"path":"https://bdhitt.github.io/binGroup2/reference/expectOrderBeta.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine a vector of probabilities for informative group testing algorithms — expectOrderBeta","title":"Determine a vector of probabilities for informative group testing algorithms — expectOrderBeta","text":"Find expected value order statistics beta distribution. function used provide set individual risk probabilities informative group testing.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/expectOrderBeta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine a vector of probabilities for informative group testing algorithms — expectOrderBeta","text":"","code":"expectOrderBeta(   p,   alpha,   size,   grp.sz,   num.sim = 10000,   rel.tol = ifelse(alpha >= 1, .Machine$double.eps^0.25, .Machine$double.eps^0.1),   ... )"},{"path":"https://bdhitt.github.io/binGroup2/reference/expectOrderBeta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine a vector of probabilities for informative group testing algorithms — expectOrderBeta","text":"p overall probability disease used determine vector individual risk probabilities. expected value random variable beta distribution, \\(\\frac{\\alpha}{\\alpha + \\beta}\\). alpha shape parameter beta distribution specifies degree heterogeneity determined probability vector. size size vector individual risk probabilities generated. also number total individuals determine risk probabilities. grp.sz number total individuals determine risk probabilities. argument deprecated; size argument used instead. num.sim number simulations. argument used simulation necessary. rel.tol relative tolerance used integration. ... arguments passed beta.dist function written Michael Black Black et al. (2015).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/expectOrderBeta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine a vector of probabilities for informative group testing algorithms — expectOrderBeta","text":"vector individual risk probabilities.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/expectOrderBeta.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Determine a vector of probabilities for informative group testing algorithms — expectOrderBeta","text":"function uses beta.dist function Black et al. (2015) determine vector individual risk probabilities, ordered least greatest. Depending specified probability, \\(\\alpha\\) level, overall group size, simulation may necessary order determine probabilities. reason, user set seed order reproduce results. number simulations (default = 10,000) relative tolerance integration can specified user. expectOrderBeta function augments beta.dist function checking whether simulation needed attempting determine probabilities, allowing number simulations specified user. See Black et al. (2015) additional details original beta.dist function.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/expectOrderBeta.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Determine a vector of probabilities for informative group testing algorithms — expectOrderBeta","text":"Black, M., Bilder, C., Tebbs, J. (2015). “Optimal retesting configurations hierarchical group testing.” Journal Royal Statistical Society. Series C: Applied Statistics, 64, 693–710.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/expectOrderBeta.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Determine a vector of probabilities for informative group testing algorithms — expectOrderBeta","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/expectOrderBeta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine a vector of probabilities for informative group testing algorithms — expectOrderBeta","text":"","code":"set.seed(8791) expectOrderBeta(p = 0.03, alpha = 0.5, size = 100, rel.tol = 0.0001) #> Using simulation #>   [1] 9.888742e-06 2.960985e-05 5.758418e-05 9.536279e-05 1.435112e-04 #>   [6] 2.014517e-04 2.693015e-04 3.484398e-04 4.347717e-04 5.301154e-04 #>  [11] 6.347749e-04 7.553283e-04 8.813811e-04 1.019173e-03 1.165680e-03 #>  [16] 1.321324e-03 1.487075e-03 1.665317e-03 1.853131e-03 2.052074e-03 #>  [21] 2.263881e-03 2.484335e-03 2.716080e-03 2.960775e-03 3.216792e-03 #>  [26] 3.485977e-03 3.768618e-03 4.055657e-03 4.361395e-03 4.674162e-03 #>  [31] 5.003723e-03 5.343320e-03 5.697125e-03 6.066926e-03 6.444940e-03 #>  [36] 6.839459e-03 7.252745e-03 7.681719e-03 8.121652e-03 8.586982e-03 #>  [41] 9.065121e-03 9.554287e-03 1.005516e-02 1.058576e-02 1.112961e-02 #>  [46] 1.169173e-02 1.227191e-02 1.287684e-02 1.349762e-02 1.414197e-02 #>  [51] 1.479939e-02 1.547656e-02 1.616789e-02 1.689998e-02 1.765705e-02 #>  [56] 1.845073e-02 1.925670e-02 2.006631e-02 2.093889e-02 2.183414e-02 #>  [61] 2.276064e-02 2.369815e-02 2.469039e-02 2.572719e-02 2.677131e-02 #>  [66] 2.788736e-02 2.904225e-02 3.024986e-02 3.149846e-02 3.281283e-02 #>  [71] 3.417198e-02 3.556576e-02 3.704478e-02 3.857573e-02 4.017339e-02 #>  [76] 4.183985e-02 4.360637e-02 4.546013e-02 4.739956e-02 4.945612e-02 #>  [81] 5.161278e-02 5.390850e-02 5.633163e-02 5.889587e-02 6.166592e-02 #>  [86] 6.462436e-02 6.784261e-02 7.127314e-02 7.500320e-02 7.918243e-02 #>  [91] 8.381123e-02 8.890606e-02 9.461215e-02 1.011622e-01 1.088779e-01 #>  [96] 1.181433e-01 1.297517e-01 1.454834e-01 1.679224e-01 2.120121e-01  expectOrderBeta(p = 0.05, alpha = 2, size = 40) #>  [1] 0.005570409 0.008630251 0.011086767 0.013256762 0.015259102 0.017153566 #>  [7] 0.018975479 0.020748047 0.022487753 0.024207057 0.025915887 0.027622530 #> [13] 0.029334200 0.031057425 0.032798321 0.034562810 0.036356794 0.038186309 #> [19] 0.040057678 0.041977661 0.043953627 0.045993740 0.048107195 0.050304504 #> [25] 0.052597857 0.055001598 0.057532868 0.060212467 0.063066087 0.066126076 #> [31] 0.069434074 0.073045078 0.077034015 0.081506906 0.086621178 0.092625871 #> [37] 0.099951032 0.109442444 0.123165239 0.149033333"},{"path":"https://bdhitt.github.io/binGroup2/reference/formula.gtReg.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the model formula from a fitted group testing model — formula.gtReg","title":"Extract the model formula from a fitted group testing model — formula.gtReg","text":"Extract model formula objects class \"gtReg\" returned gtReg.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/formula.gtReg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the model formula from a fitted group testing model — formula.gtReg","text":"","code":"# S3 method for class 'gtReg' formula(x, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/formula.gtReg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the model formula from a fitted group testing model — formula.gtReg","text":"x object class \"gtReg\", created gtReg, model formula extracted. ... currently used.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/formula.gtReg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the model formula from a fitted group testing model — formula.gtReg","text":"Model formula extracted object object.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/formula.gtReg.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract the model formula from a fitted group testing model — formula.gtReg","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/formula.gtReg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract the model formula from a fitted group testing model — formula.gtReg","text":"","code":"data(hivsurv) fit1 <- gtReg(formula = groupres ~ AGE * EDUC.,               data = hivsurv, groupn = gnum,               linkf = \"probit\") formula(x = fit1) #> groupres ~ AGE * EDUC. #> <environment: 0x55d7d77d5270>"},{"path":"https://bdhitt.github.io/binGroup2/reference/gtPower.html","id":null,"dir":"Reference","previous_headings":"","what":"Power to reject a hypothesis for one proportion in group testing — gtPower","title":"Power to reject a hypothesis for one proportion in group testing — gtPower","text":"function calculates power reject hypothesis group testing experiment, using confidence intervals decision. function also calculates bias point estimator given \\(n\\), \\(s\\), true, unknown proportion.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtPower.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power to reject a hypothesis for one proportion in group testing — gtPower","text":"","code":"gtPower(   n,   s,   delta,   p.hyp,   conf.level = 0.95,   method = \"CP\",   alternative = \"two.sided\" )"},{"path":"https://bdhitt.github.io/binGroup2/reference/gtPower.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power to reject a hypothesis for one proportion in group testing — gtPower","text":"n integer specifying number groups. vector integers also allowed. s integer specifying common group size. vector integers also allowed. delta absolute difference true proportion hypothesized proportion. vector also allowed. p.hyp proportion hypotheses, specified value 0 1. conf.level confidence level required decision hypotheses. method character string specifying confidence interval method (see propCI) used. alternative character string defining alternative hypothesis, either \"two.sided\", \"less\", \"greater\".","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtPower.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power to reject a hypothesis for one proportion in group testing — gtPower","text":"matrix containing following columns: ns vector total sample size, \\(n*s\\). n vector number groups. s vector group sizes. delta vector delta values. power power reject given null hypothesis. bias bias estimator specified \\(n\\), \\(s\\), true proportion.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtPower.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Power to reject a hypothesis for one proportion in group testing — gtPower","text":"power hypothesis test performed confidence interval defined probability confidence interval excludes threshold parameter (p.hyp) null hypothesis, described Schaarschmidt (2007). Due discreteness, power increase monotonically increasing number groups \\(n\\) group size \\(s\\), exhibits local maxima minima, depending \\(n\\), \\(s\\), p.hyp, conf.level. Additional power, bias point estimator calculated according Swallow (1985). vectors specified \\(n\\), \\(s\\), () delta, matrix constructed power bias calculated line matrix.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtPower.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Power to reject a hypothesis for one proportion in group testing — gtPower","text":"Schaarschmidt, F. (2007). “Experimental design one-sided confidence intervals hypothesis tests binomial group testing.” Communications Biometry Crop Science, 2, 32–40. ISSN 1896-0782. Swallow, W. (1985). “Group testing estimating infection rates probabilities disease transmission.” Phytopathology, 75, 882–889.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/gtPower.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Power to reject a hypothesis for one proportion in group testing — gtPower","text":"function originally written bgtPower Frank Schaarschmidt binGroup package. Minor modifications made inclusion function binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtPower.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Power to reject a hypothesis for one proportion in group testing — gtPower","text":"","code":"# Calculate the power for the design #   in the example given in Tebbs and Bilder(2004): #   n=24 groups each containing 7 insects #   if the true proportion of virus vectors #   in the population is 0.04 (4 percent), #   the power to reject H0: p>=0.1 using an #   upper Clopper-Pearson (\"CP\") confidence interval #   is calculated with the following call: gtPower(n = 24, s = 7, delta = 0.06, p.hyp = 0.1,         conf.level = 0.95, alternative = \"less\",         method = \"CP\") #>    ns  n s delta     power         bias #> n 168 24 7  0.06 0.8821248 0.0008405368  # Explore development of power and bias for varying n, #   s, and delta. How much can we decrease the number of #   groups (costly tests to be performed) by pooling the #   same number of 320 individuals to groups of #   increasing size without largely decreasing power? gtPower(n = c(320, 160, 80, 64, 40, 32, 20, 10, 5),         s = c(1, 2, 4, 5, 8, 10, 16, 32, 64),         delta = 0.01,  p.hyp = 0.02) #>        ns   n  s delta       power         bias #>  [1,] 320 320  1  0.01 0.169575200 3.122502e-17 #>  [2,] 320 160  2  0.01 0.153984506 4.775749e-05 #>  [3,] 320  80  4  0.01 0.171809348 1.485202e-04 #>  [4,] 320  64  5  0.01 0.172465973 2.017053e-04 #>  [5,] 320  40  8  0.01 0.138488643 3.737105e-04 #>  [6,] 320  32 10  0.01 0.175933578 4.999685e-04 #>  [7,] 320  20 16  0.01 0.102452816 9.486069e-04 #>  [8,] 320  10 32  0.01 0.062895913 1.090916e-02 #>  [9,] 320   5 64  0.01 0.001819794 4.455608e-01  # What happens to the power for increasing differences #   between the true proportion and the threshold #   proportion? gtPower(n = 50, s = 10,         delta = seq(from = 0, to = 0.01, by = 0.001),         p.hyp = 0.01, method = \"CP\") #>        ns  n  s delta      power         bias #>  [1,] 500 50 10 0.000 0.02509474 9.556995e-05 #>  [2,] 500 50 10 0.001 0.02045901 1.056338e-04 #>  [3,] 500 50 10 0.002 0.02240288 1.157943e-04 #>  [4,] 500 50 10 0.003 0.03154284 1.260525e-04 #>  [5,] 500 50 10 0.004 0.04988657 1.364095e-04 #>  [6,] 500 50 10 0.005 0.08170390 1.468667e-04 #>  [7,] 500 50 10 0.006 0.13481479 1.574252e-04 #>  [8,] 500 50 10 0.007 0.22262947 1.680863e-04 #>  [9,] 500 50 10 0.008 0.31313453 1.788510e-04 #> [10,] 500 50 10 0.009 0.37280062 1.897208e-04 #> [11,] 500 50 10 0.010 0.43351536 2.006969e-04  # Calculate power with a group size of 1 (individual #   testing). gtPower(n = 100, s = 1,         delta = seq(from = 0, to = 0.01, by = 0.001),         p.hyp = 0.01, method = \"CP\") #>        ns   n s delta        power         bias #>  [1,] 100 100 1 0.000 1.837404e-02 1.734723e-17 #>  [2,] 100 100 1 0.001 1.299201e-02 1.908196e-17 #>  [3,] 100 100 1 0.002 8.743140e-03 2.081668e-17 #>  [4,] 100 100 1 0.003 5.525839e-03 2.081668e-17 #>  [5,] 100 100 1 0.004 3.216655e-03 2.602085e-17 #>  [6,] 100 100 1 0.005 1.673268e-03 2.775558e-17 #>  [7,] 100 100 1 0.006 7.394374e-04 2.775558e-17 #>  [8,] 100 100 1 0.007 2.524704e-04 2.775558e-17 #>  [9,] 100 100 1 0.008 5.382635e-05 3.122502e-17 #> [10,] 100 100 1 0.009 3.631682e-06 3.122502e-17 #> [11,] 100 100 1 0.010 0.000000e+00 3.469447e-17"},{"path":"https://bdhitt.github.io/binGroup2/reference/gtReg.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitting group testing regression models — gtReg","title":"Fitting group testing regression models — gtReg","text":"Fits group testing regression model specified symbolic description linear predictor descriptions group testing setting. function allows fitting regression models simple pooling, halving, array testing data.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtReg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitting group testing regression models — gtReg","text":"","code":"gtReg(   type = \"sp\",   formula,   data,   groupn = NULL,   subg = NULL,   coln = NULL,   rown = NULL,   arrayn = NULL,   retest = NULL,   sens = 1,   spec = 1,   linkf = c(\"logit\", \"probit\", \"cloglog\"),   method = c(\"Vansteelandt\", \"Xie\"),   sens.ind = NULL,   spec.ind = NULL,   start = NULL,   control = gtRegControl(...),   ... )"},{"path":"https://bdhitt.github.io/binGroup2/reference/gtReg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitting group testing regression models — gtReg","text":"type \"sp\" simple pooling (Dorfman testing without retests), \"halving\" halving protocol, \"array\" array testing. See 'Details' descriptions group testing algorithms. formula object class \"formula\" (one can coerced class); symbolic description model fitted. details model specification 'Details'. data optional data frame, list, environment (object coercible .data.frame data frame) containing variables model. found data, variables taken environment(formula), typically environment gtReg called. groupn vector, list, data frame group numbers designates individuals groups (use simple pooling, type = \"sp\", halving protocol, type = \"halving\"). subg vector, list, data frame group numbers designates individuals subgroups (use halving protocol, type = \"halving\"). coln vector, list, data frame specifies column group number sample (use array testing, type = \"array\"). rown vector, list, data frame specifies row group number sample (use array testing, type = \"array\"). arrayn vector, list, data frame specifies array number sample (use array testing, type = \"array\"). retest vector, list, data frame individual retest results. Default value NULL retests. See 'Details' details specify retest. sens sensitivity test. Default value set 1. spec specificity test. Default value set 1. linkf character string specifying one three link functions binomial model: \"logit\" (default), \"probit\", \"cloglog\". method method fit regression model. Options include \"Vansteelandt\" (default) \"Xie\". \"Vansteelandt\" option finds estimates directly maximizing likelihood function based group responses, \"Xie\" option uses EM algorithm maximize likelihood function terms unobserved individual responses. sens.ind sensitivity individual retests. NULL, set equal sens. spec.ind specificity individual retests. NULL, set equal spec. start starting values parameters linear predictor. control list parameters controlling fitting process method \"Xie\". parameters passed gtRegControl function use. ... arguments passed gtRegControl default. See argument control.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtReg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitting group testing regression models — gtReg","text":"object class \"gtReg\", list may include: coefficients named vector coefficients. hessian estimated Hessian matrix negative log-likelihood function. serves estimate information matrix. residuals response residuals. difference observed group responses fitted group responses. included array testing. fitted.values fitted mean values group responses. included array testing. deviance deviance fitted model saturated model. included array testing. aic Akaike's Information Criterion. minus twice maximized log-likelihood plus twice number coefficients. included array testing. null.deviance deviance null model, comparable deviance. null model include intercept, one model. Provided simple pooling, type = \"sp\", . counts number iterations optim (Vansteelandt's method) number iterations EM algorithm (Xie's method, halving, array testing). Gibbs.sample.size number Gibbs samples generated E step. Provided array testing, type = \"array\", . df.residual residual degrees freedom. Provided simple pooling, type = \"sp\", . df.null residual degrees freedom null model. Provided simple pooling, type = \"sp\", . z vector group responses. included array testing. call matched call. formula formula supplied. terms terms object used. method method (\"Vansteelandt\" \"Xie\") used fit model. halving protocol, \"Xie\" method used. included array testing. link link function used model.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtReg.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fitting group testing regression models — gtReg","text":"simple pooling halving, typical predictor form groupresp ~ covariates groupresp (numeric) group response vector. array testing, individual samples placed matrix-like grid samples pooled within row within column. leads two kinds group responses: row column group responses. Thus, typical predictor form cbind(col.resp, row.resp) ~ covariates, col.resp (numeric) column group response vector row.resp (numeric) row group response vector. methods, covariates series terms specifies linear predictor individual responses. Note actually unobserved individual responses, observed group responses, modeled covariates. denoting group responses (groupresp, col.resp, row.resp), 0 denotes negative response 1 denotes positive response, probability individual positive response modeled directly. terms specification form first + second indicates terms first together terms second duplicates removed. specification form first:second indicates set terms obtained taking interactions terms first terms second. specification first*second indicates cross first second. first + second + first:second. terms formula re-ordered main effects come first, followed interactions, second-order, third-order, ; avoid , pass terms object formula. simple pooling (type = \"sp\"), functions gtreg.fit, EM, EM.ret, first corresponds Vansteelandt's method described Vansteelandt et al. (2000) last two correspond Xie's method described Xie (2001), called carry model fitting. gtreg.fit function uses optim function default method \"Nelder-Mead\" maximize likelihood function observed group responses. optimization method produces Hessian matrix zero elements, \"SANN\" method optim employed find coefficients Hessian matrix. \"SANN\" method, number iterations optim set 10000. background use optim, see help(optim). EM EM.ret functions apply Xie's EM algorithm likelihood function written terms unobserved individual responses; functions use glm.fit update parameter estimates within M step. EM function used retests EM.ret used individual retests available. Thus, within retest argument, individual observations observed positive groups 0 (negative) 1 (positive); remaining individual observations NAs, meaning retest performed . Retests used Vansteelandt's method; warning message given case, individual retests ignored model fitting. slight differences estimates Vansteelandt's Xie's methods (retests available) due different convergence criteria. simple pooling (.e., Dorfman testing, two-stage hierarchical testing), individual appears exactly one pool. group responses observed, null degrees freedom number groups minus 1 residual degrees freedom number groups minus number parameters. individual retests observed , open research question degrees freedom deviance null model ; therefore, degrees freedom null.deviance displayed. halving protocol, EM.halving function applies Xie's EM algorithm likelihood function written terms unobserved individual responses; functions use glm.fit update parameter estimates within M step. halving protocol, initial group tests positive, split two subgroups. two subgroups subsequently tested either subgroup tests positive, third final step test individuals within subgroup. Thus, within subg, subgroup responses observed positive groups 0 (negative) 1 (positive); remaining subgroup responses NAs, meaning tests performed . individual retests similarly coded. array testing (also known matrix pooling), EM.mp function applies Xie's EM algorithm likelihood function written terms unobserved individual responses. E step, Gibbs sampling technique used estimate conditional probabilities. large number Gibbs samples needed achieve convergence, model fitting process quite slow, especially multiple positive rows columns observed. case, can either increase Gibbs sample size help achieve convergence loosen convergence criteria increasing tol expense perhaps poorer estimates. follow-retests performed, retest results going model help achieve convergence faster Gibbs sample size convergence criteria. M step, use glm.fit update parameter estimates. simple pooling, retest provides individual retest results Dorfman's retesting procedure. halving protocol, retest provides individual retest results within subgroup tests positive. retest argument provides individual retest results, 0 denotes negative 1 denotes positive status. NA denotes retest performed individual. default value NULL retests. simple pooling, control provides parameters controlling fitting process \"Xie\" method . gtReg returns object class \"gtReg\". function summary (.e., summary.gtReg used obtain print summary results. group testing function predict (.e., predict.gtReg) used make predictions \"gtReg\" objects.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtReg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fitting group testing regression models — gtReg","text":"Vansteelandt, S., Goetghebeur, E., Verstraeten, T. (2000). “Regression models disease prevalence diagnostic tests pools serum samples.” Biometrics, 56, 1126–1133. Xie, M. (2001). “Regression analysis group testing samples.” Statistics Medicine, 20, 1957–1969.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/gtReg.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fitting group testing regression models — gtReg","text":"majority function originally written gtreg.sp, gtreg.halving, gtreg.mp Boan Zhang binGroup package. Minor modifications made inclusion functions binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtReg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitting group testing regression models — gtReg","text":"","code":"data(hivsurv) fit1 <- gtReg(type = \"sp\", formula  =  groupres ~ AGE + EDUC.,               data  =  hivsurv, groupn  =  gnum, sens  =  0.9,               spec  =  0.9, method  =  \"Xie\") #>  #>  Number of minutes running: 0  #>   fit1 #>  #> Call: #> gtReg(type = \"sp\", formula = groupres ~ AGE + EDUC., data = hivsurv,  #>     groupn = gnum, sens = 0.9, spec = 0.9, method = \"Xie\") #>  #> Coefficients: #> (Intercept)          AGE        EDUC.   #>    -3.12000     -0.05692      0.82830   #>  #> Degrees of Freedom: 85 \tTotal (i.e. Null);  83 Residual #> Null Deviance:\t    154.3  #> Residual Deviance:  109.5 \tAIC: 115.5   set.seed(46) gt.data <- gtSim(type = \"sp\", par = c(-12, 0.2),                  size1 = 700, size2 = 5) fit2 <- gtReg(type = \"sp\", formula = gres ~ x, data = gt.data,               groupn = groupn) fit2 #>  #> Call: #> gtReg(type = \"sp\", formula = gres ~ x, data = gt.data, groupn = groupn) #>  #> Coefficients: #> (Intercept)            x   #>     -9.1300       0.1513   #>  #> Degrees of Freedom: 139 \tTotal (i.e. Null);  138 Residual #> Null Deviance:\t    182.5  #> Residual Deviance:  155.4 \tAIC: 159.4   set.seed(21) gt.data <- gtSim(type = \"sp\", par = c(-12, 0.2),                  size1 = 700, size2 = 6, sens = 0.95, spec = 0.95,                  sens.ind = 0.98, spec.ind = 0.98) fit3 <- gtReg(type = \"sp\", formula = gres ~ x, data = gt.data,               groupn = groupn, retest = retest, method = \"Xie\",               sens = 0.95, spec = 0.95, sens.ind = 0.98,               spec.ind = 0.98, trace = TRUE) #> beta is -2.385642 0.04980633 \tdiff is 0.7744917  #> beta is -4.666981 0.08044078 \tdiff is 0.956279  #> beta is -9.078311 0.1497513 \tdiff is 0.9452213  #> beta is -12.057 0.1988675 \tdiff is 0.3281102  #> beta is -12.87448 0.2127228 \tdiff is 0.06967083  #> beta is -13.08208 0.216366 \tdiff is 0.01712646  #> beta is -13.13659 0.2173541 \tdiff is 0.004566901  #> beta is -13.15141 0.2176301 \tdiff is 0.001269882  #> beta is -13.15556 0.2177089 \tdiff is 0.0003622362  #> beta is -13.15675 0.2177318 \tdiff is 0.0001050858  #> beta is -13.15709 0.2177385 \tdiff is 3.083636e-05  #>  #>  Number of minutes running: 0  #>   summary(fit3) #>  #> Call: #> gtReg(type = \"sp\", formula = gres ~ x, data = gt.data, groupn = groupn,  #>     retest = retest, sens = 0.95, spec = 0.95, method = \"Xie\",  #>     sens.ind = 0.98, spec.ind = 0.98, trace = TRUE) #>  #> Deviance Residuals:  #>     Min       1Q   Median       3Q      Max   #> -2.1906  -0.7711  -0.5313   1.0163   2.1241   #>  #> Coefficients: #>             Estimate Std. Error z value Pr(>|z|)     #> (Intercept) -13.1571     1.6380  -8.033 9.55e-16 *** #> x             0.2177     0.0311   7.002 2.53e-12 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #> AIC: 249.5 #>  #> Number of iterations in EM: 11 #>   set.seed(46) gt.data <- gtSim(type = \"halving\", par = c(-6, 0.1), gshape = 17,                  gscale = 1.4, size1 = 5000, size2 = 5,                  sens = 0.95, spec = 0.95) fit4 <- gtReg(type = \"halving\", formula = gres ~ x,               data = gt.data, groupn = groupn, subg = subgroup,               retest = retest, sens = 0.95, spec = 0.95,               start = c(-6, 0.1), trace = TRUE) #> beta is -5.801464 0.09854319 \tdiff is 0.03308938  #> beta is -5.763654 0.09797172 \tdiff is 0.006517349  #> beta is -5.756256 0.09782221 \tdiff is 0.001525959  #> beta is -5.75482 0.0977881 \tdiff is 0.0003487232  #> beta is -5.754545 0.09778085 \tdiff is 7.416938e-05  #>  #>  Number of minutes running: 0.01  #>   summary(fit4) #>  #> Call: #> gtReg(type = \"halving\", formula = gres ~ x, data = gt.data, groupn = groupn,  #>     subg = subgroup, retest = retest, sens = 0.95, spec = 0.95,  #>     start = c(-6, 0.1), trace = TRUE) #>  #> Deviance Residuals:  #>     Min       1Q   Median       3Q      Max   #> -1.1755  -0.6945  -0.6349  -0.5616   1.9998   #>  #> Coefficients: #>             Estimate Std. Error z value Pr(>|z|)     #> (Intercept) -5.75454    0.37183 -15.476  < 2e-16 *** #> x            0.09778    0.01338   7.307 2.73e-13 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #> AIC: 1984 #>  #> Number of iterations in EM: 5 #>   # 5x6 and 4x5 array set.seed(9128) sa1a <- gtSim(type = \"array\", par = c(-7, 0.1), size1 = c(5, 4),               size2 = c(6, 5), sens = 0.95, spec = 0.95) sa1 <- sa1a$dframe fit5 <- gtReg(type = \"array\",               formula = cbind(col.resp, row.resp) ~ x,               data = sa1, coln = coln, rown = rown,               arrayn = arrayn, sens = 0.95, spec = 0.95,               tol = 0.005, n.gibbs = 2000, trace = TRUE) #> beta is -6.412693 0.08884765 \tdiff is 0.09130411  #> beta is -6.267057 0.08682834 \tdiff is 0.02272769  #> beta is -6.205361 0.08577792 \tdiff is 0.01209771  #> beta is -6.248676 0.08681603 \tdiff is 0.01210228  #> beta is -6.239827 0.08659878 \tdiff is 0.002502387  #>  #>  Number of minutes running: 0.2  #>   fit5 #>  #> Call: #> gtReg(type = \"array\", formula = cbind(col.resp, row.resp) ~ x,  #>     data = sa1, coln = coln, rown = rown, arrayn = arrayn, sens = 0.95,  #>     spec = 0.95, tol = 0.005, n.gibbs = 2000, trace = TRUE) #>  #> Coefficients: #> (Intercept)            x   #>     -6.2400       0.0866   summary(fit5) #>  #> Call: #> gtReg(type = \"array\", formula = cbind(col.resp, row.resp) ~ x,  #>     data = sa1, coln = coln, rown = rown, arrayn = arrayn, sens = 0.95,  #>     spec = 0.95, tol = 0.005, n.gibbs = 2000, trace = TRUE) #>  #>  #> Coefficients: #>             Estimate Std. Error z value Pr(>|z|)   #> (Intercept)  -6.2398     2.7349  -2.282   0.0225 * #> x             0.0866     0.0569   1.522   0.1280   #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> Number of Gibbs samples generated in each E step: 2000 #> Number of iterations in EM algorithm: 5 #>"},{"path":"https://bdhitt.github.io/binGroup2/reference/gtRegControl.html","id":null,"dir":"Reference","previous_headings":"","what":"Auxiliary for controlling group testing regression — gtRegControl","title":"Auxiliary for controlling group testing regression — gtRegControl","text":"Auxiliary function control fitting parameters EM algorithm used internally gtReg simple pooling (type = \"sp\") method = \"Xie\" array testing (type = \"array\").","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtRegControl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Auxiliary for controlling group testing regression — gtRegControl","text":"","code":"gtRegControl(   tol = 1e-04,   n.gibbs = 1000,   n.burnin = 20,   maxit = 500,   trace = FALSE,   time = TRUE )"},{"path":"https://bdhitt.github.io/binGroup2/reference/gtRegControl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Auxiliary for controlling group testing regression — gtRegControl","text":"tol convergence criterion. n.gibbs Gibbs sample size used E step EM algorithm, array testing. default 1000. n.burnin number samples burn-period, array testing. default 20. maxit maximum number iterations EM algorithm. trace logical value indicating whether output printed iteration. default FALSE. time logical value indicating whether length time model fitting printed. default TRUE.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtRegControl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Auxiliary for controlling group testing regression — gtRegControl","text":"list components named input arguments.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtRegControl.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Auxiliary for controlling group testing regression — gtRegControl","text":"function originally written gt.control function binGroup package. Minor modifications made inclusion binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtRegControl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Auxiliary for controlling group testing regression — gtRegControl","text":"","code":"# The default settings: gtRegControl() #> $tol #> [1] 1e-04 #>  #> $n.gibbs #> [1] 1000 #>  #> $n.burnin #> [1] 20 #>  #> $maxit #> [1] 500 #>  #> $trace #> [1] FALSE #>  #> $time #> [1] TRUE #>"},{"path":"https://bdhitt.github.io/binGroup2/reference/gtSim.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation function for group testing data — gtSim","title":"Simulation function for group testing data — gtSim","text":"Simulates data group testing form ready fit gtReg.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtSim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation function for group testing data — gtSim","text":"","code":"gtSim(   type = \"sp\",   x = NULL,   gshape = 20,   gscale = 2,   par,   linkf = c(\"logit\", \"probit\", \"cloglog\"),   size1,   size2,   sens = 1,   spec = 1,   sens.ind = NULL,   spec.ind = NULL )"},{"path":"https://bdhitt.github.io/binGroup2/reference/gtSim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation function for group testing data — gtSim","text":"type \"sp\" simple pooling (Dorfman testing without retests), \"halving\" halving protocol, \"array\" array testing (also known matrix pooling). x matrix user-submitted covariates simulate data. Default NULL, case gamma distribution used generate covariates automatically. gshape shape parameter gamma distribution. value must non-negative. Default value set 20. gscale scale parameter gamma distribution. value must strictly positive. Default value set 2. par true coefficients linear predictor. linkf character string specifying one three link functions used: \"logit\" (default), \"probit\", \"cloglog\". size1 sample size simulated data (use \"sp\" \"halving\" methods) vector specifies number rows matrix (use \"array\" method). one matrix simulated, value scalar. size2 group size pooling individual samples (use \"sp\" \"halving\" methods) vector specifies number columns matrix (use \"array\" method). one matrix simulated, value scalar. sens sensitivity group tests. Default value set 1. spec specificity group tests. Default value set 1. sens.ind sensitivity individual retests. NULL, set equal sens. spec.ind specificity individual retests. NULL, set equal spec.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtSim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulation function for group testing data — gtSim","text":"simple pooling (type = \"sp\") halving protocol (type = \"halving\"), data frame array testing (type = \"array\"), list, may include following: gres group response, simple pooling halving protocol . col.resp column group response, array testing . row.resp row group response, array testing . x covariate. groupn group number, simple pooling halving protocol . arrayn array number, array testing . coln column group number, array testing . rown row group number, array testing . ind true individual responses. simple pooling halving protocol, included data frame results. array testing, included list results, individual responses presented matrices. retest results individual retests. subgroup subgroup number, halving protocol. prob individual probabilities, array testing .","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtSim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulation function for group testing data — gtSim","text":"Generates group testing data simple pooling form (type = \"sp\"), halving protocol (type = \"halving\"), array testing form (type = \"array\"). covariates either specified x argument generated gamma distribution given gshape gscale parameters. individual probabilities calculated covariates, coefficients given par, link function specified linkf. true binary individual responses simulated individual probabilities. matrix pooling protocol (type = \"array\"), individuals first organized (column) one matrices specified number rows (size1) number columns (size2). , pooling protocols, true group responses found individual responses within groups within rows/columns matrix pooling (.e., least one response positive, group positive; otherwise, group response negative). Finally, observed group (method = \"sp\") subgroup method = \"halving\" ), row column responses method = \"array\" simulated using given sens spec. simple pooling halving protocols, individual retests simulated sens.ind spec.ind samples observed positive groups. Note given group size (specified size2 method = \"sp\" method = \"halving\"), last group may fewer individuals. matrix pooling protocol, individual retests simulated sens.ind spec.ind individuals lie intersection observed positive row observed positive column. case column (row) tests positive matrix, individuals observed positive rows (columns) assigned simulated retest result. column row observed positive, NULL returned.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/gtSim.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulation function for group testing data — gtSim","text":"function combination sim.gt, sim.halving, sim.mp written Boan Zhang binGroup package. Minor modifications made inclusion functions binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtSim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulation function for group testing data — gtSim","text":"","code":"set.seed(46) gt.data <- gtSim(type = \"sp\", par = c(-12, 0.2),                  size1 = 700, size2 = 5)  x1 <- sort(runif(100, 0, 30)) x2 <- rgamma(100, shape = 17, scale = 1.5) gt.data <- gtSim(type = \"sp\", x = cbind(x1, x2),                  par = c(-14, 0.2, 0.3), size2 = 4,                  sens = 0.98, spec = 0.98)  set.seed(46) gt.data <- gtSim(type = \"halving\", par = c(-6, 0.1),                  gshape = 17, gscale = 1.4, size1 = 5000,                  size2 = 5, sens = 0.95, spec = 0.95)  # 5x6 and 4x5 matrix set.seed(9128) sa1a <- gtSim(type = \"array\", par = c(-7, 0.1),               size1 = c(5, 4), size2 = c(6, 5),               sens = 0.95, spec = 0.95) sa1a$dframe #>           x col.resp row.resp coln rown arrayn retest #> 1  29.96059        0        0    1    1      1     NA #> 2  61.28205        0        1    1    2      1     NA #> 3  34.27341        0        1    1    3      1     NA #> 4  46.19001        0        0    1    4      1     NA #> 5  39.43801        0        1    1    5      1     NA #> 6  45.88038        1        0    2    1      1     NA #> 7  37.46931        1        1    2    2      1      0 #> 8  41.53810        1        1    2    3      1      0 #> 9  33.19917        1        0    2    4      1     NA #> 10 39.12554        1        1    2    5      1      1 #> 11 35.63487        1        0    3    1      1     NA #> 12 76.53439        1        1    3    2      1      1 #> 13 43.28924        1        1    3    3      1      0 #> 14 19.54699        1        0    3    4      1     NA #> 15 42.47747        1        1    3    5      1      0 #> 16 50.58869        0        0    4    1      1     NA #> 17 26.54039        0        1    4    2      1     NA #> 18 42.56257        0        1    4    3      1     NA #> 19 53.56499        0        0    4    4      1     NA #> 20 37.74931        0        1    4    5      1     NA #> 21 41.87551        0        0    5    1      1     NA #> 22 40.20522        0        1    5    2      1     NA #> 23 37.97127        0        1    5    3      1     NA #> 24 38.45669        0        0    5    4      1     NA #> 25 39.56397        0        1    5    5      1     NA #> 26 37.93089        1        0    6    1      1     NA #> 27 42.63813        1        1    6    2      1      1 #> 28 35.52633        1        1    6    3      1      0 #> 29 37.21599        1        0    6    4      1     NA #> 30 35.73672        1        1    6    5      1      0 #> 31 37.80483        0        0    1    1      2     NA #> 32 45.86955        0        0    1    2      2     NA #> 33 46.37589        0        1    1    3      2      1 #> 34 33.38453        0        0    1    4      2     NA #> 35 30.46027        0        0    2    1      2     NA #> 36 42.76132        0        0    2    2      2     NA #> 37 32.44970        0        1    2    3      2      0 #> 38 36.08952        0        0    2    4      2     NA #> 39 41.96027        0        0    3    1      2     NA #> 40 45.06366        0        0    3    2      2     NA #> 41 51.31051        0        1    3    3      2      0 #> 42 34.06011        0        0    3    4      2     NA #> 43 50.30978        0        0    4    1      2     NA #> 44 32.58809        0        0    4    2      2     NA #> 45 26.49616        0        1    4    3      2      0 #> 46 27.90731        0        0    4    4      2     NA #> 47 30.96149        0        0    5    1      2     NA #> 48 33.31087        0        0    5    2      2     NA #> 49 44.68050        0        1    5    3      2      0 #> 50 42.13516        0        0    5    4      2     NA"},{"path":"https://bdhitt.github.io/binGroup2/reference/gtTest.html","id":null,"dir":"Reference","previous_headings":"","what":"Hypothesis test for one proportion in group testing — gtTest","title":"Hypothesis test for one proportion in group testing — gtTest","text":"Calculates p-values hypothesis tests single proportions estimated group testing experiments threshold proportion hypotheses. Available methods include exact test, score test, Wald test.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hypothesis test for one proportion in group testing — gtTest","text":"","code":"gtTest(n, y, s, p.hyp, alternative = \"two.sided\", method = \"exact\")"},{"path":"https://bdhitt.github.io/binGroup2/reference/gtTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hypothesis test for one proportion in group testing — gtTest","text":"n integer specifying number groups. y integer specifying number positive groups. s integer specifying common size groups. p.hyp hypothetical threshold proportion test, specified number 0 1. alternative character string defining alternative hypothesis, either \"two.sided\", \"less\", \"greater\". method character string defining test method used. Options include \"exact\" exact test corresponding Clopper-Pearson confidence interval, \"score\" score test corresponding Wilson confidence interval, \"Wald\" Wald test corresponding Wald confidence interval. Wald method recommended. \"exact\" method uses binom.test{stats}.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hypothesis test for one proportion in group testing — gtTest","text":"list containing: p.value p-value test estimate estimated proportion p.hyp threshold proportion provided user. alternative alternative provided user. method test method provided user.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtTest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hypothesis test for one proportion in group testing — gtTest","text":"function assumes equal group sizes, testing error (.e., 100 percent sensitivity specificity) test groups, individual units randomly assigned groups identical true probability success.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/gtTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hypothesis test for one proportion in group testing — gtTest","text":"function originally written bgtTest Frank Schaarschmidt binGroup package. Minor modifications made inclusion function binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hypothesis test for one proportion in group testing — gtTest","text":"","code":"# Consider the following the experiment: Tests are #   performed on n=10 groups, each group has a size #   of s=100 individuals. The aim is to show that less #   than 0.5 percent (\\eqn{p < 0.005}) of the units in #   the population show a detrimental trait (positive test). #   y=1 positive test and 9 negative tests are observed. gtTest(n = 10, y = 1, s = 100, p.hyp = 0.005,        alternative = \"less\", method = \"exact\") #>  #> exact test for one proportion in group testing #> Alternative hypothesis: true proportion is less than 0.005  #> p-value = 0.04996  #> point estimate = 0.001053   # The exact test corresponds to the #   limits of the Clopper-Pearson confidence interval #   in the example of Tebbs & Bilder (2004): gtTest(n = 24, y = 3, s = 7, alternative = \"two.sided\",        method = \"exact\", p.hyp = 0.0543) #>  #> exact test for one proportion in group testing #> Alternative hypothesis: true proportion is not equal to 0.0543  #> p-value = 0.05014  #> point estimate = 0.0189   gtTest(n = 24, y = 3, s = 7, alternative = \"two.sided\",        method = \"exact\", p.hyp = 0.0038) #>  #> exact test for one proportion in group testing #> Alternative hypothesis: true proportion is not equal to 0.0038  #> p-value = 0.04874  #> point estimate = 0.0189   # Hypothesis test with a group size of 1. gtTest(n = 24, y = 3, s = 1, alternative = \"two.sided\",        method = \"exact\", p.hyp = 0.1) #>  #> exact test for one proportion in group testing #> Alternative hypothesis: true proportion is not equal to 0.1  #> p-value = 0.8715  #> point estimate = 0.125   # Further methods: gtTest(n = 24, y = 3, s = 7, alternative = \"two.sided\",        method = \"score\", p.hyp = 0.0516) #>  #> score test for one proportion in group testing #> Alternative hypothesis: true proportion is not equal to 0.0516  #> p-value = 0.05019  #> point estimate = 0.0189   gtTest(n = 24, y = 3, s = 7, alternative = \"two.sided\",        method = \"Wald\", p.hyp = 0.0401) #>  #> Wald test for one proportion in group testing #> Alternative hypothesis: true proportion is not equal to 0.0401  #> p-value = 0.04988  #> point estimate = 0.0189"},{"path":"https://bdhitt.github.io/binGroup2/reference/gtWidth.html","id":null,"dir":"Reference","previous_headings":"","what":"Expected width of confidence intervals in group testing — gtWidth","title":"Expected width of confidence intervals in group testing — gtWidth","text":"Calculation expected value width confidence intervals one proportion group testing. Calculations available confidence interval methods propCI.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtWidth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expected width of confidence intervals in group testing — gtWidth","text":"","code":"gtWidth(n, s, p, conf.level = 0.95, alternative = \"two.sided\", method = \"CP\")"},{"path":"https://bdhitt.github.io/binGroup2/reference/gtWidth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expected width of confidence intervals in group testing — gtWidth","text":"n integer specifying number groups. vector integers also allowed. s integer specifying common size groups. vector integers also allowed. p assumed true proportion individuals showing trait estimated. vector also allowed. conf.level required confidence level interval. alternative character string specifying alternative hypothesis, either \"two.sided\", \"less\", \"greater\". method character string specifying confidence interval method. Available options include propCI.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtWidth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expected width of confidence intervals in group testing — gtWidth","text":"matrix containing columns: ns resulting total number units, \\(n*s\\). n number groups. s group size. p assumed true proportion. expCIWidth expected value confidence interval width defined argument alternative.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtWidth.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Expected width of confidence intervals in group testing — gtWidth","text":"two-sided (alternative=\"two.sided\") option calculates expected width lower upper bound two-sided \\(conf.level*100\\) percent confidence interval. See Tebbs & Bilder (2004) expression. one-sided (alternative=\"less\" alternative=\"greater\") options calculate expected distance one-sided limit assumed true proportion p one-sided \\(conf.level*100\\) percent confidence interval.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtWidth.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Expected width of confidence intervals in group testing — gtWidth","text":"Tebbs, J., Bilder, C. (2004). “Confidence interval procedures probability disease transmission multiple-vector-transfer designs.” Journal Agricultural, Biological, Environmental Statistics, 9, 75–90.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/gtWidth.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Expected width of confidence intervals in group testing — gtWidth","text":"function originally written bgtWidth Frank Schaarschmidt binGroup package. Minor modifications made inclusion function binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/gtWidth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expected width of confidence intervals in group testing — gtWidth","text":"","code":"# Examine different group sizes to determine #   the shortest expected width. gtWidth(n = 20, s = seq(from = 1, to = 200, by = 10),         p = 0.01, alternative = \"less\", method = \"CP\") #>         ns  n   s    p  expCIwidth #>  [1,]   20 20   1 0.01 0.144314249 #>  [2,]  220 20  11 0.01 0.020459877 #>  [3,]  420 20  21 0.01 0.013520195 #>  [4,]  620 20  31 0.01 0.010890547 #>  [5,]  820 20  41 0.01 0.009503989 #>  [6,] 1020 20  51 0.01 0.008665159 #>  [7,] 1220 20  61 0.01 0.008124800 #>  [8,] 1420 20  71 0.01 0.007771843 #>  [9,] 1620 20  81 0.01 0.007553342 #> [10,] 1820 20  91 0.01 0.007452126 #> [11,] 2020 20 101 0.01 0.007487536 #> [12,] 2220 20 111 0.01 0.007728727 #> [13,] 2420 20 121 0.01 0.008313282 #> [14,] 2620 20 131 0.01 0.009463048 #> [15,] 2820 20 141 0.01 0.011489335 #> [16,] 3020 20 151 0.01 0.014782427 #> [17,] 3220 20 161 0.01 0.019784901 #> [18,] 3420 20 171 0.01 0.026952691 #> [19,] 3620 20 181 0.01 0.036710802 #> [20,] 3820 20 191 0.01 0.049411254  # Calculate the expected width of the confidence #   interval with a group size of 1 (individual testing). gtWidth(n = 20, s = 1, p = 0.005, alternative = \"less\", method = \"CP\") #>   ns  n s     p expCIwidth #> n 20 20 1 0.005   0.141759"},{"path":"https://bdhitt.github.io/binGroup2/reference/halving.html","id":null,"dir":"Reference","previous_headings":"","what":"Probability mass function for halving — halving","title":"Probability mass function for halving — halving","text":"Calculate probability mass function number tests using halving algorithm.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/halving.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probability mass function for halving — halving","text":"","code":"halving(p, Se = 1, Sp = 1, stages = 2, order.p = TRUE)"},{"path":"https://bdhitt.github.io/binGroup2/reference/halving.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Probability mass function for halving — halving","text":"p vector individual risk probabilities. Se sensitivity diagnostic test. Sp specificity diagnostic test. stages number stages halving algorithm. order.p logical; TRUE, vector individual risk probabilities sorted.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/halving.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Probability mass function for halving — halving","text":"list containing: pmf probability mass function halving algorithm. et expected testing expenditure halving algorithm. vt variance testing expenditure halving           algorithm. p vector containing probabilities positivity individual.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/halving.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Probability mass function for halving — halving","text":"Halving algorithms involve successively splitting positive testing group two equal-sized halves (close equal possible) individuals identified positive negative. \\(S\\)-stage halving begins testing whole group \\(\\) individuals. Positive groups split half final stage algorithm, consists individual testing. example, consider initial group size \\(=16\\) individuals. Three-stage halving (3H) begins testing whole group 16 individuals. group tests positive, second stage involves splitting two groups size 8. either groups test positive, third stage involves testing individual rather halving . Four-stage halving (4H) continue halving groups size 4 individual testing. Five-stage halving (5H) continue halving groups size 2 individual testing. 3H requires 2 individuals, 4H requires 4 individuals, 5H requires 8 individuals. function calculates probability mass function, expected testing expenditure, variance testing expenditure halving algorithms 3 5 stages.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/halving.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Probability mass function for halving — halving","text":"Black, M., Bilder, C., Tebbs, J. (2012). “Group testing heterogeneous populations using halving algorithms.” Journal Royal Statistical Society. Series C: Applied Statistics, 61, 277–290.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/halving.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Probability mass function for halving — halving","text":"function originally written Michael Black Black et al. (2012). function obtained http://chrisbilder.com/grouptesting/. Minor modifications made inclusion function binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/halving.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Probability mass function for halving — halving","text":"","code":"# Equivalent to Dorfman testing (two-stage hierarchical) halving(p = rep(0.01, 10), Se = 1, Sp = 1, stages = 2,         order.p = TRUE) #> pmf : #>   num.tests prob.tests #> 1         1     0.9044 #> 2        11     0.0956 #>  #> et : #> [1] 1.956179 #>  #> vt : #> [1] 8.647514 #>  #> p : #>  [1] 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 #>   # Halving over three stages; each individual has a #   different probability of being positive set.seed(12895) p.vec <- expectOrderBeta(p = 0.05, alpha = 2, size = 20) halving(p = p.vec, Se = 0.95, Sp = 0.95, stages = 3,         order.p = TRUE) #> pmf : #>   num.tests prob.tests #> 1         1     0.3690 #> 2         3     0.0399 #> 3        13     0.4624 #> 4        23     0.1287 #>  #> et : #> [1] 9.459485 #>  #> vt : #> [1] 57.46018 #>  #> p : #>  [1] 0.00813011 0.01281577 0.01672941 0.02032010 0.02376267 0.02715206 #>  [7] 0.03055215 0.03401377 0.03758344 0.04130894 0.04524401 0.04945382 #> [13] 0.05402248 0.05906516 0.06474940 0.07133702 0.07927673 0.08944686 #> [19] 0.10398454 0.13105154 #>"},{"path":"https://bdhitt.github.io/binGroup2/reference/hivsurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Data from an HIV surveillance project — hivsurv","title":"Data from an HIV surveillance project — hivsurv","text":"hivsurv data set comes HIV surveillance project discussed Verstraeten et al. (1998) Vansteelandt et al. (2000). purpose study estimate HIV prevalence among pregnant Kenyan women four rural locations country, using individual group testing responses. Blood tests administered participating woman, 4 covariates obtained woman. original group responses unavailable, individuals artificially put groups 5 form group responses. 428 complete observations given.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/hivsurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data from an HIV surveillance project — hivsurv","text":"","code":"data(hivsurv)"},{"path":"https://bdhitt.github.io/binGroup2/reference/hivsurv.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data from an HIV surveillance project — hivsurv","text":"data frame 428 observations following 8 variables. DATE date sample collected. PAR. parity (number children). AGE age (years). MA.ST. marital status (1: single; 2: married (polygamous); 3: married (monogamous); 4: divorced; 5: widow). EDUC. highest attained education level (1: schooling; 2: primary school; 3: secondary school; 4: higher). HIV individual response HIV diagnosis (0: negative; 1: positive). gnum group number designates individuals groups. groupres group response calculated artificially formed groups.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/hivsurv.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Data from an HIV surveillance project — hivsurv","text":"Vansteelandt, S., Goetghebeur, E., Verstraeten, T. (2000). “Regression models disease prevalence diagnostic tests pools serum samples.” Biometrics, 56, 1126–1133. Verstraeten, T., Farah, B., Duchateau, L., Matu, R. (1998). “Pooling sera reduce cost HIV surveillance: feasibility study rural Kenyan district.” Tropical Medicine & International Health, 3, 747–750.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/hivsurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data from an HIV surveillance project — hivsurv","text":"","code":"data(hivsurv)  str(hivsurv) #> 'data.frame':\t428 obs. of  8 variables: #>  $ DATE    : Factor w/ 64 levels \"10/1/1996\",\"10/11/1996\",..: 47 53 53 53 53 53 53 53 60 60 ... #>  $ PAR.    : int  0 1 0 1 1 3 2 5 0 0 ... #>  $ AGE     : int  21 16 17 17 18 20 26 35 17 18 ... #>  $ MA.ST.  : int  3 3 3 3 3 3 3 3 3 3 ... #>  $ EDUC.   : int  4 2 1 2 1 2 2 2 2 2 ... #>  $ HIV     : int  0 0 0 0 0 0 0 0 0 0 ... #>  $ gnum    : int  1 1 1 1 1 2 2 2 2 2 ... #>  $ groupres: int  0 0 0 0 0 0 0 0 0 0 ..."},{"path":"https://bdhitt.github.io/binGroup2/reference/informativeArrayProb.html","id":null,"dir":"Reference","previous_headings":"","what":"Arrange a matrix of probabilities for informative array testing — informativeArrayProb","title":"Arrange a matrix of probabilities for informative array testing — informativeArrayProb","text":"Arrange vector individual risk probabilities matrix informative array testing without master pooling.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/informativeArrayProb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arrange a matrix of probabilities for informative array testing — informativeArrayProb","text":"","code":"informativeArrayProb(prob.vec, nr, nc, method = \"sd\")"},{"path":"https://bdhitt.github.io/binGroup2/reference/informativeArrayProb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arrange a matrix of probabilities for informative array testing — informativeArrayProb","text":"prob.vec vector individual risk probabilities, length nr * nc. nr number rows array. nc number columns array. method character string defining method used matrix arrangement. Options include spiral (\"sd\") gradient (\"gd\") arrangement. See McMahan et al. (2012) additional details.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/informativeArrayProb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Arrange a matrix of probabilities for informative array testing — informativeArrayProb","text":"matrix probabilities arranged according specified method.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/informativeArrayProb.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Arrange a matrix of probabilities for informative array testing — informativeArrayProb","text":"McMahan, C., Tebbs, J., Bilder, C. (2012b). “Two-Dimensional Informative Array Testing.” Biometrics, 68, 793–804.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/informativeArrayProb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Arrange a matrix of probabilities for informative array testing — informativeArrayProb","text":"function originally written Christopher McMahan McMahan et al. (2012). function obtained http://chrisbilder.com/grouptesting/.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/informativeArrayProb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arrange a matrix of probabilities for informative array testing — informativeArrayProb","text":"","code":"# Use the gradient arrangement method to create a matrix #   of individual risk probabilities for a 10x10 array. # Depending on the specified probability, alpha level, #   and overall group size, simulation may be necessary #   in order to generate the vector of individual #   probabilities. This is done using the expectOrderBeta() #   function and requires the user to set a seed in order #   to reproduce results. set.seed(1107) p.vec1 <- expectOrderBeta(p = 0.05, alpha = 2, size = 100) informativeArrayProb(prob.vec = p.vec1, nr = 10, nc = 10,                      method = \"gd\") #>             [,1]       [,2]       [,3]       [,4]       [,5]       [,6] #>  [1,] 0.17193388 0.09467980 0.07411090 0.06092015 0.05082629 0.04238657 #>  [2,] 0.14733559 0.09197756 0.07257579 0.05980526 0.04992281 0.04160348 #>  [3,] 0.13440942 0.08947726 0.07109986 0.05871781 0.04903450 0.04082921 #>  [4,] 0.12553848 0.08714856 0.06967801 0.05765607 0.04816056 0.04006328 #>  [5,] 0.11874115 0.08496750 0.06830576 0.05661848 0.04730023 0.03930523 #>  [6,] 0.11320756 0.08291482 0.06697916 0.05560359 0.04645278 0.03855460 #>  [7,] 0.10852663 0.08097481 0.06569469 0.05461006 0.04561756 0.03781097 #>  [8,] 0.10446071 0.07913448 0.06444923 0.05363666 0.04479392 0.03707390 #>  [9,] 0.10085984 0.07738296 0.06323996 0.05268226 0.04398125 0.03634299 #> [10,] 0.09762322 0.07571104 0.06206436 0.05174580 0.04317898 0.03561783 #>             [,7]       [,8]       [,9]       [,10] #>  [1,] 0.03489803 0.02790982 0.02101030 0.013532122 #>  [2,] 0.03418320 0.02722337 0.02030504 0.012694949 #>  [3,] 0.03347295 0.02653750 0.01959398 0.011827597 #>  [4,] 0.03276690 0.02585177 0.01887608 0.010923045 #>  [5,] 0.03206466 0.02516568 0.01815016 0.009971580 #>  [6,] 0.03136587 0.02447872 0.01741488 0.008959079 #>  [7,] 0.03067012 0.02379034 0.01666868 0.007863560 #>  [8,] 0.02997705 0.02309997 0.01590972 0.006647294 #>  [9,] 0.02928624 0.02240697 0.01513584 0.005234706 #> [10,] 0.02859730 0.02171066 0.01434439 0.003423839  # Use the spiral arrangement method to create a matrix #   of individual risk probabilities for a 5x5 array. set.seed(8791) p.vec2 <- expectOrderBeta(p = 0.02, alpha = 0.5, size = 25) informativeArrayProb(prob.vec = p.vec2, nr = 5, nc = 5,                      method = \"sd\") #>      array.probs                                                 #> [1,] 0.102394783 0.044727562 0.01940464 0.006168446 0.0000533017 #> [2,] 0.070663665 0.054971408 0.02273105 0.007431183 0.0002845401 #> [3,] 0.037229961 0.031389840 0.02666103 0.008442638 0.0007324966 #> [4,] 0.016551849 0.014008839 0.01146482 0.009628169 0.0012278623 #> [5,] 0.004650901 0.003236871 0.00228025 0.001818588 0.0015719877"},{"path":"https://bdhitt.github.io/binGroup2/reference/operatingCharacteristics1.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate operating characteristics for group testing algorithms that use a single-disease assay — operatingCharacteristics1","title":"Calculate operating characteristics for group testing algorithms that use a single-disease assay — operatingCharacteristics1","text":"Calculate operating characteristics, expected number tests, specified testing configuration using non-informative informative hierarchical array-based group testing algorithms. Single-disease assays used stage algorithms.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/operatingCharacteristics1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate operating characteristics for group testing algorithms that use a single-disease assay — operatingCharacteristics1","text":"","code":"operatingCharacteristics1(   algorithm,   p = NULL,   probabilities = NULL,   Se = 0.99,   Sp = 0.99,   hier.config = NULL,   rowcol.sz = NULL,   alpha = 2,   a = NULL,   print.time = TRUE,   ... )  opChar1(   algorithm,   p = NULL,   probabilities = NULL,   Se = 0.99,   Sp = 0.99,   hier.config = NULL,   rowcol.sz = NULL,   alpha = 2,   a = NULL,   print.time = TRUE,   ... )"},{"path":"https://bdhitt.github.io/binGroup2/reference/operatingCharacteristics1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate operating characteristics for group testing algorithms that use a single-disease assay — operatingCharacteristics1","text":"algorithm character string defining group testing algorithm used. Non-informative testing options include two-stage hierarchical (\"D2\"), three-stage hierarchical (\"D3\"), four-stage hierarchical (\"D4\"), square array testing without master pooling (\"A2\"), square array testing master pooling (\"A2M\"). Informative testing options include two-stage hierarchical (\"ID2\"), three-stage hierarchical (\"ID3\"), four-stage hierarchical (\"ID4\"), square array testing without master pooling (\"IA2\"). p overall probability disease used generate vector/matrix individual probabilities. non-informative algorithms, homogeneous set probabilities used. informative algorithms, expectOrderBeta function used generate heterogeneous set probabilities. details given 'Details'. Either p probabilities specified, . probabilities vector individual probabilities, homogeneous non-informative testing algorithms heterogeneous informative testing algorithms. Either  p probabilities specified, . Se vector sensitivity values, one value given stage testing (order). single value provided, sensitivity values assumed equal value stages testing. details given 'Details'. Sp vector specificity values, one value given stage testing (order). single value provided, specificity values assumed equal value stages testing. details given 'Details'. hier.config matrix specifying configuration hierarchical testing algorithm. rows correspond stages testing, columns correspond individual tested, cell values specify group number individual stage. details given 'Details'. array testing algorithms, argument ignored. rowcol.sz row/column size array testing algorithms. hierarchical testing algorithms, argument ignored. alpha shape parameter beta distribution specifies degree heterogeneity generated probability vector (informative testing ). vector containing indices indicating individuals calculate individual accuracy measures . NULL, individual accuracy measures displayed individuals algorithm. print.time logical value indicating whether length time calculations printed. default TRUE. ... arguments passed expectOrderBeta function, generates vector probabilities informative testing algorithms. details given 'Details'.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/operatingCharacteristics1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate operating characteristics for group testing algorithms that use a single-disease assay — operatingCharacteristics1","text":"list containing: algorithm group testing algorithm used calculations. prob probability disease vector individual probabilities, specified user. alpha level heterogeneity generated probability vector (informative testing ). Se vector sensitivity values stage testing. Sp vector specificity values stage testing. Config list specifying elements specified testing configuration, may include: Stage1 group size first stage hierarchical testing, applicable. Stage2 group sizes second stage hierarchical testing, applicable. Stage3 group sizes third stage hierarchical testing, applicable. Block.sz block size/initial group size informative Dorfman testing, tested. pool.szs group sizes first stage testing informative Dorfman testing. Array.dim row/column size array testing. Array.sz overall array size array testing (square row/column size). p.vec sorted vector individual probabilities, applicable. p.mat sorted matrix individual probabilities gradient arrangement, applicable. details given 'Details'. ET expected testing expenditure decode individuals algorithm; includes individuals groups hierarchical algorithms entire array array testing. value value expected number tests per individual. Accuracy list containing: Individual matrix accuracy measures individual specified . rows correspond unique set accuracy measures algorithm. Individuals set accuracy measures displayed together single row matrix. columns correspond pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value, indices individuals row matrix. Overall matrix overall accuracy measures algorithm. columns correspond pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value overall algorithm. details given 'Details'.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/operatingCharacteristics1.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate operating characteristics for group testing algorithms that use a single-disease assay — operatingCharacteristics1","text":"function computes operating characteristics group testing algorithms assay tests one disease, described Hitt et al. (2019). Available algorithms include two-, three-, four-stage hierarchical testing array testing without master pooling. non-informative informative group testing settings allowed algorithm, except informative array testing master pooling unavailable method appeared group testing literature. Operating characteristics calculated expected number tests, pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value individual. informative algorithms p argument specified, expected value order statistics beta distribution found. values used represent disease risk probabilities individual tested. beta distribution two parameters: mean parameter p (overall disease prevalence) shape parameter alpha (heterogeneity level). Depending specified p, alpha, overall group size, simulation may necessary generate vector individual probabilities. done using expectOrderBeta requires user set seed reproduce results. sensitivity/specificity values allowed vary across stages testing. hierarchical testing, different sensitivity/specificity value may used stage testing. array testing, different sensitivity/specificity value may used master pool testing (included), row/column testing, individual testing. values must specified order testing performed. example, values specified (stage 1, stage 2, stage 3) three-stage hierarchical testing (master pool testing, row/column testing, individual testing) array testing master pooling. single sensitivity/specificity value may specified instead. situation, sensitivity/specificity values stages assumed equal. matrix specified  hier.config defines hierarchical group testing algorithm \\(\\) individuals. rows matrix correspond stages \\(s=1,...,S\\) testing algorithm, columns correspond individuals \\(=1,...\\). cell values within matrix represent group number individual \\(\\) stage \\(s\\). three-stage, four-stage, non-informative two-stage hierarchical testing, first row matrix consists ones. indicates individuals algorithm tested together single group first stage testing. informative two-stage hierarchical testing, initial group (block) tested. Thus, first row matrix consists group numbers individual first stage testing. hierarchical algorithms, final row matrix denotes individual testing. Individuals tested particular stage represented \"NA\" (e.g., individual tested group size 1 second stage testing tested third stage testing). important note matrix represents testing performed group tests positively stage prior last. details matrix (called group membership matrix), see Bilder et al. (2019). array testing without master pooling, rowcol.sz specified represents row/column size initial (stage 1) testing. array testing master pooling, rowcol.sz specified represents row/column size stage 2 testing. master pool size overall array size, given square row/column size. displayed overall pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value weighted averages corresponding individual accuracy measures individuals within initial group (block) hierarchical algorithm, within entire array array-based algorithm. Expressions averages provided Supplementary Material Hitt et al. (2019). expressions based accuracy definitions given Altman Bland (1994a, 1994b). operatingCharacteristics1 function accepts additional arguments, namely num.sim, passed expectOrderBeta function, generates vector probabilities informative group testing algorithms. num.sim argument specifies number simulations beta distribution simulation used. default, 10,000 simulations used.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/operatingCharacteristics1.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate operating characteristics for group testing algorithms that use a single-disease assay — operatingCharacteristics1","text":"function returns pooling positive negative predictive values individuals even though measures diagnostic specific; e.g., pooling positive predictive value considered individuals tested positive. Additionally, stage dependent sensitivity specificity values allowed within program (group within stage dependent values allowed). See Bilder et al. (2019) additional information.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/operatingCharacteristics1.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate operating characteristics for group testing algorithms that use a single-disease assay — operatingCharacteristics1","text":"Altman, D., Bland, J. (1994). “Diagnostic tests 1: Sensitivity specificity.” BMJ, 308, 1552. Altman, D., Bland, J. (1994). “Diagnostic tests 2: Predictive values.” BMJ, 309, 102. Bilder, C., Tebbs, J., McMahan, C. (2019). “Informative group testing multiplex assays.” Biometrics, 75, 278–288. Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2019). “objective function controversy group testing: Much ado nothing?” Statistics Medicine, 38, 4912–4923. McMahan, C., Tebbs, J., Bilder, C. (2012a). “Informative Dorfman Screening.” Biometrics, 68, 287–296. McMahan, C., Tebbs, J., Bilder, C. (2012b). “Two-Dimensional Informative Array Testing.” Biometrics, 68, 793–804.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/operatingCharacteristics1.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate operating characteristics for group testing algorithms that use a single-disease assay — operatingCharacteristics1","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/operatingCharacteristics1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate operating characteristics for group testing algorithms that use a single-disease assay — operatingCharacteristics1","text":"","code":"# Calculate the operating characteristics for non-informative #   two-stage hierarchical (Dorfman) testing. config.mat <- matrix(data = c(rep(1, 10), 1:10),                      nrow = 2, ncol = 10, byrow = TRUE) opChar1(algorithm = \"D2\", p = 0.05, Se = 0.99, Sp = 0.99,         hier.config = config.mat, print.time = FALSE) #>  #> Algorithm: Non-informative two-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1 #> 1     10 #>  #> Expected number of tests: 5.0324 #> Expected number of tests per individual: 0.5032 #>  #> Accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.9801 0.9963 0.9327 0.9989         All #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9801 0.9963 0.9327 0.9989  # Calculate the operating characteristics for informative #   two-stage hierarchical (Dorfman) testing. # A vector of individual probabilities is generated using #   the expected value of order statistics from a beta #   distribution with p = 0.01 and a heterogeneity level #   of alpha = 0.5. config.mat <- matrix(data = c(rep(1:3, each = 10), 1:30),                      nrow = 2, ncol = 30, byrow = TRUE) set.seed(52613) opChar1(algorithm = \"ID2\", p = 0.01, Se = 0.95, Sp = 0.95,         hier.config = config.mat, alpha = 0.5, num.sim = 10000) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Informative two-stage hierarchical testing  #>  #> Testing configuration:  #>   Block.sz pool.szs #> 1       30 10,10,10 #>  #> Expected number of tests: 6.9658 #> Expected number of tests per individual: 0.2322 #>  #> Accuracy for individuals: #>       PSe    PSp   PPPV   PNPV Individuals #> 1  0.9025 0.9971 0.0006 1.0000           1 #> 2  0.9025 0.9971 0.0063 1.0000           2 #> 3  0.9025 0.9971 0.0298 1.0000           3 #> 4  0.9025 0.9971 0.0872 1.0000           4 #> 5  0.9025 0.9972 0.1773 0.9999           5 #> 6  0.9025 0.9972 0.2727 0.9999           6 #> 7  0.9025 0.9972 0.3428 0.9998           7 #> 8  0.9025 0.9952 0.2576 0.9998           8 #> 9  0.9025 0.9952 0.2507 0.9998           9 #> 10 0.9025 0.9972 0.3298 0.9999          10 #> 11 0.9025 0.9972 0.2983 0.9999          11 #> 12 0.9025 0.9972 0.3148 0.9999          12 #> 13 0.9025 0.9952 0.2796 0.9998          13 #> 14 0.9025 0.9953 0.3857 0.9997          14 #> 15 0.9025 0.9954 0.4924 0.9995          15 #> 16 0.9025 0.9954 0.5737 0.9993          16 #> 17 0.9025 0.9955 0.6218 0.9992          17 #> 18 0.9025 0.9882 0.4020 0.9991          18 #> 19 0.9025 0.9955 0.6318 0.9992          19 #> 20 0.9025 0.9955 0.6181 0.9992          20 #> 21 0.9025 0.9955 0.6277 0.9992          21 #> 22 0.9025 0.9883 0.4414 0.9990          22 #> 23 0.9025 0.9884 0.5146 0.9987          23 #> 24 0.9025 0.9885 0.5558 0.9984          24 #> 25 0.9025 0.9886 0.5935 0.9982          25 #> 26 0.9025 0.9887 0.6328 0.9979          26 #> 27 0.9025 0.9888 0.6744 0.9975          27 #> 28 0.9025 0.9890 0.7195 0.9969          28 #> 29 0.9025 0.9893 0.7713 0.9961          29 #> 30 0.9025 0.9900 0.8395 0.9943          30 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9025 0.9938 0.5937 0.9990 # Equivalent code using a heterogeneous vector of #   probabilities set.seed(52613) probs <- expectOrderBeta(p = 0.01, alpha = 0.5, size = 30) opChar1(algorithm = \"ID2\", probabilities = probs,         Se = 0.95, Sp = 0.95, hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Informative two-stage hierarchical testing  #>  #> Testing configuration:  #>   Block.sz pool.szs #> 1       30 10,10,10 #>  #> Expected number of tests: 6.9658 #> Expected number of tests per individual: 0.2322 #>  #> Accuracy for individuals: #>       PSe    PSp   PPPV   PNPV Individuals #> 1  0.9025 0.9971 0.0006 1.0000           1 #> 2  0.9025 0.9971 0.0063 1.0000           2 #> 3  0.9025 0.9971 0.0298 1.0000           3 #> 4  0.9025 0.9971 0.0872 1.0000           4 #> 5  0.9025 0.9972 0.1773 0.9999           5 #> 6  0.9025 0.9972 0.2727 0.9999           6 #> 7  0.9025 0.9972 0.2983 0.9999           7 #> 8  0.9025 0.9972 0.3148 0.9999           8 #> 9  0.9025 0.9972 0.3298 0.9999           9 #> 10 0.9025 0.9972 0.3428 0.9998          10 #> 11 0.9025 0.9952 0.2507 0.9998          11 #> 12 0.9025 0.9952 0.2576 0.9998          12 #> 13 0.9025 0.9952 0.2796 0.9998          13 #> 14 0.9025 0.9953 0.3857 0.9997          14 #> 15 0.9025 0.9954 0.4924 0.9995          15 #> 16 0.9025 0.9954 0.5737 0.9993          16 #> 17 0.9025 0.9955 0.6181 0.9992          17 #> 18 0.9025 0.9955 0.6218 0.9992          18 #> 19 0.9025 0.9955 0.6277 0.9992          19 #> 20 0.9025 0.9955 0.6318 0.9992          20 #> 21 0.9025 0.9882 0.4020 0.9991          21 #> 22 0.9025 0.9883 0.4414 0.9990          22 #> 23 0.9025 0.9884 0.5146 0.9987          23 #> 24 0.9025 0.9885 0.5558 0.9984          24 #> 25 0.9025 0.9886 0.5935 0.9982          25 #> 26 0.9025 0.9887 0.6328 0.9979          26 #> 27 0.9025 0.9888 0.6744 0.9975          27 #> 28 0.9025 0.9890 0.7195 0.9969          28 #> 29 0.9025 0.9893 0.7713 0.9961          29 #> 30 0.9025 0.9900 0.8395 0.9943          30 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9025 0.9938 0.5937 0.9990  # Calculate the operating characteristics for #   non-informative three-stage hierarchical testing. config.mat <- matrix(data = c(rep(1, 18), rep(1:3, each = 5),                               rep(4, 3), 1:18),                     nrow = 3, ncol = 18, byrow = TRUE) opChar1(algorithm = \"D3\", p = 0.001, Se = 0.95, Sp = 0.95,         hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Non-informative three-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1  Stage2 #> 1     18 5,5,5,3 #>  #> Expected number of tests: 1.3954 #> Expected number of tests per individual: 0.0775 #>  #> Accuracy for individuals: #>      PSe    PSp   PPPV   PNPV                         Individuals #> 1 0.8574 0.9997 0.7200 0.9999 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 #> 2 0.8574 0.9998 0.7755 0.9999                            16,17,18 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8574 0.9997 0.7287 0.9999 opChar1(algorithm = \"D3\", p = 0.001, Se = c(0.95, 0.95, 0.99),         Sp = c(0.96, 0.96, 0.98), hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Non-informative three-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1  Stage2 #> 1     18 5,5,5,3 #>  #> Expected number of tests: 1.3379 #> Expected number of tests per individual: 0.0743 #>  #> Accuracy for individuals: #>      PSe    PSp   PPPV   PNPV                         Individuals #> 1 0.8935 0.9999 0.8875 0.9999 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 #> 2 0.8935 0.9999 0.9190 0.9999                            16,17,18 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8935 0.9999 0.8926 0.9999  # Calculate the operating characteristics for #   informative three-stage hierarchical testing, #   given a heterogeneous vector of probabilities. config.mat <- matrix(data = c(rep(1, 6), rep(1:2, each = 3),                               1:6), nrow = 3, ncol = 6,                      byrow = TRUE) set.seed(52613) opChar1(algorithm = \"ID3\",          probabilities = c(0.012, 0.014, 0.011, 0.012, 0.010, 0.015),          Se = 0.99, Sp = 0.99, hier.config = config.mat,          alpha = 0.5, num.sim = 5000) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Informative three-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1 Stage2 #> 1      6    3,3 #>  #> Expected number of tests: 1.3782 #> Expected number of tests per individual: 0.2297 #>  #> Accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.9703 0.9998 0.9772 0.9997           1 #> 2 0.9703 0.9998 0.9801 0.9997           2 #> 3 0.9703 0.9998 0.9825 0.9996           3 #> 4 0.9703 0.9997 0.9763 0.9996           4 #> 5 0.9703 0.9997 0.9810 0.9996           5 #> 6 0.9703 0.9997 0.9829 0.9995           6 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9703 0.9998 0.9802 0.9996  # Calculate the operating characteristics for #   non-informative four-stage hierarchical testing. config.mat <- matrix(data = c(rep(1, 12), rep(1, 8),                               rep(2, 2), 3, 4, rep(1, 5),                               rep(2, 3), 3, 4, rep(NA, 2),                               1:8, rep(NA, 4)), nrow = 4,                      ncol = 12, byrow = TRUE) opChar1(algorithm = \"D4\", p = 0.041, Se = 0.99, Sp = 0.90,         hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Non-informative four-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1  Stage2  Stage3 #> 1     12 8,2,1,1 5,3,1,1 #>  #> Expected number of tests: 4.9988 #> Expected number of tests per individual: 0.4166 #>  #> Accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.9606 0.9839 0.7182 0.9983   1,2,3,4,5 #> 2 0.9606 0.9903 0.8094 0.9983       6,7,8 #> 3 0.9703 0.9921 0.8401 0.9987        9,10 #> 4 0.9801 0.9572 0.4944 0.9991       11,12 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9655 0.9824 0.7012 0.9985  # Calculate the operating characteristics for #   informative four-stage hierarchical testing. # A vector of individual probabilities is generated using #   the expected value of order statistics from a beta #   distribution with p = 0.041 and a heterogeneity level #   of alpha = 0.5. config.mat <- matrix(data = c(rep(1, 12), rep(1, 8),                               rep(2, 2), 3, 4, rep(1, 5),                               rep(2, 3), 3, 4, rep(NA, 2),                               1:8, rep(NA, 4)), nrow = 4,                      ncol = 12, byrow = TRUE) set.seed(5678) opChar1(algorithm = \"ID4\", p = 0.041, Se = 0.99, Sp = 0.90,         hier.config = config.mat, alpha = 0.5) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Informative four-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1  Stage2  Stage3 #> 1     12 8,2,1,1 5,3,1,1 #>  #> Expected number of tests: 3.8652 #> Expected number of tests per individual: 0.3221 #>  #> Accuracy for individuals: #>       PSe    PSp   PPPV   PNPV Individuals #> 1  0.9606 0.9961 0.1666 1.0000           1 #> 2  0.9606 0.9963 0.3826 0.9999           2 #> 3  0.9606 0.9965 0.5724 0.9998           3 #> 4  0.9606 0.9968 0.7187 0.9997           4 #> 5  0.9606 0.9973 0.8230 0.9995           5 #> 6  0.9606 0.9933 0.7345 0.9992           6 #> 7  0.9606 0.9940 0.8152 0.9989           7 #> 8  0.9606 0.9950 0.8800 0.9985           8 #> 9  0.9703 0.9895 0.8318 0.9984           9 #> 10 0.9703 0.9913 0.8938 0.9978          10 #> 11 0.9801 0.9600 0.7305 0.9977          11 #> 12 0.9801 0.9642 0.8389 0.9961          12 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9733 0.9897 0.8020 0.9988  # Calculate the operating characteristics for #   non-informative array testing without master pooling. opChar1(algorithm = \"A2\", p = 0.005, Se = c(0.95, 0.99),         Sp = c(0.95, 0.99), rowcol.sz = 8, a = 1) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Non-informative array testing without master pooling  #>  #> Testing configuration:  #>   Array.dim Array.sz #> 1         8       64 #>  #> Expected number of tests: 19.9643 #> Expected number of tests per individual: 0.3119 #>  #> Accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.9438 0.9994 0.8919 0.9997         All #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9438 0.9994 0.8919 0.9997  # Calculate the operating characteristics for #   informative array testing without master pooling. # A vector of individual probabilities is generated using #   the expected value of order statistics from a beta #   distribution with p = 0.03 and a heterogeneity level #   of alpha = 2. set.seed(1002) opChar1(algorithm = \"IA2\", p = 0.03, Se = 0.95, Sp = 0.95,          rowcol.sz = 8, alpha = 2, a = 1:10) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Informative array testing without master pooling  #>  #> Testing configuration:  #>   Array.dim Array.sz #> 1         8       64 #>  #> Expected number of tests: 21.5022 #> Expected number of tests per individual: 0.3360 #>  #> Accuracy for individuals: #>       PSe    PSp   PPPV   PNPV Individuals #> 1  0.8726 0.9951 0.9509 0.9862           1 #> 2  0.8711 0.9956 0.9160 0.9928           2 #> 3  0.8706 0.9961 0.9021 0.9946           3 #> 4  0.8702 0.9965 0.8905 0.9958           4 #> 5  0.8699 0.9969 0.8787 0.9966           5 #> 6  0.8697 0.9973 0.8648 0.9974           6 #> 7  0.8695 0.9977 0.8458 0.9981           7 #> 8  0.8692 0.9982 0.8141 0.9988           8 #> 9  0.8724 0.9951 0.9411 0.9886           9 #> 10 0.8710 0.9958 0.9169 0.9931          10 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8707 0.9970 0.8993 0.9960  # Calculate the operating characteristics for #   non-informative array testing with master pooling. opChar1(algorithm = \"A2M\", p = 0.02, Se = c(0.95,0.95,0.99),         Sp = c(0.98,0.98,0.99), rowcol.sz = 5) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Non-informative array testing with master pooling  #>  #> Testing configuration:  #>   Array.dim Array.sz #> 1         5       25 #>  #> Expected number of tests: 5.6725 #> Expected number of tests per individual: 0.2269 #>  #> Accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.9050 0.9999 0.9928 0.9981         All #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9050 0.9999 0.9928 0.9981"},{"path":"https://bdhitt.github.io/binGroup2/reference/operatingCharacteristics2.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate operating characteristics for group testing algorithms that use a multiplex assay for two diseases — operatingCharacteristics2","title":"Calculate operating characteristics for group testing algorithms that use a multiplex assay for two diseases — operatingCharacteristics2","text":"Calculate operating characteristics, expected number tests, specified testing configuration using non-informative informative hierarchical array-based group testing algorithms. Multiplex assays two diseases used stage algorithms.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/operatingCharacteristics2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate operating characteristics for group testing algorithms that use a multiplex assay for two diseases — operatingCharacteristics2","text":"","code":"operatingCharacteristics2(   algorithm,   p.vec = NULL,   probabilities = NULL,   alpha = NULL,   Se,   Sp,   hier.config = NULL,   rowcol.sz = NULL,   ordering = matrix(data = c(0, 1, 0, 1, 0, 0, 1, 1), nrow = 4, ncol = 2),   a = NULL,   print.time = TRUE,   ... )  opChar2(   algorithm,   p.vec = NULL,   probabilities = NULL,   alpha = NULL,   Se,   Sp,   hier.config = NULL,   rowcol.sz = NULL,   ordering = matrix(data = c(0, 1, 0, 1, 0, 0, 1, 1), nrow = 4, ncol = 2),   a = NULL,   print.time = TRUE,   ... )"},{"path":"https://bdhitt.github.io/binGroup2/reference/operatingCharacteristics2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate operating characteristics for group testing algorithms that use a multiplex assay for two diseases — operatingCharacteristics2","text":"algorithm character string defining group testing algorithm used. Non-informative testing options include two-stage hierarchical (\"D2\"), three-stage hierarchical (\"D3\"), four-stage hierarchical (\"D4\"), five-stage hierarchical (\"D5\"), square array testing without master pooling (\"A2\"), square array testing master pooling (\"A2M\"). Informative testing options include two-stage hierarchical (\"ID2\"), three-stage hierarchical (\"ID3\"), four-stage hierarchical (\"ID4\"), five-stage hierarchical (\"ID5\") testing. p.vec vector overall joint probabilities. joint probabilities assumed equal individuals algorithm (non-informative testing ). four joint probabilities consider: \\(p_{00}\\), probability individual tests negative diseases; \\(p_{10}\\), probability individual tests positive first disease; \\(p_{01}\\), probability individual tests positive second disease; \\(p_{11}\\), probability individual tests positive diseases. joint probabilities must sum 1. one p.vec, probabilities, alpha specified. probabilities matrix joint probabilities individual, rows correspond four joint probabilities columns correspond individual algorithm. one p.vec, probabilities, alpha specified. alpha vector containing positive shape parameters Dirichlet distribution (informative testing ). vector used generate heterogeneous matrix joint probabilities individual. vector must length 4. details given 'Details'. one p.vec, probabilities, alpha specified. Se matrix sensitivity values, one value given disease (infection) stage testing. rows matrix correspond disease \\(k=1,2\\), columns matrix correspond stage testing \\(s=1,...,S\\). vector 2 values provided, sensitivity values associated disease assumed equal \\(k\\)th value vector stages testing. details given 'Details'. Sp matrix specificity values, one value given disease (infection) stage testing. rows matrix correspond disease \\(k=1,2\\), columns matrix correspond stage testing \\(s=1,...,S\\). vector 2 values provided, specificity values associated disease \\(k\\) assumed equal \\(k\\)th value vector stages testing. details given 'Details'. hier.config matrix specifying configuration hierarchical testing algorithm. rows correspond stages testing, columns correspond individual tested, cell values specify group number individual stage. details given 'Details'. array testing algorithms, argument ignored. rowcol.sz row/column size array testing algorithms. hierarchical testing algorithms, argument ignored. ordering matrix detailing ordering binary responses diseases. columns matrix correspond disease rows matrix correspond 4 sets binary responses two diseases. ordering used joint probabilities. default ordering (p_00, p_10, p_01, p_11). vector containing indices indicating individuals calculate individual accuracy measures . NULL, individual accuracy measures displayed individuals algorithm. print.time logical value indicating whether length time calculations printed. default TRUE. ... additional arguments passed functions hierarchical testing multiplex assays two diseases.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/operatingCharacteristics2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate operating characteristics for group testing algorithms that use a multiplex assay for two diseases — operatingCharacteristics2","text":"list containing: algorithm group testing algorithm used calculations. prob.vec vector joint probabilities provided user, applicable (non-informative algorithms ). joint.p matrix joint probabilities individual provided user, applicable. alpha.vec alpha vector provided user, applicable (informative algorithms ). Se matrix sensitivity values disease stage testing. Sp matrix specificity values disease stage testing. Config list specifying elements specified testing configuration, may include: Stage1 group size first stage hierarchical testing, applicable. Stage2 group sizes second stage hierarchical testing, applicable. Stage3 group sizes third stage hierarchical testing, applicable. Stage4 group sizes fourth stage hierarchical testing, applicable. Block.sz block size/initial group size informative Dorfman testing, tested. pool.szs group sizes first stage testing informative Dorfman testing. Array.dim row/column size array testing. Array.sz overall array size array testing (square row/column size). p.mat matrix joint probabilities individual algorithm. row corresponds one four joint probabilities. column corresponds individual testing algorithm. ET expected testing expenditure OTC. value value expected number tests per individual. Accuracy list containing: Disease 1 Individual matrix accuracy measures, pertaining first disease, individual specified . rows correspond unique set accuracy measures algorithm. Individuals set accuracy measures displayed together single row matrix. columns correspond pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value, indices individuals row matrix. Individual accuracy measures displayed array testing algorithms. Disease 2 Individual matrix accuracy measures, pertaining second disease, individual specified . rows correspond unique set accuracy measures algorithm. Individuals set accuracy measures displayed together single row matrix. columns correspond pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value, indices individuals row matrix. Individual accuracy measures displayed array testing algorithms. Overall matrix overall accuracy measures algorithm. rows correspond disease. columns correspond pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value overall algorithm. details given 'Details'.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/operatingCharacteristics2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate operating characteristics for group testing algorithms that use a multiplex assay for two diseases — operatingCharacteristics2","text":"function computes operating characteristics standard group testing algorithms multiplex assay tests two diseases. Calculations hierarchical group testing algorithms performed described Bilder et al. (2019) calculations array-based group testing algorithms performed described Hou et al. (2019). Available algorithms include two-, three-, four-, five-stage hierarchical testing array testing without master pooling. non-informative informative group testing settings allowed hierarchical algorithms. non-informative group testing settings allowed array testing algorithms. Operating characteristics calculated expected number tests, pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value individual. informative algorithms alpha argument specified, heterogeneous matrix joint probabilities individual generated using Dirichlet distribution. done using rBeta2009::rdirichlet requires user set seed reproduce results. See Bilder et al. (2019) additional details use Dirichlet distribution purpose. sensitivity/specificity values allowed vary across stages testing. hierarchical testing, different sensitivity/specificity value may used stage testing. array testing, different sensitivity/specificity value may used master pool testing (included), row/column testing, individual testing. values must specified order testing performed. example, values specified (stage 1, stage 2, stage 3) three-stage hierarchical testing (master pool testing, row/column testing, individual testing) array testing master pooling. vector 2 sensitivity/specificity values may specified, sensitivity/specificity values stages testing assumed equal. first value vector used stage testing first disease, second value vector used stage testing second disease. matrix specified  hier.config defines hierarchical group testing algorithm \\(\\) individuals. rows matrix correspond stages \\(s=1,...,S\\) testing algorithm, columns correspond individuals \\(=1,...\\). cell values within matrix represent group number individual \\(\\) stage \\(s\\). three-stage, four-stage, five-stage, non-informative two-stage hierarchical testing, first row matrix consists ones. indicates individuals algorithm tested together single group first stage testing. informative two-stage hierarchical testing, initial group (block) tested. Thus, first row matrix consists group numbers individual first stage testing. hierarchical algorithms, final row matrix denotes individual testing. Individuals tested particular stage represented \"NA\" (e.g., individual tested group size 1 second stage testing tested third stage testing). important note matrix represents testing performed group tests positively stage prior last. details matrix (called group membership matrix), see Bilder et al. (2019). array testing without master pooling, rowcol.sz specified represents row/column size initial (stage 1) testing. array testing master pooling, rowcol.sz specified represents row/column size stage 2 testing. master pool size overall array size, given square row/column size. displayed overall pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value weighted averages corresponding individual accuracy measures individuals within initial group (block) hierarchical algorithm, within entire array array-based algorithm. Expressions averages provided Supplementary Material Hitt et al. (2019). expressions based accuracy definitions given Altman Bland (1994a, 1994b).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/operatingCharacteristics2.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate operating characteristics for group testing algorithms that use a multiplex assay for two diseases — operatingCharacteristics2","text":"function returns pooling positive negative predictive values individuals even though measures diagnostic specific; e.g., pooling positive predictive value considered individuals tested positive. Additionally, stage dependent sensitivity specificity values allowed within program (group within stage dependent values allowed). See Bilder et al. (2019) additional information.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/operatingCharacteristics2.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate operating characteristics for group testing algorithms that use a multiplex assay for two diseases — operatingCharacteristics2","text":"Altman, D., Bland, J. (1994). “Diagnostic tests 1: Sensitivity specificity.” BMJ, 308, 1552. Altman, D., Bland, J. (1994). “Diagnostic tests 2: Predictive values.” BMJ, 309, 102. Bilder, C., Tebbs, J., McMahan, C. (2019). “Informative group testing multiplex assays.” Biometrics, 75, 278–288. Hitt, B., Bilder, C., Tebbs, J., McMahan, C. (2019). “objective function controversy group testing: Much ado nothing?” Statistics Medicine, 38, 4912–4923. Hou, P., Tebbs, J., Wang, D., McMahan, C., Bilder, C. (2021). “Array testing multiplex assays.” Biostatistics, 21, 417–431. McMahan, C., Tebbs, J., Bilder, C. (2012a). “Informative Dorfman Screening.” Biometrics, 68, 287–296.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/operatingCharacteristics2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate operating characteristics for group testing algorithms that use a multiplex assay for two diseases — operatingCharacteristics2","text":"function written Brianna D. Hitt. calls ET..stages.new PSePSpAllStages, originally written Christopher Bilder Bilder et al. (2019), ARRAY, originally written Peijie Hou Hou et al. (2020). functions ET..stages.new, PSePSpAllStages, ARRAY obtained http://chrisbilder.com/grouptesting/. Minor modifications made functions inclusion binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/operatingCharacteristics2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate operating characteristics for group testing algorithms that use a multiplex assay for two diseases — operatingCharacteristics2","text":"","code":"# Calculate the operating characteristics for #   non-informative two-stage hierarchical #   (Dorfman) testing. config.mat <- matrix(data = c(rep(1, 24), 1:24),                      nrow = 2, ncol = 24, byrow = TRUE) Se <- matrix(data = c(0.95, 0.95, 0.95, 0.95),              nrow = 2, ncol = 2,              dimnames = list(Infection = 1:2, Stage = 1:2)) Sp <- matrix(data = c(0.99, 0.99, 0.99, 0.99),              nrow = 2, ncol = 2,              dimnames = list(Infection = 1:2, Stage = 1:2)) opChar2(algorithm = \"D2\", p.vec = c(0.90, 0.04, 0.04, 0.02),          Se = Se, Sp = Sp, hier.config = config.mat, print.time = FALSE) #>  #> Algorithm: Non-informative two-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1 #> 1     24 #>  #> Expected number of tests: 22.7375 #> Expected number of tests per individual: 0.9474 #>  #> Disease 1 accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.9405 0.9910 0.8696 0.9962         All #>  #> Disease 2 accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.9405 0.9910 0.8696 0.9962         All #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9405 0.9910 0.8696 0.9962 #> 2 0.9405 0.9910 0.8696 0.9962  # Calculate the operating characteristics for informative #   two-stage hierarchical (Dorfman) testing. # A matrix of joint probabilities for each individual is #   generated using the Dirichlet distribution. config.mat <- matrix(data = c(rep(1, 5), rep(2, 4), 3, 1:9, NA),                      nrow = 2, ncol = 10, byrow = TRUE) Se <- matrix(data = c(0.95, 0.95, 0.99, 0.99),              nrow = 2, ncol = 2,              dimnames = list(Infection = 1:2, Stage = 1:2)) Sp <- matrix(data = c(0.96, 0.96, 0.98, 0.98),              nrow = 2, ncol = 2,              dimnames = list(Infection = 1:2, Stage = 1:2)) set.seed(8791) opChar2(algorithm = \"ID2\", alpha = c(18.25, 0.75, 0.75, 0.25),          Se = Se, Sp = Sp, hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Informative two-stage hierarchical testing  #>  #> Testing configuration:  #>   Block.sz pool.szs #> 1       10    5,4,1 #>  #> Expected number of tests: 5.8242 #> Expected number of tests per individual: 0.5824 #>  #> Disease 1 accuracy for individuals: #>       PSe    PSp   PPPV   PNPV Individuals #> 1  0.9753 0.9865 0.0272 1.0000           1 #> 2  0.9650 0.9244 0.2261 0.9991           2 #> 3  0.9803 0.8352 0.1660 0.9992           3 #> 4  0.9622 0.8839 0.2603 0.9982           4 #> 5  0.9820 0.9590 0.1273 0.9999           5 #> 6  0.9657 0.9415 0.5234 0.9976           6 #> 7  0.9601 0.9584 0.5311 0.9980           7 #> 8  0.9846 0.8696 0.4664 0.9980           8 #> 9  0.9685 0.9505 0.4958 0.9983           9 #> 10 0.9500 0.9600 0.8458 0.9881          10 #>  #> Disease 2 accuracy for individuals: #>       PSe    PSp   PPPV   PNPV Individuals #> 1  0.9625 0.9647 0.4600 0.9988           1 #> 2  0.9660 0.9556 0.3354 0.9992           2 #> 3  0.9782 0.8463 0.1970 0.9990           3 #> 4  0.9652 0.9689 0.3213 0.9995           4 #> 5  0.9643 0.9210 0.4310 0.9976           5 #> 6  0.9829 0.9743 0.3496 0.9998           6 #> 7  0.9613 0.9631 0.5498 0.9981           7 #> 8  0.9855 0.8727 0.4639 0.9982           8 #> 9  0.9660 0.9281 0.5613 0.9965           9 #> 10 0.9500 0.9600 0.7370 0.9939          10 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9644 0.9270 0.4347 0.9978 #> 2 0.9671 0.9360 0.4507 0.9981 # Equivalent code using a heterogeneous matrix of joint #   probabilities for each individual set.seed(8791) p.unordered <- t(rBeta2009::rdirichlet(n = 10,                             shape = c(18.25, 0.75, 0.75, 0.25))) p.ordered <- p.unordered[, order(1 - p.unordered[1,])] opChar2(algorithm = \"ID2\", probabilities = p.ordered,         Se = Se, Sp = Sp, hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Informative two-stage hierarchical testing  #>  #> Testing configuration:  #>   Block.sz pool.szs #> 1       10    5,4,1 #>  #> Expected number of tests: 5.8242 #> Expected number of tests per individual: 0.5824 #>  #> Disease 1 accuracy for individuals: #>       PSe    PSp   PPPV   PNPV Individuals #> 1  0.9753 0.9865 0.0272 1.0000           1 #> 2  0.9650 0.9244 0.2261 0.9991           2 #> 3  0.9803 0.8352 0.1660 0.9992           3 #> 4  0.9622 0.8839 0.2603 0.9982           4 #> 5  0.9820 0.9590 0.1273 0.9999           5 #> 6  0.9657 0.9415 0.5234 0.9976           6 #> 7  0.9601 0.9584 0.5311 0.9980           7 #> 8  0.9846 0.8696 0.4664 0.9980           8 #> 9  0.9685 0.9505 0.4958 0.9983           9 #> 10 0.9500 0.9600 0.8458 0.9881          10 #>  #> Disease 2 accuracy for individuals: #>       PSe    PSp   PPPV   PNPV Individuals #> 1  0.9625 0.9647 0.4600 0.9988           1 #> 2  0.9660 0.9556 0.3354 0.9992           2 #> 3  0.9782 0.8463 0.1970 0.9990           3 #> 4  0.9652 0.9689 0.3213 0.9995           4 #> 5  0.9643 0.9210 0.4310 0.9976           5 #> 6  0.9829 0.9743 0.3496 0.9998           6 #> 7  0.9613 0.9631 0.5498 0.9981           7 #> 8  0.9855 0.8727 0.4639 0.9982           8 #> 9  0.9660 0.9281 0.5613 0.9965           9 #> 10 0.9500 0.9600 0.7370 0.9939          10 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9644 0.9270 0.4347 0.9978 #> 2 0.9671 0.9360 0.4507 0.9981  # Calculate the operating characteristics for #   non-informative three-stage hierarchical testing. config.mat <- matrix(data = c(rep(1, 10), rep(1, 5),                               rep(2, 4), 3, 1:9, NA),                      nrow = 3, ncol = 10, byrow = TRUE) Se <- matrix(data = rep(0.95, 6), nrow = 2, ncol = 3,              dimnames = list(Infection = 1:2, Stage = 1:3)) Sp <- matrix(data = rep(0.99, 6), nrow = 2, ncol = 3,              dimnames = list(Infection = 1:2, Stage = 1:3)) opChar2(algorithm = \"D3\", p.vec = c(0.95, 0.02, 0.02, 0.01),          Se = Se, Sp = Sp, hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Non-informative three-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1 Stage2 #> 1     10  5,4,1 #>  #> Expected number of tests: 3.9765 #> Expected number of tests per individual: 0.3977 #>  #> Disease 1 accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.8975 0.9981 0.9354 0.9968   1,2,3,4,5 #> 2 0.8966 0.9985 0.9476 0.9968     6,7,8,9 #> 3 0.9250 0.9962 0.8824 0.9977          10 #>  #> Disease 2 accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.8975 0.9981 0.9354 0.9968   1,2,3,4,5 #> 2 0.8966 0.9985 0.9476 0.9968     6,7,8,9 #> 3 0.9250 0.9962 0.8824 0.9977          10 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8999 0.9980 0.9344 0.9969 #> 2 0.8999 0.9980 0.9344 0.9969 opChar2(algorithm = \"D3\", p.vec = c(0.95, 0.02, 0.02, 0.01),         Se = Se, Sp = Sp, hier.config = config.mat,         a = c(1, 6, 10)) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Non-informative three-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1 Stage2 #> 1     10  5,4,1 #>  #> Expected number of tests: 3.9765 #> Expected number of tests per individual: 0.3977 #>  #> Disease 1 accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.8975 0.9981 0.9354 0.9968           1 #> 2 0.8966 0.9985 0.9476 0.9968           6 #> 3 0.9250 0.9962 0.8824 0.9977          10 #>  #> Disease 2 accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.8975 0.9981 0.9354 0.9968           1 #> 2 0.8966 0.9985 0.9476 0.9968           6 #> 3 0.9250 0.9962 0.8824 0.9977          10 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8999 0.9980 0.9344 0.9969 #> 2 0.8999 0.9980 0.9344 0.9969  # Calculate the operating characteristics for informative #   three-stage hierarchical testing. # A matrix of joint probabilities for each individual is #   generated using the Dirichlet distribution. config.mat <- matrix(data = c(rep(1, 15),                               rep(c(1, 2, 3), each = 5), 1:15),                      nrow = 3, ncol = 15, byrow = TRUE) Se <- matrix(data = rep(0.95, 6), nrow = 2, ncol = 3,              dimnames = list(Infection = 1:2, Stage = 1:3)) Sp <- matrix(data = rep(0.99, 6), nrow = 2, ncol = 3,              dimnames = list(Infection = 1:2, Stage = 1:3)) opChar2(algorithm = \"ID3\", alpha = c(18.25, 0.75, 0.75, 0.25),          Se = Se, Sp = Sp, hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Informative three-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1 Stage2 #> 1     15  5,5,5 #>  #> Expected number of tests: 6.5272 #> Expected number of tests per individual: 0.4351 #>  #> Disease 1 accuracy for individuals: #>       PSe    PSp   PPPV   PNPV Individuals #> 1  0.8899 0.9987 0.3819 0.9999           1 #> 2  0.9401 0.9988 0.8075 0.9997           2 #> 3  0.8863 0.9987 0.7019 0.9996           3 #> 4  0.9371 0.9989 0.9589 0.9983           4 #> 5  0.9161 0.9987 0.7964 0.9996           5 #> 6  0.8795 0.9979 0.9252 0.9965           6 #> 7  0.8853 0.9978 0.8743 0.9980           7 #> 8  0.8804 0.9980 0.9524 0.9947           8 #> 9  0.9029 0.9979 0.9264 0.9972           9 #> 10 0.8872 0.9982 0.9696 0.9927          10 #> 11 0.8880 0.9966 0.9556 0.9907          11 #> 12 0.9048 0.9963 0.9075 0.9962          12 #> 13 0.8853 0.9964 0.9390 0.9929          13 #> 14 0.9075 0.9966 0.9540 0.9927          14 #> 15 0.9416 0.9964 0.9206 0.9974          15 #>  #> Disease 2 accuracy for individuals: #>       PSe    PSp   PPPV   PNPV Individuals #> 1  0.8800 0.9987 0.6786 0.9996           1 #> 2  0.8922 0.9989 0.9497 0.9975           2 #> 3  0.8781 0.9989 0.9455 0.9973           3 #> 4  0.9191 0.9990 0.9724 0.9970           4 #> 5  0.8819 0.9990 0.9753 0.9950           5 #> 6  0.8811 0.9978 0.8786 0.9979           6 #> 7  0.8853 0.9979 0.9323 0.9963           7 #> 8  0.8817 0.9978 0.7835 0.9989           8 #> 9  0.8999 0.9980 0.9422 0.9963           9 #> 10 0.9128 0.9978 0.8526 0.9988          10 #> 11 0.8899 0.9961 0.3152 0.9998          11 #> 12 0.8973 0.9965 0.9443 0.9932          12 #> 13 0.8835 0.9964 0.9186 0.9946          13 #> 14 0.9088 0.9965 0.9496 0.9934          14 #> 15 0.9049 0.9969 0.9752 0.9872          15 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8991 0.9978 0.9334 0.9965 #> 2 0.8976 0.9978 0.9359 0.9963  # Calculate the operating characteristics for #   non-informative four-stage hierarchical testing. config.mat <- matrix(data = c(rep(1, 12), rep(1, 6), rep(2, 6),                               rep(1, 4), rep(2, 2), rep(3, 3),                               rep(4, 3), 1:12),                      nrow = 4, ncol = 12, byrow = TRUE) Se <- matrix(data = rep(0.95, 8), nrow = 2, ncol = 4,              dimnames = list(Infection = 1:2, Stage = 1:4)) Sp <- matrix(data = rep(0.99, 8), nrow = 2, ncol = 4,              dimnames = list(Infection = 1:2, Stage = 1:4)) opChar2(algorithm = \"D4\", p.vec = c(0.92, 0.05, 0.02, 0.01),          Se = Se, Sp = Sp, hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Non-informative four-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1 Stage2  Stage3 #> 1     12    6,6 4,2,3,3 #>  #> Expected number of tests: 6.2334 #> Expected number of tests per individual: 0.5195 #>  #> Disease 1 accuracy for individuals: #>      PSe    PSp   PPPV   PNPV    Individuals #> 1 0.8548 0.9979 0.9621 0.9908        1,2,3,4 #> 2 0.8526 0.9991 0.9831 0.9907            5,6 #> 3 0.8537 0.9984 0.9720 0.9907 7,8,9,10,11,12 #>  #> Disease 2 accuracy for individuals: #>      PSe    PSp   PPPV   PNPV    Individuals #> 1 0.8840 0.9977 0.9209 0.9964        1,2,3,4 #> 2 0.8807 0.9988 0.9586 0.9963            5,6 #> 3 0.8824 0.9982 0.9385 0.9964 7,8,9,10,11,12 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8539 0.9983 0.9705 0.9907 #> 2 0.8826 0.9981 0.9358 0.9964  # Calculate the operating characteristics for informative #   five-stage hierarchical testing. # A matrix of joint probabilities for each individual is #   generated using the Dirichlet distribution. config.mat <- matrix(data = c(rep(1, 20), rep(1, 10), rep(2, 10),                               rep(c(1, 2, 3, 4), each = 5),                               rep(1, 3), rep(2, 2), rep(3, 3),                               rep(4, 2), rep(5, 3), rep(6, 2),                               rep(7, 3), rep(8, 2), 1:20),                      nrow = 5, ncol = 20, byrow = TRUE) Se <- matrix(data = rep(0.95, 10), nrow = 2, ncol = 5,              dimnames = list(Infection = 1:2, Stage = 1:5)) Sp <- matrix(data = rep(0.99, 10), nrow = 2, ncol = 5,              dimnames = list(Infection = 1:2, Stage = 1:5)) opChar2(algorithm = \"ID5\", alpha = c(18.25, 0.75, 0.75, 0.25),         Se = Se, Sp = Sp, hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Informative five-stage hierarchical testing  #>  #> Testing configuration:  #>   Stage1 Stage2  Stage3          Stage4 #> 1     20  10,10 5,5,5,5 3,2,3,2,3,2,3,2 #>  #> Expected number of tests: 10.9673 #> Expected number of tests per individual: 0.5484 #>  #> Disease 1 accuracy for individuals: #>   PSe PSp PPPV PNPV Individuals #> 1  NA  NA   NA   NA        <NA> #>  #> Disease 2 accuracy for individuals: #>   PSe PSp PPPV PNPV Individuals #> 1  NA  NA   NA   NA        <NA> #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8485 0.9986 0.9747 0.9907 #> 2 0.8685 0.9985 0.9611 0.9945  # Calculate the operating characteristics for #   non-informative array testing without master pooling. Se <- matrix(data = rep(0.95, 4), nrow = 2, ncol = 2,              dimnames = list(Infection = 1:2, Stage = 1:2)) Sp <- matrix(data = rep(0.99, 4), nrow = 2, ncol = 2,              dimnames = list(Infection = 1:2, Stage = 1:2)) opChar2(algorithm = \"A2\", p.vec = c(0.90, 0.04, 0.04, 0.02),          Se = Se, Sp = Sp, rowcol.sz = 12) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Non-informative array testing without master pooling  #>  #> Testing configuration:  #>   Array.dim Array.sz #> 1        12      144 #>  #> Expected number of tests: 85.9259 #> Expected number of tests per individual: 0.5967 #>  #> Disease 1 accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.8991 0.9960 0.9353 0.9936         All #>  #> Disease 2 accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.8991 0.9960 0.9353 0.9936         All #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8991 0.9960 0.9353 0.9936 #> 2 0.8991 0.9960 0.9353 0.9936  # Calculate the operating characteristics for #   non-informative array testing with master pooling. Se <- matrix(data = rep(0.95, 6), nrow = 2, ncol = 3,              dimnames = list(Infection = 1:2, Stage = 1:3)) Sp <- matrix(data = rep(0.99, 6), nrow = 2, ncol = 3,              dimnames = list(Infection = 1:2, Stage = 1:3)) opChar2(algorithm = \"A2M\", p.vec = c(0.90, 0.04, 0.04, 0.02),          Se = Se, Sp = Sp, rowcol.sz = 10) #>  #>  Number of minutes running:  0  #>   #>  #> Algorithm: Non-informative array testing with master pooling  #>  #> Testing configuration:  #>   Array.dim Array.sz #> 1        10      100 #>  #> Expected number of tests: 56.2898 #> Expected number of tests per individual: 0.5629 #>  #> Disease 1 accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.8937 0.9968 0.9475 0.9932         All #>  #> Disease 2 accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.8937 0.9968 0.9475 0.9932         All #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8937 0.9968 0.9475 0.9932 #> 2 0.8937 0.9968 0.9475 0.9932"},{"path":"https://bdhitt.github.io/binGroup2/reference/plot.OTC.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for optimal testing configuration results — plot.OTC","title":"Plot method for optimal testing configuration results — plot.OTC","text":"Produce plot objects class \"OTC\" returned OTC1 OTC2.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/plot.OTC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for optimal testing configuration results — plot.OTC","text":"","code":"# S3 method for class 'OTC' plot(x, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/plot.OTC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for optimal testing configuration results — plot.OTC","text":"x object class \"OTC\", providing operating characteristics optimal testing configuration similar configurations group testing algorithm. ... currently used.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/plot.OTC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for optimal testing configuration results — plot.OTC","text":"plot expected number tests per individual similar configurations provided object.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/plot.OTC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot method for optimal testing configuration results — plot.OTC","text":"function produces plot objects class \"OTC\" returned OTC1 OTC2. plots expected number tests per individual similar testing configuration object. addition OTC, OTC1 OTC2 functions provide operating characteristics configurations corresponding initial group size provided user. algorithms one configuration initial group size (non-informative two-stage hierarchical array testing algorithms), results initial group size plotted. algorithms one possible configuration initial group size (informative two-stage hierarchical three-stage hierarchical algorithms), results corresponding best configuration initial group size plotted. single value provided group.sz argument OTC1 OTC2 functions, plot produced. plot produced using ggplot2 package. Customization features ggplot2 available package loaded. Examples shown 'Examples' section.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/plot.OTC.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot method for optimal testing configuration results — plot.OTC","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/plot.OTC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot method for optimal testing configuration results — plot.OTC","text":"","code":"# Find the optimal testing configuration for #   non-informative two-stage hierarchical testing. res1 <- OTC1(algorithm = \"D2\", p = 0.01, Se = 0.99, Sp = 0.99,              group.sz = 3:100, obj.fn = c(\"ET\", \"MAR\", \"GR1\"),              weights = matrix(data = c(1, 1), nrow = 1, ncol = 2)) #> Initial Group Size = 3 #> Initial Group Size = 4 #> Initial Group Size = 5 #> Initial Group Size = 6 #> Initial Group Size = 7 #> Initial Group Size = 8 #> Initial Group Size = 9 #> Initial Group Size = 10 #> Initial Group Size = 11 #> Initial Group Size = 12 #> Initial Group Size = 13 #> Initial Group Size = 14 #> Initial Group Size = 15 #> Initial Group Size = 16 #> Initial Group Size = 17 #> Initial Group Size = 18 #> Initial Group Size = 19 #> Initial Group Size = 20 #> Initial Group Size = 21 #> Initial Group Size = 22 #> Initial Group Size = 23 #> Initial Group Size = 24 #> Initial Group Size = 25 #> Initial Group Size = 26 #> Initial Group Size = 27 #> Initial Group Size = 28 #> Initial Group Size = 29 #> Initial Group Size = 30 #> Initial Group Size = 31 #> Initial Group Size = 32 #> Initial Group Size = 33 #> Initial Group Size = 34 #> Initial Group Size = 35 #> Initial Group Size = 36 #> Initial Group Size = 37 #> Initial Group Size = 38 #> Initial Group Size = 39 #> Initial Group Size = 40 #> Initial Group Size = 41 #> Initial Group Size = 42 #> Initial Group Size = 43 #> Initial Group Size = 44 #> Initial Group Size = 45 #> Initial Group Size = 46 #> Initial Group Size = 47 #> Initial Group Size = 48 #> Initial Group Size = 49 #> Initial Group Size = 50 #> Initial Group Size = 51 #> Initial Group Size = 52 #> Initial Group Size = 53 #> Initial Group Size = 54 #> Initial Group Size = 55 #> Initial Group Size = 56 #> Initial Group Size = 57 #> Initial Group Size = 58 #> Initial Group Size = 59 #> Initial Group Size = 60 #> Initial Group Size = 61 #> Initial Group Size = 62 #> Initial Group Size = 63 #> Initial Group Size = 64 #> Initial Group Size = 65 #> Initial Group Size = 66 #> Initial Group Size = 67 #> Initial Group Size = 68 #> Initial Group Size = 69 #> Initial Group Size = 70 #> Initial Group Size = 71 #> Initial Group Size = 72 #> Initial Group Size = 73 #> Initial Group Size = 74 #> Initial Group Size = 75 #> Initial Group Size = 76 #> Initial Group Size = 77 #> Initial Group Size = 78 #> Initial Group Size = 79 #> Initial Group Size = 80 #> Initial Group Size = 81 #> Initial Group Size = 82 #> Initial Group Size = 83 #> Initial Group Size = 84 #> Initial Group Size = 85 #> Initial Group Size = 86 #> Initial Group Size = 87 #> Initial Group Size = 88 #> Initial Group Size = 89 #> Initial Group Size = 90 #> Initial Group Size = 91 #> Initial Group Size = 92 #> Initial Group Size = 93 #> Initial Group Size = 94 #> Initial Group Size = 95 #> Initial Group Size = 96 #> Initial Group Size = 97 #> Initial Group Size = 98 #> Initial Group Size = 99 #> Initial Group Size = 100 #>  #>  Number of minutes running:  0  #>   plot(res1)   # Customize the plot using the ggplot2 package. library(ggplot2) plot(res1) + ylim(0,1) +   ggtitle(\"Similar configurations for Dorfman testing\") +   theme(plot.title = element_text(hjust = 0.5))   # Find the optimal testing configuration for #   informative three-stage hierarchical testing res2 <- OTC1(algorithm = \"ID3\", p = 0.025,              Se = c(0.95, 0.95, 0.99), Sp = c(0.96, 0.96, 0.98),              group.sz = 3:15, obj.fn = \"ET\", alpha = 2) #> Initial Group Size = 3 #> Initial Group Size = 4 #> Initial Group Size = 5 #> Initial Group Size = 6 #> Initial Group Size = 7 #> Initial Group Size = 8 #> Initial Group Size = 9 #> Initial Group Size = 10 #> Initial Group Size = 11 #> Initial Group Size = 12 #> Initial Group Size = 13 #> Initial Group Size = 14 #> Initial Group Size = 15 #>  #>  Number of minutes running:  0.01  #>   plot(res2)   # Find the optimal testing configuration for #   informative array testing without master pooling. res3 <- OTC1(algorithm = \"IA2\", p = 0.09, alpha = 2,              Se = 0.90, Sp = 0.90, group.sz = 3:20, obj.fn = \"ET\") #> Row/Column Size = 3, Array Size = 9 #> Row/Column Size = 4, Array Size = 16 #> Row/Column Size = 5, Array Size = 25 #> Row/Column Size = 6, Array Size = 36 #> Row/Column Size = 7, Array Size = 49 #> Row/Column Size = 8, Array Size = 64 #> Row/Column Size = 9, Array Size = 81 #> Row/Column Size = 10, Array Size = 100 #> Row/Column Size = 11, Array Size = 121 #> Row/Column Size = 12, Array Size = 144 #> Row/Column Size = 13, Array Size = 169 #> Using simulation #> Row/Column Size = 14, Array Size = 196 #> Using simulation #> Row/Column Size = 15, Array Size = 225 #> Using simulation #> Row/Column Size = 16, Array Size = 256 #> Using simulation #> Row/Column Size = 17, Array Size = 289 #> Using simulation #> Row/Column Size = 18, Array Size = 324 #> Using simulation #> Row/Column Size = 19, Array Size = 361 #> Using simulation #> Row/Column Size = 20, Array Size = 400 #>  #>  Number of minutes running:  0.35  #>   plot(res3)   # Find the optimal testing configuration for #   informative two-stage hierarchical testing. Se <- matrix(data = c(rep(0.95, 2), rep(0.99, 2)),              nrow = 2, ncol = 2, byrow = FALSE) Sp <- matrix(data = c(rep(0.96, 2), rep(0.98, 2)),              nrow = 2, ncol = 2, byrow = FALSE) res4 <- OTC2(algorithm = \"ID2\", alpha = c(18.25, 0.75, 0.75, 0.25),                 Se = Se, Sp = Sp, group.sz = 12:20) #> Block Size = 12 #> Block Size = 13 #> Block Size = 14 #> Block Size = 15 #> Block Size = 16 #> Block Size = 17 #> Block Size = 18 #> Block Size = 19 #> Block Size = 20 #>  #>  Number of minutes running:  0.29  #>   plot(res4)    # Find the optimal testing configuration for #   non-informative array testing with master pooling. res5 <- OTC2(algorithm = \"A2M\", p.vec = c(0.90, 0.04, 0.04, 0.02),              Se = rep(0.99, 2), Sp = rep(0.99, 2), group.sz = 3:20) #> Row/Column Size = 3, Array Size = 9 #> Row/Column Size = 4, Array Size = 16 #> Row/Column Size = 5, Array Size = 25 #> Row/Column Size = 6, Array Size = 36 #> Row/Column Size = 7, Array Size = 49 #> Row/Column Size = 8, Array Size = 64 #> Row/Column Size = 9, Array Size = 81 #> Row/Column Size = 10, Array Size = 100 #> Row/Column Size = 11, Array Size = 121 #> Row/Column Size = 12, Array Size = 144 #> Row/Column Size = 13, Array Size = 169 #> Row/Column Size = 14, Array Size = 196 #> Row/Column Size = 15, Array Size = 225 #> Row/Column Size = 16, Array Size = 256 #> Row/Column Size = 17, Array Size = 289 #> Row/Column Size = 18, Array Size = 324 #> Row/Column Size = 19, Array Size = 361 #> Row/Column Size = 20, Array Size = 400 #>  #>  Number of minutes running:  0.05  #>   plot(res5)"},{"path":"https://bdhitt.github.io/binGroup2/reference/pmf.Sterrett.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract probability mass function (PMF) from group testing results — pmf.Sterrett","title":"Extract probability mass function (PMF) from group testing results — pmf.Sterrett","text":"Extract probability mass function group testing results Sterrett algorithm (objects class \"Sterrett\" returned Sterrett).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/pmf.Sterrett.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract probability mass function (PMF) from group testing results — pmf.Sterrett","text":"","code":"# S3 method for class 'Sterrett' pmf(object, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/pmf.Sterrett.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract probability mass function (PMF) from group testing results — pmf.Sterrett","text":"object object class \"Sterrett\", created Sterrett, PMF extracted. ... currently used.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/pmf.Sterrett.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract probability mass function (PMF) from group testing results — pmf.Sterrett","text":"Data frame containing probability mass function extracted object object.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/pmf.Sterrett.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract probability mass function (PMF) from group testing results — pmf.Sterrett","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/pmf.Sterrett.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract probability mass function (PMF) from group testing results — pmf.Sterrett","text":"","code":"set.seed(1231) p.vec <- rbeta(n = 8, shape1 = 1, shape2 = 10) res <- Sterrett(p = p.vec, Sp = 0.90, Se = 0.95) pmf(res) #>    tests one.stage.IS.PMF two.stage.IS.PMF  full.IS.PMF Dorfman.PMF #> 1      1       0.48835471       0.48835471 4.883547e-01   0.4883547 #> 2      3       0.09599437       0.09599437 9.599437e-02          NA #> 3      4       0.07394624       0.07394624 7.394624e-02          NA #> 4      5       0.04488706       0.06729731 6.729731e-02          NA #> 5      6       0.03972361       0.06516755 6.516755e-02          NA #> 6      7       0.02005756       0.05073281 5.444685e-02          NA #> 7      8       0.01199658       0.03078615 3.887818e-02          NA #> 8      9       0.04084418       0.05308898 6.080128e-02   0.5116453 #> 9     10       0.18419568       0.03045444 3.711694e-02          NA #> 10    11               NA       0.04417744 1.426534e-02          NA #> 11    12               NA               NA 3.262503e-03          NA #> 12    13               NA               NA 4.362291e-04          NA #> 13    14               NA               NA 3.151575e-05          NA #> 14    15               NA               NA 9.742431e-07          NA"},{"path":"https://bdhitt.github.io/binGroup2/reference/pmf.halving.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract probability mass function (PMF) from group testing results — pmf.halving","title":"Extract probability mass function (PMF) from group testing results — pmf.halving","text":"Extract probability mass function group testing results halving algorithm (objects class \"halving\" returned halving).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/pmf.halving.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract probability mass function (PMF) from group testing results — pmf.halving","text":"","code":"# S3 method for class 'halving' pmf(object, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/pmf.halving.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract probability mass function (PMF) from group testing results — pmf.halving","text":"object object class \"halving\", created halving, PMF extracted. ... currently used.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/pmf.halving.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract probability mass function (PMF) from group testing results — pmf.halving","text":"Data frame containing probability mass function extracted object object.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/pmf.halving.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract probability mass function (PMF) from group testing results — pmf.halving","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/pmf.halving.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract probability mass function (PMF) from group testing results — pmf.halving","text":"","code":"res <- halving(p = rep(0.01, 10), Sp = 1, Se = 1,                stages = 2, order.p = TRUE) pmf(res) #>   num.tests prob.tests #> 1         1     0.9044 #> 2        11     0.0956"},{"path":"https://bdhitt.github.io/binGroup2/reference/pmf.html","id":null,"dir":"Reference","previous_headings":"","what":"Access the testing probability mass function returned from an object — pmf","title":"Access the testing probability mass function returned from an object — pmf","text":"pmf generic function extracts probability   mass function object (available) contains information   aboout testing configuration.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/pmf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access the testing probability mass function returned from an object — pmf","text":"","code":"pmf(object, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/pmf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access the testing probability mass function returned from an object — pmf","text":"object object probability mass function extracted. ... Additional arguments passed pmf.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/pmf.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Access the testing probability mass function returned from an object — pmf","text":"Christopher R. Bilder","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/pmf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Access the testing probability mass function returned from an object — pmf","text":"","code":"res <- halving(p = rep(0.01, 10), Sp = 1, Se = 1,                stages = 2, order.p = TRUE) pmf.halving(res) #>   num.tests prob.tests #> 1         1     0.9044 #> 2        11     0.0956"},{"path":"https://bdhitt.github.io/binGroup2/reference/predict.gtReg.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict method for gtReg — predict.gtReg","title":"Predict method for gtReg — predict.gtReg","text":"Obtains predictions individual observations optionally computes standard errors predictions objects class \"gtReg\" returned gtReg.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/predict.gtReg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict method for gtReg — predict.gtReg","text":"","code":"# S3 method for class 'gtReg' predict(   object,   newdata,   type = c(\"link\", \"response\"),   se.fit = FALSE,   conf.level = NULL,   na.action = na.pass,   ... )"},{"path":"https://bdhitt.github.io/binGroup2/reference/predict.gtReg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict method for gtReg — predict.gtReg","text":"object fitted object class \"gtReg\". newdata optional data frame look variables predict. omitted, fitted linear predictors used. type type prediction required. \"link\" option scale linear predictors. \"response\" option scale response variable. Thus, logit model, \"link\" predictions log-odds (probabilities logit scale)  type = \"response\" gives predicted probabilities. se.fit logical value indicating whether standard errors required. conf.level confidence level interval predicted values. na.action function determining done missing values newdata. default predict NA. ... currently used.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/predict.gtReg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict method for gtReg — predict.gtReg","text":"se = FALSE, vector matrix predictions. se = TRUE, list containing: fit predictions. se.fit estimated standard errors. lower lower bound confidence interval, calculated (.e., conf.level specified). upper upper bound confidence interval, calculated (.e., conf.level specified).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/predict.gtReg.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict method for gtReg — predict.gtReg","text":"newdata omitted, predictions based data used fit. newdata present contains missing values, missing values dealt determined na.action argument. case, na.action = na.omit, omitted cases appear, whereas na.action = na.exclude, omitted cases appear (predictions standard errors) value NA.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/predict.gtReg.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Predict method for gtReg — predict.gtReg","text":"Boan Zhang","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/predict.gtReg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict method for gtReg — predict.gtReg","text":"","code":"data(hivsurv) fit1 <- gtReg(formula = groupres ~ AGE + EDUC.,               data = hivsurv, groupn = gnum,               sens = 0.9, spec = 0.9,               linkf = \"logit\", method = \"V\") pred.data <- data.frame(AGE = c(15, 25, 30),                         EDUC. = c(1, 3, 2)) predict(object = fit1, newdata = pred.data,         type = \"link\", se.fit = TRUE) #>      fit se.fit #> 1 -3.145 0.8906 #> 2 -2.058 0.3168 #> 3 -3.171 0.7505 predict(object = fit1, newdata = pred.data,         type = \"response\", se.fit = TRUE,         conf.level = 0.9) #>       fit  se.fit    lower  upper #> 1 0.04130 0.03527 0.009858 0.1571 #> 2 0.11320 0.03181 0.070500 0.1770 #> 3 0.04027 0.02901 0.012060 0.1260 predict(object = fit1, type = \"response\",         se.fit = TRUE, conf.level = 0.9) #>          fit  se.fit     lower  upper #> 1   0.268600 0.15980 0.0878300 0.5834 #> 2   0.085220 0.04699 0.0334100 0.2007 #> 3   0.037020 0.03001 0.0095340 0.1331 #> 4   0.080890 0.04066 0.0345600 0.1779 #> 5   0.035040 0.02798 0.0092260 0.1241 #> 6   0.069050 0.02718 0.0356800 0.1295 #> 7   0.050060 0.02446 0.0221200 0.1094 #> 8   0.030590 0.03260 0.0051470 0.1614 #> 9   0.080890 0.04066 0.0345600 0.1779 #> 10  0.076750 0.03521 0.0354100 0.1584 #> 11  0.125200 0.03527 0.0777200 0.1955 #> 12  0.113200 0.03181 0.0705000 0.1770 #> 13  0.113200 0.03181 0.0705000 0.1770 #> 14  0.052840 0.02348 0.0251400 0.1077 #> 15  0.107600 0.03283 0.0643400 0.1747 #> 16  0.097180 0.03783 0.0503000 0.1795 #> 17  0.092300 0.04092 0.0435500 0.1851 #> 18  0.013600 0.01954 0.0012530 0.1315 #> 19  0.030590 0.03260 0.0051470 0.1614 #> 20  0.012150 0.01906 0.0009019 0.1436 #> 21  0.060560 0.05953 0.0114000 0.2650 #> 22  0.031390 0.02493 0.0083390 0.1110 #> 23  0.145200 0.05540 0.0753300 0.2614 #> 24  0.131600 0.04015 0.0783400 0.2126 #> 25  0.131600 0.04015 0.0783400 0.2126 #> 26  0.131600 0.04015 0.0783400 0.2126 #> 27  0.119100 0.03250 0.0751200 0.1837 #> 28  0.113200 0.03181 0.0705000 0.1770 #> 29  0.052840 0.02348 0.0251400 0.1077 #> 30  0.268600 0.15980 0.0878300 0.5834 #> 31  0.131600 0.04015 0.0783400 0.2126 #> 32  0.125200 0.03527 0.0777200 0.1955 #> 33  0.050060 0.02446 0.0221200 0.1094 #> 34  0.085220 0.04699 0.0334100 0.2007 #> 35  0.085220 0.04699 0.0334100 0.2007 #> 36  0.076750 0.03521 0.0354100 0.1584 #> 37  0.035040 0.02798 0.0092260 0.1241 #> 38  0.062080 0.02322 0.0332100 0.1131 #> 39  0.023790 0.02146 0.0053020 0.1003 #> 40  0.102300 0.03501 0.0573800 0.1758 #> 41  0.092300 0.04092 0.0435500 0.1851 #> 42  0.042530 0.02793 0.0141700 0.1207 #> 43  0.019610 0.03257 0.0012320 0.2450 #> 44  0.041300 0.03527 0.0098580 0.1571 #> 45  0.175800 0.10200 0.0627600 0.4045 #> 46  0.080890 0.04066 0.0345600 0.1779 #> 47  0.035040 0.02798 0.0092260 0.1241 #> 48  0.031390 0.02493 0.0083390 0.1110 #> 49  0.145200 0.05540 0.0753300 0.2614 #> 50  0.065480 0.02470 0.0348200 0.1198 #> 51  0.062080 0.02322 0.0332100 0.1131 #> 52  0.125200 0.03527 0.0777200 0.1955 #> 53  0.055770 0.02281 0.0281500 0.1075 #> 54  0.023790 0.02146 0.0053020 0.1003 #> 55  0.080890 0.04066 0.0345600 0.1779 #> 56  0.159900 0.07639 0.0694800 0.3266 #> 57  0.031390 0.02493 0.0083390 0.1110 #> 58  0.031390 0.02493 0.0083390 0.1110 #> 59  0.062080 0.02322 0.0332100 0.1131 #> 60  0.062080 0.02322 0.0332100 0.1131 #> 61  0.018000 0.02044 0.0027280 0.1094 #> 62  0.016090 0.02012 0.0020180 0.1169 #> 63  0.076750 0.03521 0.0354100 0.1584 #> 64  0.031390 0.02493 0.0083390 0.1110 #> 65  0.069050 0.02718 0.0356800 0.1295 #> 66  0.058840 0.02265 0.0309200 0.1091 #> 67  0.023790 0.02146 0.0053020 0.1003 #> 68  0.018000 0.02044 0.0027280 0.1094 #> 69  0.159900 0.07639 0.0694800 0.3266 #> 70  0.065480 0.02470 0.0348200 0.1198 #> 71  0.065480 0.02470 0.0348200 0.1198 #> 72  0.119100 0.03250 0.0751200 0.1837 #> 73  0.023790 0.02146 0.0053020 0.1003 #> 74  0.138200 0.04695 0.0773800 0.2347 #> 75  0.131600 0.04015 0.0783400 0.2126 #> 76  0.058840 0.02265 0.0309200 0.1091 #> 77  0.113200 0.03181 0.0705000 0.1770 #> 78  0.107600 0.03283 0.0643400 0.1747 #> 79  0.047420 0.02560 0.0192200 0.1122 #> 80  0.092300 0.04092 0.0435500 0.1851 #> 81  0.060560 0.05953 0.0114000 0.2650 #> 82  0.054390 0.06151 0.0079810 0.2914 #> 83  0.072810 0.03070 0.0358300 0.1423 #> 84  0.125200 0.03527 0.0777200 0.1955 #> 85  0.119100 0.03250 0.0751200 0.1837 #> 86  0.047420 0.02560 0.0192200 0.1122 #> 87  0.080890 0.04066 0.0345600 0.1779 #> 88  0.078940 0.04980 0.0270300 0.2091 #> 89  0.039110 0.03243 0.0097440 0.1441 #> 90  0.080890 0.04066 0.0345600 0.1779 #> 91  0.076750 0.03521 0.0354100 0.1584 #> 92  0.072810 0.03070 0.0358300 0.1423 #> 93  0.069050 0.02718 0.0356800 0.1295 #> 94  0.058840 0.02265 0.0309200 0.1091 #> 95  0.058840 0.02265 0.0309200 0.1091 #> 96  0.055770 0.02281 0.0281500 0.1075 #> 97  0.107600 0.03283 0.0643400 0.1747 #> 98  0.102300 0.03501 0.0573800 0.1758 #> 99  0.044910 0.02678 0.0165600 0.1161 #> 100 0.044910 0.02678 0.0165600 0.1161 #> 101 0.087630 0.04404 0.0373700 0.1920 #> 102 0.063880 0.05816 0.0135900 0.2525 #> 103 0.037020 0.03001 0.0095340 0.1331 #> 104 0.069050 0.02718 0.0356800 0.1295 #> 105 0.131600 0.04015 0.0783400 0.2126 #> 106 0.023790 0.02146 0.0053020 0.1003 #> 107 0.113200 0.03181 0.0705000 0.1770 #> 108 0.050060 0.02446 0.0221200 0.1094 #> 109 0.097180 0.03783 0.0503000 0.1795 #> 110 0.040270 0.02901 0.0120600 0.1260 #> 111 0.013600 0.01954 0.0012530 0.1315 #> 112 0.010260 0.01820 0.0005438 0.1650 #> 113 0.069050 0.02718 0.0356800 0.1295 #> 114 0.268600 0.15980 0.0878300 0.5834 #> 115 0.052840 0.02348 0.0251400 0.1077 #> 116 0.102300 0.03501 0.0573800 0.1758 #> 117 0.097180 0.03783 0.0503000 0.1795 #> 118 0.089770 0.05418 0.0320700 0.2269 #> 119 0.119100 0.03250 0.0751200 0.1837 #> 120 0.052840 0.02348 0.0251400 0.1077 #> 121 0.016090 0.02012 0.0020180 0.1169 #> 122 0.167700 0.08868 0.0661500 0.3642 #> 123 0.033170 0.02630 0.0088240 0.1168 #> 124 0.152400 0.06527 0.0726000 0.2922 #> 125 0.069050 0.02718 0.0356800 0.1295 #> 126 0.055770 0.02281 0.0281500 0.1075 #> 127 0.236300 0.13000 0.0864800 0.5029 #> 128 0.107600 0.03283 0.0643400 0.1747 #> 129 0.107600 0.03283 0.0643400 0.1747 #> 130 0.050060 0.02446 0.0221200 0.1094 #> 131 0.087630 0.04404 0.0373700 0.1920 #> 132 0.089770 0.05418 0.0320700 0.2269 #> 133 0.085220 0.04699 0.0334100 0.2007 #> 134 0.076750 0.03521 0.0354100 0.1584 #> 135 0.069050 0.02718 0.0356800 0.1295 #> 136 0.055770 0.02281 0.0281500 0.1075 #> 137 0.113200 0.03181 0.0705000 0.1770 #> 138 0.022500 0.02117 0.0047040 0.1008 #> 139 0.047420 0.02560 0.0192200 0.1122 #> 140 0.018000 0.02044 0.0027280 0.1094 #> 141 0.010860 0.01850 0.0006446 0.1574 #> 142 0.145200 0.05540 0.0753300 0.2614 #> 143 0.019030 0.02060 0.0031520 0.1064 #> 144 0.018000 0.02044 0.0027280 0.1094 #> 145 0.069050 0.02718 0.0356800 0.1295 #> 146 0.145200 0.05540 0.0753300 0.2614 #> 147 0.125200 0.03527 0.0777200 0.1955 #> 148 0.058840 0.02265 0.0309200 0.1091 #> 149 0.246800 0.13840 0.0878200 0.5272 #> 150 0.119100 0.03250 0.0751200 0.1837 #> 151 0.216400 0.11790 0.0808800 0.4643 #> 152 0.230900 0.20270 0.0438800 0.6625 #> 153 0.080890 0.04066 0.0345600 0.1779 #> 154 0.031390 0.02493 0.0083390 0.1110 #> 155 0.062080 0.02322 0.0332100 0.1131 #> 156 0.058840 0.02265 0.0309200 0.1091 #> 157 0.119100 0.03250 0.0751200 0.1837 #> 158 0.113200 0.03181 0.0705000 0.1770 #> 159 0.113200 0.03181 0.0705000 0.1770 #> 160 0.092300 0.04092 0.0435500 0.1851 #> 161 0.092300 0.04092 0.0435500 0.1851 #> 162 0.083180 0.04703 0.0318600 0.2001 #> 163 0.016090 0.02012 0.0020180 0.1169 #> 164 0.074900 0.05232 0.0228500 0.2190 #> 165 0.074900 0.05232 0.0228500 0.2190 #> 166 0.067370 0.05650 0.0161900 0.2407 #> 167 0.039110 0.03243 0.0097440 0.1441 #> 168 0.076750 0.03521 0.0354100 0.1584 #> 169 0.031390 0.02493 0.0083390 0.1110 #> 170 0.062080 0.02322 0.0332100 0.1131 #> 171 0.107600 0.03283 0.0643400 0.1747 #> 172 0.044910 0.02678 0.0165600 0.1161 #> 173 0.020130 0.02076 0.0036240 0.1040 #> 174 0.020130 0.02076 0.0036240 0.1040 #> 175 0.092300 0.04092 0.0435500 0.1851 #> 176 0.172000 0.11090 0.0545400 0.4279 #> 177 0.172000 0.11090 0.0545400 0.4279 #> 178 0.085220 0.04699 0.0334100 0.2007 #> 179 0.257500 0.14840 0.0882300 0.5542 #> 180 0.119100 0.03250 0.0751200 0.1837 #> 181 0.107600 0.03283 0.0643400 0.1747 #> 182 0.047420 0.02560 0.0192200 0.1122 #> 183 0.206900 0.11410 0.0767100 0.4503 #> 184 0.047420 0.02560 0.0192200 0.1122 #> 185 0.197700 0.11180 0.0717800 0.4398 #> 186 0.013600 0.01954 0.0012530 0.1315 #> 187 0.039110 0.03243 0.0097440 0.1441 #> 188 0.028100 0.02300 0.0071860 0.1035 #> 189 0.125200 0.03527 0.0777200 0.1955 #> 190 0.020130 0.02076 0.0036240 0.1040 #> 191 0.076750 0.03521 0.0354100 0.1584 #> 192 0.031390 0.02493 0.0083390 0.1110 #> 193 0.069050 0.02718 0.0356800 0.1295 #> 194 0.138200 0.04695 0.0773800 0.2347 #> 195 0.138200 0.04695 0.0773800 0.2347 #> 196 0.062080 0.02322 0.0332100 0.1131 #> 197 0.055770 0.02281 0.0281500 0.1075 #> 198 0.050060 0.02446 0.0221200 0.1094 #> 199 0.047420 0.02560 0.0192200 0.1122 #> 200 0.021280 0.02095 0.0041420 0.1021 #> 201 0.102300 0.03501 0.0573800 0.1758 #> 202 0.097180 0.03783 0.0503000 0.1795 #> 203 0.040270 0.02901 0.0120600 0.1260 #> 204 0.038120 0.02998 0.0102300 0.1320 #> 205 0.078940 0.04980 0.0270300 0.2091 #> 206 0.025910 0.03330 0.0030270 0.1890 #> 207 0.072810 0.03070 0.0358300 0.1423 #> 208 0.138200 0.04695 0.0773800 0.2347 #> 209 0.026590 0.02234 0.0065590 0.1015 #> 210 0.052840 0.02348 0.0251400 0.1077 #> 211 0.023790 0.02146 0.0053020 0.1003 #> 212 0.044910 0.02678 0.0165600 0.1161 #> 213 0.087630 0.04404 0.0373700 0.1920 #> 214 0.035040 0.02798 0.0092260 0.1241 #> 215 0.076750 0.03521 0.0354100 0.1584 #> 216 0.031390 0.02493 0.0083390 0.1110 #> 217 0.018000 0.02044 0.0027280 0.1094 #> 218 0.069050 0.02718 0.0356800 0.1295 #> 219 0.138200 0.04695 0.0773800 0.2347 #> 220 0.044910 0.02678 0.0165600 0.1161 #> 221 0.152400 0.06527 0.0726000 0.2922 #> 222 0.050060 0.02446 0.0221200 0.1094 #> 223 0.072810 0.03070 0.0358300 0.1423 #> 224 0.069050 0.02718 0.0356800 0.1295 #> 225 0.069050 0.02718 0.0356800 0.1295 #> 226 0.031390 0.02493 0.0083390 0.1110 #> 227 0.065480 0.02470 0.0348200 0.1198 #> 228 0.257500 0.14840 0.0882300 0.5542 #> 229 0.018000 0.02044 0.0027280 0.1094 #> 230 0.040270 0.02901 0.0120600 0.1260 #> 231 0.028950 0.03295 0.0043170 0.1701 #> 232 0.028950 0.03295 0.0043170 0.1701 #> 233 0.011490 0.01879 0.0007630 0.1503 #> 234 0.085220 0.04699 0.0334100 0.2007 #> 235 0.085220 0.04699 0.0334100 0.2007 #> 236 0.028100 0.02300 0.0071860 0.1035 #> 237 0.216400 0.11790 0.0808800 0.4643 #> 238 0.206900 0.11410 0.0767100 0.4503 #> 239 0.016090 0.02012 0.0020180 0.1169 #> 240 0.078940 0.04980 0.0270300 0.2091 #> 241 0.074900 0.05232 0.0228500 0.2190 #> 242 0.080890 0.04066 0.0345600 0.1779 #> 243 0.080890 0.04066 0.0345600 0.1779 #> 244 0.131600 0.04015 0.0783400 0.2126 #> 245 0.062080 0.02322 0.0332100 0.1131 #> 246 0.083180 0.04703 0.0318600 0.2001 #> 247 0.055770 0.02281 0.0281500 0.1075 #> 248 0.036090 0.03082 0.0086410 0.1385 #> 249 0.072810 0.03070 0.0358300 0.1423 #> 250 0.069050 0.02718 0.0356800 0.1295 #> 251 0.138200 0.04695 0.0773800 0.2347 #> 252 0.065480 0.02470 0.0348200 0.1198 #> 253 0.246800 0.13840 0.0878200 0.5272 #> 254 0.055770 0.02281 0.0281500 0.1075 #> 255 0.074900 0.05232 0.0228500 0.2190 #> 256 0.279900 0.17270 0.0867200 0.6141 #> 257 0.145200 0.05540 0.0753300 0.2614 #> 258 0.065480 0.02470 0.0348200 0.1198 #> 259 0.028100 0.02300 0.0071860 0.1035 #> 260 0.062080 0.02322 0.0332100 0.1131 #> 261 0.131600 0.04015 0.0783400 0.2126 #> 262 0.236300 0.13000 0.0864800 0.5029 #> 263 0.020130 0.02076 0.0036240 0.1040 #> 264 0.019030 0.02060 0.0031520 0.1064 #> 265 0.018000 0.02044 0.0027280 0.1094 #> 266 0.076750 0.03521 0.0354100 0.1584 #> 267 0.031390 0.02493 0.0083390 0.1110 #> 268 0.119100 0.03250 0.0751200 0.1837 #> 269 0.052840 0.02348 0.0251400 0.1077 #> 270 0.062080 0.02322 0.0332100 0.1131 #> 271 0.050060 0.02446 0.0221200 0.1094 #> 272 0.036090 0.03082 0.0086410 0.1385 #> 273 0.072810 0.03070 0.0358300 0.1423 #> 274 0.119100 0.03250 0.0751200 0.1837 #> 275 0.078940 0.04980 0.0270300 0.2091 #> 276 0.145200 0.05540 0.0753300 0.2614 #> 277 0.031390 0.02493 0.0083390 0.1110 #> 278 0.028100 0.02300 0.0071860 0.1035 #> 279 0.055770 0.02281 0.0281500 0.1075 #> 280 0.015210 0.01995 0.0017260 0.1213 #> 281 0.012850 0.01931 0.0010640 0.1373 #> 282 0.008664 0.01719 0.0003245 0.1905 #> 283 0.069050 0.02718 0.0356800 0.1295 #> 284 0.014380 0.01976 0.0014730 0.1262 #> 285 0.138200 0.04695 0.0773800 0.2347 #> 286 0.131600 0.04015 0.0783400 0.2126 #> 287 0.125200 0.03527 0.0777200 0.1955 #> 288 0.021280 0.02095 0.0041420 0.1021 #> 289 0.067370 0.05650 0.0161900 0.2407 #> 290 0.023790 0.02146 0.0053020 0.1003 #> 291 0.020130 0.02076 0.0036240 0.1040 #> 292 0.069050 0.02718 0.0356800 0.1295 #> 293 0.062080 0.02322 0.0332100 0.1131 #> 294 0.131600 0.04015 0.0783400 0.2126 #> 295 0.047420 0.02560 0.0192200 0.1122 #> 296 0.102300 0.03501 0.0573800 0.1758 #> 297 0.092300 0.04092 0.0435500 0.1851 #> 298 0.083180 0.04703 0.0318600 0.2001 #> 299 0.033170 0.02630 0.0088240 0.1168 #> 300 0.055770 0.02281 0.0281500 0.1075 #> 301 0.050060 0.02446 0.0221200 0.1094 #> 302 0.036090 0.03082 0.0086410 0.1385 #> 303 0.039110 0.03243 0.0097440 0.1441 #> 304 0.159900 0.07639 0.0694800 0.3266 #> 305 0.033170 0.02630 0.0088240 0.1168 #> 306 0.062080 0.02322 0.0332100 0.1131 #> 307 0.102300 0.03501 0.0573800 0.1758 #> 308 0.044910 0.02678 0.0165600 0.1161 #> 309 0.080890 0.04066 0.0345600 0.1779 #> 310 0.145200 0.05540 0.0753300 0.2614 #> 311 0.029700 0.02385 0.0077860 0.1067 #> 312 0.065480 0.02470 0.0348200 0.1198 #> 313 0.028100 0.02300 0.0071860 0.1035 #> 314 0.026590 0.02234 0.0065590 0.1015 #> 315 0.058840 0.02265 0.0309200 0.1091 #> 316 0.050060 0.02446 0.0221200 0.1094 #> 317 0.197700 0.11180 0.0717800 0.4398 #> 318 0.015210 0.01995 0.0017260 0.1213 #> 319 0.141900 0.11700 0.0329400 0.4453 #> 320 0.069050 0.02718 0.0356800 0.1295 #> 321 0.131600 0.04015 0.0783400 0.2126 #> 322 0.062080 0.02322 0.0332100 0.1131 #> 323 0.055770 0.02281 0.0281500 0.1075 #> 324 0.197700 0.11180 0.0717800 0.4398 #> 325 0.037020 0.03001 0.0095340 0.1331 #> 326 0.159900 0.07639 0.0694800 0.3266 #> 327 0.033170 0.02630 0.0088240 0.1168 #> 328 0.062080 0.02322 0.0332100 0.1131 #> 329 0.062080 0.02322 0.0332100 0.1131 #> 330 0.025150 0.02184 0.0059250 0.1005 #> 331 0.119100 0.03250 0.0751200 0.1837 #> 332 0.022500 0.02117 0.0047040 0.1008 #> 333 0.040270 0.02901 0.0120600 0.1260 #> 334 0.013600 0.01954 0.0012530 0.1315 #> 335 0.037020 0.03001 0.0095340 0.1331 #> 336 0.076750 0.03521 0.0354100 0.1584 #> 337 0.069050 0.02718 0.0356800 0.1295 #> 338 0.131600 0.04015 0.0783400 0.2126 #> 339 0.026590 0.02234 0.0065590 0.1015 #> 340 0.125200 0.03527 0.0777200 0.1955 #> 341 0.246800 0.13840 0.0878200 0.5272 #> 342 0.102300 0.03501 0.0573800 0.1758 #> 343 0.007312 0.01609 0.0001921 0.2202 #> 344 0.085220 0.04699 0.0334100 0.2007 #> 345 0.175800 0.10200 0.0627600 0.4045 #> 346 0.080890 0.04066 0.0345600 0.1779 #> 347 0.035040 0.02798 0.0092260 0.1241 #> 348 0.035040 0.02798 0.0092260 0.1241 #> 349 0.076750 0.03521 0.0354100 0.1584 #> 350 0.031390 0.02493 0.0083390 0.1110 #> 351 0.069050 0.02718 0.0356800 0.1295 #> 352 0.025150 0.02184 0.0059250 0.1005 #> 353 0.025150 0.02184 0.0059250 0.1005 #> 354 0.023790 0.02146 0.0053020 0.1003 #> 355 0.107600 0.03283 0.0643400 0.1747 #> 356 0.020130 0.02076 0.0036240 0.1040 #> 357 0.011490 0.01879 0.0007630 0.1503 #> 358 0.080890 0.04066 0.0345600 0.1779 #> 359 0.076750 0.03521 0.0354100 0.1584 #> 360 0.076750 0.03521 0.0354100 0.1584 #> 361 0.055770 0.02281 0.0281500 0.1075 #> 362 0.159900 0.07639 0.0694800 0.3266 #> 363 0.072810 0.03070 0.0358300 0.1423 #> 364 0.069050 0.02718 0.0356800 0.1295 #> 365 0.065480 0.02470 0.0348200 0.1198 #> 366 0.131600 0.04015 0.0783400 0.2126 #> 367 0.125200 0.03527 0.0777200 0.1955 #> 368 0.058840 0.02265 0.0309200 0.1091 #> 369 0.246800 0.13840 0.0878200 0.5272 #> 370 0.055770 0.02281 0.0281500 0.1075 #> 371 0.055770 0.02281 0.0281500 0.1075 #> 372 0.040270 0.02901 0.0120600 0.1260 #> 373 0.072810 0.03070 0.0358300 0.1423 #> 374 0.052840 0.02348 0.0251400 0.1077 #> 375 0.072810 0.03070 0.0358300 0.1423 #> 376 0.031390 0.02493 0.0083390 0.1110 #> 377 0.069050 0.02718 0.0356800 0.1295 #> 378 0.145200 0.05540 0.0753300 0.2614 #> 379 0.055770 0.02281 0.0281500 0.1075 #> 380 0.119100 0.03250 0.0751200 0.1837 #> 381 0.052840 0.02348 0.0251400 0.1077 #> 382 0.050060 0.02446 0.0221200 0.1094 #> 383 0.107600 0.03283 0.0643400 0.1747 #> 384 0.020130 0.02076 0.0036240 0.1040 #> 385 0.019610 0.03257 0.0012320 0.2450 #> 386 0.076750 0.03521 0.0354100 0.1584 #> 387 0.076750 0.03521 0.0354100 0.1584 #> 388 0.138200 0.04695 0.0773800 0.2347 #> 389 0.029700 0.02385 0.0077860 0.1067 #> 390 0.131600 0.04015 0.0783400 0.2126 #> 391 0.131600 0.04015 0.0783400 0.2126 #> 392 0.058840 0.02265 0.0309200 0.1091 #> 393 0.055770 0.02281 0.0281500 0.1075 #> 394 0.025150 0.02184 0.0059250 0.1005 #> 395 0.119100 0.03250 0.0751200 0.1837 #> 396 0.055770 0.02281 0.0281500 0.1075 #> 397 0.023790 0.02146 0.0053020 0.1003 #> 398 0.052840 0.02348 0.0251400 0.1077 #> 399 0.052840 0.02348 0.0251400 0.1077 #> 400 0.044910 0.02678 0.0165600 0.1161 #> 401 0.042530 0.02793 0.0141700 0.1207 #> 402 0.042530 0.02793 0.0141700 0.1207 #> 403 0.087630 0.04404 0.0373700 0.1920 #> 404 0.040270 0.02901 0.0120600 0.1260 #> 405 0.074900 0.05232 0.0228500 0.2190 #> 406 0.025910 0.03330 0.0030270 0.1890 #> 407 0.080890 0.04066 0.0345600 0.1779 #> 408 0.031390 0.02493 0.0083390 0.1110 #> 409 0.023790 0.02146 0.0053020 0.1003 #> 410 0.069050 0.02718 0.0356800 0.1295 #> 411 0.065480 0.02470 0.0348200 0.1198 #> 412 0.023790 0.02146 0.0053020 0.1003 #> 413 0.052840 0.02348 0.0251400 0.1077 #> 414 0.038120 0.02998 0.0102300 0.1320 #> 415 0.038120 0.02998 0.0102300 0.1320 #> 416 0.036090 0.03082 0.0086410 0.1385 #> 417 0.131600 0.04015 0.0783400 0.2126 #> 418 0.107600 0.03283 0.0643400 0.1747 #> 419 0.044910 0.02678 0.0165600 0.1161 #> 420 0.067370 0.05650 0.0161900 0.2407 #> 421 0.052840 0.02348 0.0251400 0.1077 #> 422 0.092300 0.04092 0.0435500 0.1851 #> 423 0.080890 0.04066 0.0345600 0.1779 #> 424 0.076750 0.03521 0.0354100 0.1584 #> 425 0.076750 0.03521 0.0354100 0.1584 #> 426 0.131600 0.04015 0.0783400 0.2126 #> 427 0.040270 0.02901 0.0120600 0.1260 #> 428 0.071040 0.05455 0.0192600 0.2295"},{"path":"https://bdhitt.github.io/binGroup2/reference/print.OTC.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for optimal testing configuration results — print.OTC","title":"Print method for optimal testing configuration results — print.OTC","text":"Print method objects class \"OTC\" returned OTC1 OTC2.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.OTC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for optimal testing configuration results — print.OTC","text":"","code":"# S3 method for class 'OTC' print(x, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/print.OTC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for optimal testing configuration results — print.OTC","text":"x object class \"OTC\", providing optimal testing configuration results group testing algorithm. ... Additional arguments passed print (e.g., digits passed round appropriate rounding).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.OTC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for optimal testing configuration results — print.OTC","text":"print algorithm, testing configuration, expected number tests, expected number tests per individual, accuracy measures individuals overall algorithm.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.OTC.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print method for optimal testing configuration results — print.OTC","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.Sterrett.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for objects of class ","title":"Print method for objects of class ","text":"Print method objects class \"Sterrett\" created Sterrett function.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.Sterrett.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for objects of class ","text":"","code":"# S3 method for class 'Sterrett' print(x, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/print.Sterrett.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for objects of class ","text":"x object class \"Sterrett\" (Sterrett). ... Additional arguments passed print. Currently digits passed signif appropriate rounding.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.Sterrett.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for objects of class ","text":"print PMF, expected testing expenditure variance testing expenditure resulting Sterrett.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.Sterrett.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print method for objects of class ","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.TOD.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for TOD — print.TOD","title":"Print method for TOD — print.TOD","text":"Print method objects obtained TOD.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.TOD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for TOD — print.TOD","text":"","code":"# S3 method for class 'TOD' print(x, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/print.TOD.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for TOD — print.TOD","text":"x object class \"TOD\" created TOD. ... currently used.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.TOD.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for TOD — print.TOD","text":"print configuration operating characteristics found TOD.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.TOD.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print method for TOD — print.TOD","text":"Chris Bilder","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.designEst.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for objects of class ","title":"Print method for objects of class ","text":"Print method objects class \"designEst\" created designEst.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.designEst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for objects of class ","text":"","code":"# S3 method for class 'designEst' print(x, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/print.designEst.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for objects of class ","text":"x object class \"designEst\" created designEst. ... additional arguments passed print. Currently digits passed signif appropriate rounding.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.designEst.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for objects of class ","text":"print detailing whether bias restriction violated, whether maximum allowed group size reached, minimum MSE associated group size, expected value, variance, bias.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.designEst.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print method for objects of class ","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.designPower.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for objects of class ","title":"Print method for objects of class ","text":"Print method objects class \"designPower\" created designPower.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.designPower.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for objects of class ","text":"","code":"# S3 method for class 'designPower' print(x, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/print.designPower.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for objects of class ","text":"x object class \"designPower\" created designPower. ... additional arguments passed print. Currently digits passed signif appropriate rounding.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.designPower.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for objects of class ","text":"print detailing whether power reached range values (n s) provided, maximal power reached range values, alternative hypothesis, assumed true proportion.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.designPower.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print method for objects of class ","text":"function originally written print.bgtDesign Frank Schaarschmidt binGroup package. Minor modifications made inclusion binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.gtReg.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for gtReg — print.gtReg","title":"Print method for gtReg — print.gtReg","text":"Print method objects obtained gtReg.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.gtReg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for gtReg — print.gtReg","text":"","code":"# S3 method for class 'gtReg' print(x, digits = max(3, getOption(\"digits\") - 3), ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/print.gtReg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for gtReg — print.gtReg","text":"x object class \"gtReg\" created gtReg. digits digits rounding. ... currently used.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.gtReg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for gtReg — print.gtReg","text":"print function call, coefficients, null residual deviance degrees freedom.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.gtReg.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print method for gtReg — print.gtReg","text":"function originally written Boan Zhang print.gt function binGroup package. Minor modifications made inclusion binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.gtTest.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for objects of class ","title":"Print method for objects of class ","text":"Print method objects class \"gtTest\" created gtTest function.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.gtTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for objects of class ","text":"","code":"# S3 method for class 'gtTest' print(x, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/print.gtTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for objects of class ","text":"x object class \"gtTest\" (gtTest). ... Additional arguments passed print. Currently digits passed signif appropriate rounding.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.gtTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for objects of class ","text":"print p-value point estimate resulting gtTest.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.gtTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print method for objects of class ","text":"function originally written print.bgtTest Brad Biggerstaff binGroup package. Minor modifications made inclusion function binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.halving.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for objects of class ","title":"Print method for objects of class ","text":"Print method objects class \"halving\" created halving function.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.halving.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for objects of class ","text":"","code":"# S3 method for class 'halving' print(x, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/print.halving.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for objects of class ","text":"x object class \"halving\" (halving). ... Additional arguments passed print. Currently digits passed signif appropriate rounding.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.halving.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for objects of class ","text":"print PMF, expected testing expenditure variance testing expenditure resulting halving.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.halving.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print method for objects of class ","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.opChar.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for operating characteristics results — print.opChar","title":"Print method for operating characteristics results — print.opChar","text":"Print method objects class \"opChar\" returned operatingCharacteristics1 (opChar1) operatingCharacteristics2 (opChar2).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.opChar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for operating characteristics results — print.opChar","text":"","code":"# S3 method for class 'opChar' print(x, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/print.opChar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for operating characteristics results — print.opChar","text":"x object class \"opChar\", providing calculated operating characteristics group testing algorithm. ... Additional arguments passed print (e.g., digits passed round appropriate rounding).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.opChar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for operating characteristics results — print.opChar","text":"print algorithm, testing configuration, expected number tests, expected number tests per individual, accuracy measures individuals overall algorithm.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.opChar.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print method for operating characteristics results — print.opChar","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.predict.gtReg.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for predict.gtReg — print.predict.gtReg","title":"Print method for predict.gtReg — print.predict.gtReg","text":"Print method objects obtained predict.gtReg.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.predict.gtReg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for predict.gtReg — print.predict.gtReg","text":"","code":"# S3 method for class 'predict.gtReg' print(x, digits = max(3, getOption(\"digits\") - 3), ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/print.predict.gtReg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for predict.gtReg — print.predict.gtReg","text":"x object class \"predict.gtReg\" created predict.gtReg. digits digits rounding. ... currently used.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.predict.gtReg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for predict.gtReg — print.predict.gtReg","text":"matrix predictions rows corresponding observation newdata (provided) observation data set used fit. columns correspond predictions (fit), estimated standard errors (se.fit), lower bound confidence interval (lower), upper bound confidence interval (upper). conf.level specified, lower upper columns included. se = FALSE, se.fit column included.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.predict.gtReg.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print method for predict.gtReg — print.predict.gtReg","text":"Brianna Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.propCI.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for objects of class ","title":"Print method for objects of class ","text":"Print method objects class \"propCI\" created propCI function.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.propCI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for objects of class ","text":"","code":"# S3 method for class 'propCI' print(x, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/print.propCI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for objects of class ","text":"x object class \"propCI\" (propCI). ... Additional arguments passed print.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.propCI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for objects of class ","text":"print point estimate confidence interval found propCI.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.propCI.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print method for objects of class ","text":"function combination print.poolbindiff print.bgt, written Brad Biggerstaff binGroup package. Minor modifications made inclusion function binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.propDiffCI.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for objects of class ","title":"Print method for objects of class ","text":"Print method objects class \"propDiffCI\" created propDiffCI function.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.propDiffCI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for objects of class ","text":"","code":"# S3 method for class 'propDiffCI' print(x, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/print.propDiffCI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for objects of class ","text":"x object class \"propDiffCI\" (propDiffCI). ... Additional arguments passed print.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.propDiffCI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for objects of class ","text":"print point estimate confidence interval found propDiffCI.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.propDiffCI.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print method for objects of class ","text":"function originally written print.poolbindiff Brad Biggerstaff binGroup package. Minor modifications made inclusion function binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.summary.gtReg.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for summary.gtReg — print.summary.gtReg","title":"Print method for summary.gtReg — print.summary.gtReg","text":"Print method objects obtained summary.gtReg.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.summary.gtReg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for summary.gtReg — print.summary.gtReg","text":"","code":"# S3 method for class 'summary.gtReg' print(   x,   digits = max(3, getOption(\"digits\") - 3),   signif.stars = getOption(\"show.signif.stars\"),   ... )"},{"path":"https://bdhitt.github.io/binGroup2/reference/print.summary.gtReg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for summary.gtReg — print.summary.gtReg","text":"x object class \"summary.gtReg\" created summary.gtReg. digits digits rounding. signif.stars logical value indicating whether significance stars shown. ... Additional arguments passed printCoefmat.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.summary.gtReg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for summary.gtReg — print.summary.gtReg","text":"print function call, deviance residuals (simple pooling halving ), coefficients, null residual deviance degrees freedom (simple pooling ), AIC (simple pooling halving ), number Gibbs samples (array testing ), number iterations.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/print.summary.gtReg.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print method for summary.gtReg — print.summary.gtReg","text":"function combines code print.summary.gt print.summary.gt.mp, written Boan Zhang binGroup package. Minor modifications made inclusion binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/propCI.html","id":null,"dir":"Reference","previous_headings":"","what":"Confidence intervals for one proportion in group testing — propCI","title":"Confidence intervals for one proportion in group testing — propCI","text":"Calculates point estimates confidence intervals single proportion group testing data. Methods available groups equal different sizes.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/propCI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Confidence intervals for one proportion in group testing — propCI","text":"","code":"propCI(   x,   m,   n,   pt.method = \"mle\",   ci.method,   conf.level = 0.95,   alternative = \"two.sided\",   maxiter = 100,   tol = .Machine$double.eps^0.5 )"},{"path":"https://bdhitt.github.io/binGroup2/reference/propCI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Confidence intervals for one proportion in group testing — propCI","text":"x integer specifying number positive groups groups equal size, vector specifying number positive groups among n groups tested group sizes differ. latter, vector must length m n arguments. m integer specifying common size groups groups equal size, vector specifying group sizes group sizes differ. latter, vector must length x n arguments. n integer specifying number groups groups equal size, vector specifying corresponding number groups sizes m group sizes differ. latter, vector must length x m arguments. pt.method character string specifying point estimate compute. Options include \"Firth\" bias-preventative, \"Gart\" \"bc-mle\" bias-corrected MLE (latter allows backward compatibility), \"mle\" MLE. ci.method character string specifying confidence interval compute. Options include \"AC\" Agresti-Coull interval, \"bc-skew-score\" bias- skewness-corrected interval, \"Blaker\" Blaker interval, \"CP\" Clopper-Pearson interval, \"exact\" exact interval given Hepworth (1996), \"lrt\" likelihood ratio test interval, \"score\" Wilson score interval, \"skew-score\" skewness-corrected interval, \"soc\" second-order corrected interval, \"Wald\" Wald interval. Note Agresti-Coull, Blaker, Clopper-Pearson, second-order corrected intervals can calculated x, m, n given integers (equal group size case). conf.level confidence level interval. alternative character string defining alternative hypothesis, either \"two.sided\", \"less\", \"greater\". maxiter maximum number steps iteration confidence limits, use \"exact\" method group sizes differ. tol accuracy required iterations internal functions, use asymptotic intervals group sizes differ .","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/propCI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Confidence intervals for one proportion in group testing — propCI","text":"list containing: conf.int confidence interval proportion. estimate point estimator proportion. pt.method method used point estimation. ci.method method used confidence interval estimation. conf.level confidence level interval. alternative alternative specified user. x number positive groups. m group sizes. n numbers groups corresponding group sizes m.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/propCI.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Confidence intervals for one proportion in group testing — propCI","text":"Confidence interval methods include Agresti-Coull (ci.method = \"AC\"), bias- skewness-corrected (ci.method = \"bc-skew-score\"), Blaker (ci.method = \"Blaker\"), Clopper-Pearson (ci.method = \"CP\"), exact (ci.method = \"exact\"), likelihood ratio test (ci.method = \"lrt\"), Wilson score (ci.method = \"score\"), skewness-corrected (ci.method = \"skew-score\"), second-order corrected (ci.method = \"soc\"), Wald (ci.method = \"Wald\") intervals. Agresti-Coull, Blaker, Clopper-Pearson, second-order corrected intervals available equal group size case. Point estimates available include MLE (pt.method = \"mle\"), bias-corrected MLE (pt.method = \"Gart\" pt.method = \"bc-mle\"), bias-preventative (pt.method = \"Firth\"). MLE method available calculating Clopper-Pearson, Blaker, Agresti-Coull, second-order corrected, exact intervals.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/propCI.html","id":"equal-group-sizes","dir":"Reference","previous_headings":"","what":"Equal group sizes","title":"Confidence intervals for one proportion in group testing — propCI","text":"Computation confidence intervals group testing equal group sizes described Tebbs & Bilder (2004) Schaarschmidt (2007).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/propCI.html","id":"unequal-group-sizes","dir":"Reference","previous_headings":"","what":"Unequal group sizes","title":"Confidence intervals for one proportion in group testing — propCI","text":"exact method available group sizes differ, algorithm becomes computationally expensive number different groups, n, becomes larger three. See Hepworth (1996) additional details exact method methods constructing confidence intervals group testing situations. computational details simulation results remaining methods, see Biggerstaff (2008). See Hepworth & Biggerstaff (2017) recommendations best point estimator methods.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/propCI.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Confidence intervals for one proportion in group testing — propCI","text":"Biggerstaff, B. (2008). “Confidence intervals difference proportions estimated pooled samples.” Journal Agricultural, Biological, Environmental Statistics, 13, 478–496. Hepworth, G. (1996). “Exact confidence intervals proportions estimated group testing.” Biometrics, 52, 1134–1146. Hepworth, G., Biggerstaff, B. (2017). “Bias correction estimating proportions pooled testing.” Journal Agricultural, Biological, Environmental Statistics, 22, 602–614. Schaarschmidt, F. (2007). “Experimental design one-sided confidence intervals hypothesis tests binomial group testing.” Communications Biometry Crop Science, 2, 32–40. ISSN 1896-0782. Tebbs, J., Bilder, C. (2004). “Confidence interval procedures probability disease transmission multiple-vector-transfer designs.” Journal Agricultural, Biological, Environmental Statistics, 9, 75–90.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/propCI.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Confidence intervals for one proportion in group testing — propCI","text":"function combination bgtCI bgtvs written Frank Schaarschmidt pooledBin written Brad Biggerstaff binGroup package. Minor modifications made inclusion functions binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/propCI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Confidence intervals for one proportion in group testing — propCI","text":"","code":"# Example from Tebbs and Bilder (2004): #   3 groups out of 24 test positively;  #   each group has a size of 7. # Clopper-Pearson interval: propCI(x = 3, m = 7, n = 24, ci.method = \"CP\",         conf.level = 0.95, alternative = \"two.sided\") #>  #> 95 percent Clopper-Pearson confidence interval: #>  [ 0.003838, 0.05432 ] #> Point estimate (Maximum Likelihood): 0.0189        # Clopper-Pearson interval with the bias-corrected  #   MLE (\\kbd{pt.method = \"Gart\"}).  propCI(x = 3, m = 7, n = 24, pt.method = \"Gart\",         ci.method = \"CP\", conf.level = 0.95,         alternative = \"two.sided\") #>  #> 95 percent Clopper-Pearson confidence interval: #>  [ 0.003838, 0.05432 ] #> Point estimate (Gart's Correction): 0.01854        # One-sided Clopper-Pearson interval: propCI(x = 3, m = 7, n = 24, ci.method = \"CP\",         conf.level = 0.95, alternative = \"less\") #>  #> 95 percent Clopper-Pearson confidence interval: #>  [ 0, 0.04819 ] #> Point estimate (Maximum Likelihood): 0.0189         # Blaker interval: propCI(x = 3, m = 7, n = 24, ci.method = \"Blaker\",         conf.level = 0.95, alternative = \"two.sided\") #>  #> 95 percent Blaker confidence interval: #>  [ 0.005056, 0.0513 ] #> Point estimate (Maximum Likelihood): 0.0189        # Wilson score interval:  propCI(x = 3, m = 7, n = 24, ci.method = \"score\",         conf.level = 0.95, alternative = \"two.sided\") #>  #> 95 percent Wilson score confidence interval: #>  [ 0.006325, 0.05164 ] #> Point estimate (Maximum Likelihood): 0.0189  # Calculate confidence intervals with a group size of 1.  #   These match those found using the binom.confint()  #   function from the binom package. propCI(x = 4, m = 1, n = 10, pt.method = \"mle\",         ci.method = \"AC\") #>  #> 95 percent Agresti-Coull confidence interval: #>  [ 0.1671, 0.6884 ] #> Point estimate (Maximum Likelihood): 0.4 propCI(x = 4, m = 1, n = 10, pt.method = \"mle\",         ci.method = \"score\") #>  #> 95 percent Wilson score confidence interval: #>  [ 0.1682, 0.6873 ] #> Point estimate (Maximum Likelihood): 0.4 propCI(x = 4, m = 1, n = 10, pt.method = \"mle\",         ci.method = \"Wald\") #>  #> 95 percent Wald confidence interval: #>  [ 0.09636, 0.7036 ] #> Point estimate (Maximum Likelihood): 0.4  # Example from Hepworth (1996, table 5): #   1 group out of 2 tests positively with  #   groups of size 5; also,  #   2 groups out of 3 test positively with  #   groups of size 2. propCI(x = c(1,2), m = c(5,2), n = c(2,3), ci.method = \"exact\")  #>  #> 95 percent Exact confidence interval: #>  [ 0.05172, 0.5533 ] #> Point estimate (Maximum Likelihood): 0.2435  # Bias-preventative point estimate (\\kbd{pt.method = \"Firth\"})  #   with an exact confidence interval. propCI(x = c(1,2), m = c(5,2), n = c(2,3),         pt.method = \"Firth\", ci.method = \"exact\")  #>  #> 95 percent Exact confidence interval: #>  [ 0.05172, 0.5533 ] #> Point estimate (Firth's Correction): 0.2194  # Recalculate the example given in #   Hepworth (1996), table 5: propCI(x = c(0,0), m = c(5,2), n = c(2,3), ci.method = \"exact\") #>  #> 95 percent Exact confidence interval: #>  [ 0, 0.2059 ] #> Point estimate (Maximum Likelihood): 0 propCI(x = c(0,1), m = c(5,2), n = c(2,3), ci.method = \"exact\") #>  #> 95 percent Exact confidence interval: #>  [ 0.001581, 0.2667 ] #> Point estimate (Maximum Likelihood): 0.06459 propCI(x = c(0,2), m = c(5,2), n = c(2,3), ci.method = \"exact\") #>  #> 95 percent Exact confidence interval: #>  [ 0.01726, 0.3532 ] #> Point estimate (Maximum Likelihood): 0.134 propCI(x = c(0,3), m = c(5,2), n = c(2,3), ci.method = \"exact\") #>  #> 95 percent Exact confidence interval: #>  [ 0.05125, 0.5003 ] #> Point estimate (Maximum Likelihood): 0.2094 propCI(x = c(1,0), m = c(5,2), n = c(2,3), ci.method = \"exact\") #>  #> 95 percent Exact confidence interval: #>  [ 0.002521, 0.3387 ] #> Point estimate (Maximum Likelihood): 0.0722 propCI(x = c(1,1), m = c(5,2), n = c(2,3), ci.method = \"exact\") #>  #> 95 percent Exact confidence interval: #>  [ 0.01842, 0.4435 ] #> Point estimate (Maximum Likelihood): 0.1523 propCI(x = c(1,2), m = c(5,2), n = c(2,3), ci.method = \"exact\") #>  #> 95 percent Exact confidence interval: #>  [ 0.05172, 0.5533 ] #> Point estimate (Maximum Likelihood): 0.2435 propCI(x = c(1,3), m = c(5,2), n = c(2,3), ci.method = \"exact\") #>  #> 95 percent Exact confidence interval: #>  [ 0.1084, 0.7072 ] #> Point estimate (Maximum Likelihood): 0.3516 propCI(x = c(2,0), m = c(5,2), n = c(2,3), ci.method = \"exact\") #>  #> 95 percent Exact confidence interval: #>  [ 0.03161, 0.4991 ] #> Point estimate (Maximum Likelihood): 0.1781 propCI(x = c(2,1), m = c(5,2), n = c(2,3), ci.method = \"exact\") #>  #> 95 percent Exact confidence interval: #>  [ 0.06237, 0.6967 ] #> Point estimate (Maximum Likelihood): 0.2979 propCI(x = c(2,2), m = c(5,2), n = c(2,3), ci.method = \"exact\") #>  #> 95 percent Exact confidence interval: #>  [ 0.1147, 0.9084 ] #> Point estimate (Maximum Likelihood): 0.4699 propCI(x = c(2,3), m = c(5,2), n = c(2,3), ci.method = \"exact\") #>  #> 95 percent Exact confidence interval: #>  [ 0.209, 1 ] #> Point estimate (Maximum Likelihood): 1  # Example with multiple groups of various sizes:  #   0 out of 5 groups test positively with  #   groups of size 1 (individual testing); #   0 out of 5 groups test positively with  #   groups of size 5; #   1 out of 5 groups test positively with  #   groups of size 10; and #   2 out of 5 groups test positively with  #   groups of size 50. x1 <- c(0, 0, 1, 2) m1 <- c(1, 5, 10, 50) n1 <- c(5, 5, 5, 5) propCI(x = x1, m = m1, n = n1, pt.method = \"Gart\",         ci.method = \"skew-score\") #>  #> 95 percent Skew-Corrected score (Gart) confidence interval: #>  [ 0.002806, 0.02879 ] #> Point estimate (Gart's Correction): 0.01027 propCI(x = x1, m = m1, n = n1, pt.method = \"Gart\",         ci.method = \"score\") #>  #> 95 percent Wilson score confidence interval: #>  [ 0.00351, 0.02804 ] #> Point estimate (Gart's Correction): 0.01027  # Reproducing estimates from Table 1 in #   Hepworth & Biggerstaff (2017): propCI(x = c(1, 2), m = c(20, 5), n = c(8, 8),         pt.method = \"Firth\", ci.method = \"lrt\") #>  #> 95 percent Likelihood Ratio Test Inversion confidence interval: #>  [ 0.004033, 0.04142 ] #> Point estimate (Firth's Correction): 0.01548 propCI(x = c(7, 8), m = c(20, 5), n = c(8, 8),         pt.method = \"Firth\", ci.method = \"lrt\") #>  #> 95 percent Likelihood Ratio Test Inversion confidence interval: #>  [ 0.109, 0.3515 ] #> Point estimate (Firth's Correction): 0.1866"},{"path":"https://bdhitt.github.io/binGroup2/reference/propDiffCI.html","id":null,"dir":"Reference","previous_headings":"","what":"Confidence intervals for the difference of proportions in group testing — propDiffCI","title":"Confidence intervals for the difference of proportions in group testing — propDiffCI","text":"Calculates confidence intervals difference two proportions based group testing data.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/propDiffCI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Confidence intervals for the difference of proportions in group testing — propDiffCI","text":"","code":"propDiffCI(   x1,   m1,   x2,   m2,   n1 = rep(1, length(x1)),   n2 = rep(1, length(x2)),   pt.method = c(\"Firth\", \"Gart\", \"bc-mle\", \"mle\"),   ci.method = c(\"skew-score\", \"bc-skew-score\", \"score\", \"lrt\", \"Wald\"),   conf.level = 0.95,   tol = .Machine$double.eps^0.5 )"},{"path":"https://bdhitt.github.io/binGroup2/reference/propDiffCI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Confidence intervals for the difference of proportions in group testing — propDiffCI","text":"x1 vector specifying observed number positive groups among number groups tested (n1) population 1. m1 vector corresponding group sizes population 1. Must length x1. x2 vector specifying observed number positive groups among number groups tested (n2) population 2. m2 vector corresponding group sizes population 2. Must length x2. n1 vector corresponding number groups sizes m1. n2 vector corresponding number groups sizes m2. pt.method character string specifying point estimator compute. Options include \"Firth\" bias-preventative estimator (Hepworth & Biggerstaff, 2017), default \"Gart\" bias-corrected MLE (Biggerstaff, 2008), \"bc-mle\" (\"Gart\" backward compatibility), \"mle\" MLE. ci.method character string specifying confidence interval compute. Options include \"skew-score\" skewness-corrected, \"score\" score (default), \"bc-skew-score\" bias- skewness-corrected, \"lrt\" likelihood ratio test, \"Wald\" Wald interval. See Biggerstaff (2008) additional details. conf.level confidence level interval. tol accuracy required iterations internal functions.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/propDiffCI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Confidence intervals for the difference of proportions in group testing — propDiffCI","text":"list containing: d estimated difference proportions. lcl lower confidence limit. ucl upper confidence limit. pt.method method used point estimation. ci.method method used confidence interval estimation. conf.level confidence level interval. x1 numbers positive groups population 1. m1 sizes groups population 1. n1 numbers groups corresponding group sizes m1 population 1. x2 numbers positive groups population 2. m2 sizes groups population 2. n2 numbers groups corresponding group sizes m2 population 2.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/propDiffCI.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Confidence intervals for the difference of proportions in group testing — propDiffCI","text":"Confidence interval methods include Wilson score (ci.method = \"score\"), skewness-corrected score (ci.method = \"skew-score\"), bias- skewness-corrected score (ci.method = \"bc-skew-score\"), likelihood ratio test (ci.method = \"lrt\"), Wald (ci.method = \"Wald\") interval. computational details, simulation results, recommendations confidence interval methods, see Biggerstaff (2008). Point estimates available include MLE (pt.method = \"mle\"), bias-corrected MLE (pt.method = \"Gart\" pt.method = \"bc-mle\"), bias-preventative (pt.method = \"Firth\"). additional details recommendations point estimation, see Hepworth Biggerstaff (2017).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/propDiffCI.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Confidence intervals for the difference of proportions in group testing — propDiffCI","text":"Biggerstaff, B. (2008). “Confidence intervals difference proportions estimated pooled samples.” Journal Agricultural, Biological, Environmental Statistics, 13, 478–496. Hepworth, G., Biggerstaff, B. (2017). “Bias correction estimating proportions pooled testing.” Journal Agricultural, Biological, Environmental Statistics, 22, 602–614.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/propDiffCI.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Confidence intervals for the difference of proportions in group testing — propDiffCI","text":"function originally written pooledBinDiff function Brad Biggerstaff binGroup package. Minor modifications made inclusion function binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/propDiffCI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Confidence intervals for the difference of proportions in group testing — propDiffCI","text":"","code":"# Estimate the prevalence in two populations #   with multiple groups of various sizes: # Population 1: #   0 out of 5 groups test positively with #   groups of size 1 (individual testing); #   0 out of 5 groups test positively with #   groups of size 5; #   1 out of 5 groups test positively with #   groups of size 10; and #   2 out of 5 groups test positively with #   groups of size 50. # Population 2: #   0 out of 5 groups test positively with #   groups of size 1 (individual testing); #   1 out of 5 groups test positively with #   groups of size 5; #   0 out of 5 groups test positively with #   groups of size 10; and #   4 out of 5 groups test positively with #   groups of size 50. x1 <- c(0, 0, 1, 2) m <- c(1, 5, 10, 50) n <- c(5, 5, 5, 5) x2 <- c(0, 1, 0, 4) propDiffCI(x1 = x1, m1 = m, x2 = x2, m2 = m, n1 = n, n2 = n,            pt.method = \"Gart\", ci.method = \"score\") #>  #> 95 percent Wilson score confidence interval: #>  [ -0.04175, 0.011 ] #> Point estimate (Gart's Correction): -0.01153  # Compare recommended methods: propDiffCI(x1 = x1, m1 = m, x2 = x2, m2 = m, n1 = n, n2 = n,            pt.method = \"mle\", ci.method = \"lrt\") #>  #> 95 percent Likelihood Ratio Test Inversion confidence interval: #>  [ -0.04381, 0.01123 ] #> Point estimate (Maximum Likelihood): -0.01273  propDiffCI(x1 = x1, m1 = m, x2 = x2, m2 = m, n1 = n, n2 = n,            pt.method = \"mle\", ci.method = \"score\") #>  #> 95 percent Wilson score confidence interval: #>  [ -0.04175, 0.011 ] #> Point estimate (Maximum Likelihood): -0.01273  propDiffCI(x1 = x1, m1 = m, x2 = x2, m2 = m, n1 = n, n2 = n,            pt.method = \"mle\", ci.method = \"skew-score\") #>  #> 95 percent Skew-Corrected score (Gart) confidence interval: #>  [ -0.04415, 0.01151 ] #> Point estimate (Maximum Likelihood): -0.01273"},{"path":"https://bdhitt.github.io/binGroup2/reference/residuals.gtReg.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract model residuals from a fitted group testing model — residuals.gtReg","title":"Extract model residuals from a fitted group testing model — residuals.gtReg","text":"Extract model residuals objects class \"gtReg\" returned gtReg.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/residuals.gtReg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract model residuals from a fitted group testing model — residuals.gtReg","text":"","code":"# S3 method for class 'gtReg' residuals(object, type = c(\"deviance\", \"pearson\", \"response\"), ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/residuals.gtReg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract model residuals from a fitted group testing model — residuals.gtReg","text":"object object class \"gtReg\", created gtReg, model residuals extracted. type type residuals returned. Options include \"deviance\" (default), \"pearson\", \"response\". ... currently used.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/residuals.gtReg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract model residuals from a fitted group testing model — residuals.gtReg","text":"Residuals group responses extracted object object.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/residuals.gtReg.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract model residuals from a fitted group testing model — residuals.gtReg","text":"function originally written Boan Zhang residuals.gt function binGroup package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/residuals.gtReg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract model residuals from a fitted group testing model — residuals.gtReg","text":"","code":"data(hivsurv) fit1 <- gtReg(formula = groupres ~ AGE * EDUC.,               data = hivsurv, groupn = gnum,               linkf = \"probit\") residuals(object = fit1, type = \"pearson\") #>          1          2          3          4          5          6          7  #> -0.9055885 -0.6817337  1.0994452 -0.5926129 -0.9006457  0.8774835  1.1276576  #>          8          9         10         11         12         13         14  #> -0.6482013 -0.7618318 -0.7357126  1.3661232  1.3541500  1.7884858 -0.7328576  #>         15         16         17         18         19         20         21  #>  1.1157537  1.2634651  1.2844443 -0.6671900 -0.7178230 -0.7267928  1.3694189  #>         22         23         24         25         26         27         28  #> -0.6870413 -0.8456798 -0.8384433  1.1369704 -0.9417096 -0.7795163 -0.6209909  #>         29         30         31         32         33         34         35  #>  1.5214576  0.8789021 -1.0731765 -0.8810245 -0.6495203 -0.5918557 -0.6366881  #>         36         37         38         39         40         41         42  #>  0.8984665 -0.9218154 -0.5680544  1.1559158  1.6681266 -0.7010634 -0.7003694  #>         43         44         45         46         47         48         49  #> -0.6015539  1.4664130 -0.8279346 -0.8089442 -0.6028382  1.1730439 -0.8100753  #>         50         51         52         53         54         55         56  #>  1.4778378  1.0178694 -1.0440292  1.2268466 -0.7154452  1.3840737 -0.6508478  #>         57         58         59         60         61         62         63  #> -0.6385867 -0.7399243  1.3886819 -0.7003915 -0.6960409 -0.8384864 -0.5396091  #>         64         65         66         67         68         69         70  #> -0.7426180  1.2081364  1.3562852 -0.5801237 -0.8297057 -1.0657841 -0.5839336  #>         71         72         73         74         75         76         77  #> -0.5961649 -0.6379928 -0.8441386 -1.0441698 -0.6695771  1.2162844 -0.6066662  #>         78         79         80         81         82         83         84  #> -0.8610128  1.2729283  1.6970807 -0.6220974  1.7439897 -0.5727264  1.3236869  #>         85         86  #>  1.3304640 -0.5694523  residuals(object = fit1, type = \"deviance\") #>          1          2          3          4          5          6          7  #> -1.0944279 -0.8737184  1.2589203 -0.7758681 -1.0899257  1.0686129  1.2810071  #>          8          9         10         11         12         13         14  #> -0.8375835 -0.9567343 -0.9301706  1.4512198  1.4433234  1.6939720 -0.9272375  #>         15         16         17         18         19         20         21  #>  1.2717420  1.3813793  1.3960538 -0.8581467 -0.9116946 -0.9209872  1.4533822  #>         22         23         24         25         26         27         28  #> -0.8793628 -1.0387634 -1.0318759  1.2882010 -1.1268463 -0.9744442 -0.8076567  #>         29         30         31         32         33         34         35  #>  1.5481649  1.0699285 -1.2379514 -1.0718942 -0.8390204 -0.7750120 -0.8249871  #>         36         37         38         39         40         41         42  #>  1.0879356 -1.1090961 -0.7478828  1.3026900  1.6312105 -0.8941762 -0.8934464  #>         43         44         45         46         47         48         49  #> -0.7859473  1.5149383 -1.0218100 -1.0034269 -0.7873903  1.3156229 -1.0045288  #>         50         51         52         53         54         55         56  #>  1.5219328  1.1924895 -1.2142179  1.3552488 -0.9092215  1.4629397 -0.8404652  #>         57         58         59         60         61         62         63  #> -0.8270710 -0.9344870  1.4659257 -0.8934696 -0.8888867 -1.0319169 -0.7149196  #>         64         65         66         67         68         69         70  #> -0.9372409  1.3416379  1.4447362 -0.7616913 -1.0235117 -1.2319790 -0.7660281  #>         71         72         73         74         75         76         77  #> -0.7798794 -0.8264194 -1.0372995 -1.2143337 -0.8607132  1.3475871 -0.7916842  #>         78         79         80         81         82         83         84  #> -1.0532395  1.3880249  1.6467280 -0.8088843  1.6712964 -0.7532407  1.4229415  #>         85         86  #>  1.4275125 -0.7494876"},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.OTC.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for optimal testing configuration results — summary.OTC","title":"Summary method for optimal testing configuration results — summary.OTC","text":"Produce summary list objects class \"OTC\" returned OTC1 OTC2.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.OTC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for optimal testing configuration results — summary.OTC","text":"","code":"# S3 method for class 'OTC' summary(object, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.OTC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for optimal testing configuration results — summary.OTC","text":"object object class \"OTC\", providing optimal testing configuration associated operating characteristics group testing algorithm. ... currently used.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.OTC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for optimal testing configuration results — summary.OTC","text":"summary.OTC returns object class \"summary.OTC\", list containing: Algorithm character string specifying name group testing algorithm. OTC matrix detailing optimal testing configuration object. hierarchical testing, includes group sizes stage testing. array testing, includes array dimension (row/column size) array size (total number individuals array). Tests matrix detailing expected number tests expected number tests per individual object. Accuracy matrix detailing overall accuracy measures algorithm, including pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value algorithm object. details found 'Details' section.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.OTC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summary method for optimal testing configuration results — summary.OTC","text":"function produces summary list objects class \"OTC\" returned OTC1 OTC2. formats optimal testing configuration, expected number tests, expected number tests per individual, accuracy measures. summary results OTC1 includes results objective functions specified user. OTC component result gives optimal testing configuration, may include group sizes stage hierarchical testing algorithm row/column size array size array testing algorithm. Tests component result gives expected number tests expected number tests per individual algorithm. Accuracy component gives overall accuracy measures algorithm. Accuracy measures included pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value. values weighted averages corresponding individual accuracy measures individuals algorithm. Expressions averages provided Supplementary Material Hitt et al. (2019). information, see 'Details' section OTC1 OTC2 function.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.OTC.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summary method for optimal testing configuration results — summary.OTC","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.OTC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary method for optimal testing configuration results — summary.OTC","text":"","code":"# Find the optimal testing configuration for #   non-informative two-stage hierarchical testing. res1 <- OTC1(algorithm = \"D2\", p = 0.01, Se = 0.99, Sp = 0.99,              group.sz = 2:100, obj.fn = c(\"ET\", \"MAR\", \"GR1\"),              weights = matrix(data = c(1,1), nrow = 1, ncol = 2)) #> Initial Group Size = 2 #> Initial Group Size = 3 #> Initial Group Size = 4 #> Initial Group Size = 5 #> Initial Group Size = 6 #> Initial Group Size = 7 #> Initial Group Size = 8 #> Initial Group Size = 9 #> Initial Group Size = 10 #> Initial Group Size = 11 #> Initial Group Size = 12 #> Initial Group Size = 13 #> Initial Group Size = 14 #> Initial Group Size = 15 #> Initial Group Size = 16 #> Initial Group Size = 17 #> Initial Group Size = 18 #> Initial Group Size = 19 #> Initial Group Size = 20 #> Initial Group Size = 21 #> Initial Group Size = 22 #> Initial Group Size = 23 #> Initial Group Size = 24 #> Initial Group Size = 25 #> Initial Group Size = 26 #> Initial Group Size = 27 #> Initial Group Size = 28 #> Initial Group Size = 29 #> Initial Group Size = 30 #> Initial Group Size = 31 #> Initial Group Size = 32 #> Initial Group Size = 33 #> Initial Group Size = 34 #> Initial Group Size = 35 #> Initial Group Size = 36 #> Initial Group Size = 37 #> Initial Group Size = 38 #> Initial Group Size = 39 #> Initial Group Size = 40 #> Initial Group Size = 41 #> Initial Group Size = 42 #> Initial Group Size = 43 #> Initial Group Size = 44 #> Initial Group Size = 45 #> Initial Group Size = 46 #> Initial Group Size = 47 #> Initial Group Size = 48 #> Initial Group Size = 49 #> Initial Group Size = 50 #> Initial Group Size = 51 #> Initial Group Size = 52 #> Initial Group Size = 53 #> Initial Group Size = 54 #> Initial Group Size = 55 #> Initial Group Size = 56 #> Initial Group Size = 57 #> Initial Group Size = 58 #> Initial Group Size = 59 #> Initial Group Size = 60 #> Initial Group Size = 61 #> Initial Group Size = 62 #> Initial Group Size = 63 #> Initial Group Size = 64 #> Initial Group Size = 65 #> Initial Group Size = 66 #> Initial Group Size = 67 #> Initial Group Size = 68 #> Initial Group Size = 69 #> Initial Group Size = 70 #> Initial Group Size = 71 #> Initial Group Size = 72 #> Initial Group Size = 73 #> Initial Group Size = 74 #> Initial Group Size = 75 #> Initial Group Size = 76 #> Initial Group Size = 77 #> Initial Group Size = 78 #> Initial Group Size = 79 #> Initial Group Size = 80 #> Initial Group Size = 81 #> Initial Group Size = 82 #> Initial Group Size = 83 #> Initial Group Size = 84 #> Initial Group Size = 85 #> Initial Group Size = 86 #> Initial Group Size = 87 #> Initial Group Size = 88 #> Initial Group Size = 89 #> Initial Group Size = 90 #> Initial Group Size = 91 #> Initial Group Size = 92 #> Initial Group Size = 93 #> Initial Group Size = 94 #> Initial Group Size = 95 #> Initial Group Size = 96 #> Initial Group Size = 97 #> Initial Group Size = 98 #> Initial Group Size = 99 #> Initial Group Size = 100 #>  #>  Number of minutes running:  0  #>   summary(res1) #>  #> Algorithm: Non-informative two-stage hierarchical testing  #>  #> Optimal testing configuration: #>     Stage 1 #> ET       11 #> MAR      11 #> GR1      11 #>  #> Expected number of tests: #>     E(T)  Value #> ET  2.24 0.2035 #> MAR 2.24 0.2037 #> GR1 2.24 0.2047 #>  #> E(T) denotes the expected number of tests. #> Value denotes the objective function value per individual. #>  #> Overall accuracy of the algorithm: #>        PSe    PSp   PPPV   PNPV #> ET  0.9801 0.9990 0.9052 0.9998 #> MAR 0.9801 0.9990 0.9052 0.9998 #> GR1 0.9801 0.9990 0.9052 0.9998 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value.  # Find the optimal testing configuration for #   informative three-stage hierarchical testing res2 <- OTC1(algorithm = \"ID3\", p = 0.025,              Se = c(0.95, 0.95, 0.99), Sp = c(0.96, 0.96, 0.98),              group.sz = 3:10, obj.fn = c(\"ET\", \"MAR\"), alpha = 2) #> Initial Group Size = 3 #> Initial Group Size = 4 #> Initial Group Size = 5 #> Initial Group Size = 6 #> Initial Group Size = 7 #> Initial Group Size = 8 #> Initial Group Size = 9 #> Initial Group Size = 10 #>  #>  Number of minutes running:  0  #>   summary(res2) #>  #> Algorithm: Informative three-stage hierarchical testing  #>  #> Optimal testing configuration: #>     Stage 1 Stage 2 #> ET       10   5,3,2 #> MAR      10   5,3,2 #>  #> Expected number of tests: #>     E(T)  Value #> ET  2.49 0.2488 #> MAR 2.49 0.2497 #>  #> E(T) denotes the expected number of tests. #> Value denotes the objective function value per individual. #>  #> Overall accuracy of the algorithm: #>        PSe    PSp   PPPV   PNPV #> ET  0.8935 0.9989 0.9548 0.9973 #> MAR 0.8935 0.9989 0.9548 0.9973 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value.  # Find the optimal testing configuration for #   informative array testing without master pooling. res3 <- OTC1(algorithm = \"IA2\", p = 0.05, alpha = 2,              Se = 0.90, Sp = 0.90, group.sz = 2:15,              obj.fn = \"ET\") #> Row/Column Size = 2, Array Size = 4 #> Row/Column Size = 3, Array Size = 9 #> Row/Column Size = 4, Array Size = 16 #> Row/Column Size = 5, Array Size = 25 #> Row/Column Size = 6, Array Size = 36 #> Row/Column Size = 7, Array Size = 49 #> Row/Column Size = 8, Array Size = 64 #> Row/Column Size = 9, Array Size = 81 #> Row/Column Size = 10, Array Size = 100 #> Row/Column Size = 11, Array Size = 121 #> Row/Column Size = 12, Array Size = 144 #> Row/Column Size = 13, Array Size = 169 #> Using simulation #> Row/Column Size = 14, Array Size = 196 #> Using simulation #> Row/Column Size = 15, Array Size = 225 #>  #>  Number of minutes running:  0.1  #>   summary(res3) #>  #> Algorithm: Informative array testing without master pooling  #>  #> Optimal testing configuration: #>    Row/column size Array size #> ET              11        121 #>  #> Expected number of tests: #>     E(T)  Value #> ET 45.78 0.3784 #>  #> E(T) denotes the expected number of tests. #> Value denotes the objective function value per individual. #>  #> Overall accuracy of the algorithm: #>       PSe    PSp   PPPV   PNPV #> ET 0.7295 0.9836 0.7004 0.9857 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value.  # Find the optimal testing configuraiton for #   informative two-stage hierarchical testing. Se <- matrix(data = c(rep(0.95, 2), rep(0.99, 2)),              nrow = 2, ncol = 2, byrow = FALSE) Sp <- matrix(data = c(rep(0.96, 2), rep(0.98, 2)),              nrow = 2, ncol = 2, byrow = FALSE) res4 <- OTC2(algorithm = \"ID2\",              alpha = c(18.25, 0.75, 0.75, 0.25),              Se = Se, Sp = Sp, group.sz = 8) #> Block Size = 8 #>  #>  Number of minutes running:  0  #>   summary(res4) #>  #> Algorithm: Informative two-stage hierarchical testing  #>  #> Optimal testing configuration: #>    Block size Group sizes #> ET          8         4,4 #>  #> Expected number of tests: #>    E(T)  Value #> ET 5.47 0.6844 #>  #> E(T) denotes the expected number of tests. #> Value denotes the objective function value per individual. #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9737 0.9495 0.4759 0.9987 #> 2 0.9610 0.9197 0.5550 0.9956 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value.  # Find the optimal testing configuration for #   non-informative three-stage hierarchical testing. Se <- matrix(data = c(rep(0.95, 6)), nrow = 2, ncol = 3) Sp <- matrix(data = c(rep(0.99, 6)), nrow = 2, ncol = 3) res5 <- OTC2(algorithm = \"D3\",              p.vec = c(0.95, 0.0275, 0.0175, 0.005),              Se = Se, Sp = Sp, group.sz = 5:12) #> Initial Group Size = 5 #> Initial Group Size = 6 #> Initial Group Size = 7 #> Initial Group Size = 8 #> Initial Group Size = 9 #> Initial Group Size = 10 #> Initial Group Size = 11 #> Initial Group Size = 12 #>  #>  Number of minutes running:  0.04  #>   summary(res5) #>  #> Algorithm: Non-informative three-stage hierarchical testing  #>  #> Optimal testing configuration: #>    Stage 1 Stage 2 #> ET       9   3,3,3 #>  #> Expected number of tests: #>    E(T)  Value #> ET 3.33 0.3695 #>  #> E(T) denotes the expected number of tests. #> Value denotes the objective function value per individual. #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8793 0.9989 0.9643 0.9960 #> 2 0.8875 0.9988 0.9456 0.9974 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value.  # Find the optimal testing configuration for #   non-informative array testing with master pooling. res6 <- OTC2(algorithm = \"A2M\", p.vec = c(0.90, 0.04, 0.04, 0.02),              Se = rep(0.99, 2), Sp = rep(0.99, 2), group.sz = 2:12) #> Row/Column Size = 2, Array Size = 4 #> Row/Column Size = 3, Array Size = 9 #> Row/Column Size = 4, Array Size = 16 #> Row/Column Size = 5, Array Size = 25 #> Row/Column Size = 6, Array Size = 36 #> Row/Column Size = 7, Array Size = 49 #> Row/Column Size = 8, Array Size = 64 #> Row/Column Size = 9, Array Size = 81 #> Row/Column Size = 10, Array Size = 100 #> Row/Column Size = 11, Array Size = 121 #> Row/Column Size = 12, Array Size = 144 #>  #>  Number of minutes running:  0  #>   summary(res6) #>  #> Algorithm: Non-informative array testing with master pooling  #>  #> Optimal testing configuration: #>    Row/column size Array size #> ET               8         64 #>  #> Expected number of tests: #>     E(T)  Value #> ET 35.94 0.5615 #>  #> E(T) denotes the expected number of tests. #> Value denotes the objective function value per individual. #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9785 0.9975 0.9612 0.9986 #> 2 0.9785 0.9975 0.9612 0.9986 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value."},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.gtReg.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for gtReg — summary.gtReg","title":"Summary method for gtReg — summary.gtReg","text":"Produce summary list objects class \"gtReg\" returned gtReg.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.gtReg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for gtReg — summary.gtReg","text":"","code":"# S3 method for class 'gtReg' summary(object, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.gtReg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for gtReg — summary.gtReg","text":"object fitted object class \"gtReg\". ... currently used.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.gtReg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for gtReg — summary.gtReg","text":"summary.gtReg returns object class \"summary.gtReg\", list containing: call component object. link component object. deviance component object, simple pooling (type = \"sp\" gtReg) . aic component object, simple pooling (type = \"sp\" gtReg) . df.residual component object, simple pooling (type = \"sp\" gtReg) . null.deviance component object, simple pooling (type = \"sp\" gtReg) . df.null component object, simple pooling (type = \"sp\" gtReg) . deviance.resid deviance residuals, simple pooling (type = \"sp\" gtReg) . coefficients matrix coefficients, standard errors, z-values, p-values. Aliased coefficients omitted. counts component object. method component object, simple pooling (type = \"sp\" gtReg) . Gibbs.sample.size component object, array testing (type = \"array\" gtReg) . cov.mat estimated covariance matrix estimated coefficients.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.gtReg.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summary method for gtReg — summary.gtReg","text":"coefficients component results gives matrix containing estimated coefficients estimated standard errors. third column ratio, labeled z ratio using Wald tests. fourth column gives two-tailed p-value corresponding z-ratio based Wald test. Note possible residual degrees freedom estimate, case estimate NaN.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.gtReg.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summary method for gtReg — summary.gtReg","text":"majority function originally written summary.gt summary.gt.mp Boan Zhang binGroup package. Minor modifications made function inclusion binGroup2 package.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.gtReg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary method for gtReg — summary.gtReg","text":"","code":"data(hivsurv) fit1 <- gtReg(type = \"sp\",               formula = groupres ~ AGE + EDUC.,               data = hivsurv, groupn = gnum,               sens = 0.9, spec = 0.9,               method = \"Xie\") #>  #>  Number of minutes running: 0  #>   summary(fit1) #>  #> Call: #> gtReg(type = \"sp\", formula = groupres ~ AGE + EDUC., data = hivsurv,  #>     groupn = gnum, sens = 0.9, spec = 0.9, method = \"Xie\") #>  #> Deviance Residuals:  #>     Min       1Q   Median       3Q      Max   #> -1.1729  -0.9406  -0.8281   1.3386   1.6497   #>  #> Coefficients: #>             Estimate Std. Error z value Pr(>|z|)   #> (Intercept) -3.11976    1.84816  -1.688   0.0914 . #> AGE         -0.05692    0.07777  -0.732   0.4642   #> EDUC.        0.82833    0.50717   1.633   0.1024   #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #>     Null deviance: 154.3  on 85  degrees of freedom #> Residual deviance: 109.5  on 83  degrees of freedom #> AIC: 115.5 #>  #> Number of iterations in EM: 43 #>   # 5x6 and 4x5 array set.seed(9128) sa2a <- gtSim(type = \"array\", par = c(-7, 0.1),               size1 = c(5, 4), size2 = c(6, 5),               sens = 0.95, spec = 0.95) sa2 <- sa2a$dframe # \\donttest{ fit2 <- gtReg(type = \"array\",               formula = cbind(col.resp, row.resp) ~ x,               data = sa2, coln = coln, rown = rown,               arrayn = arrayn, sens = 0.95, spec = 0.95,               linkf = \"logit\", n.gibbs = 1000, tol = 0.005) #>  #>  Number of minutes running: 0.07  #>   summary(fit2)# } #>  #> Call: #> gtReg(type = \"array\", formula = cbind(col.resp, row.resp) ~ x,  #>     data = sa2, coln = coln, rown = rown, arrayn = arrayn, sens = 0.95,  #>     spec = 0.95, linkf = \"logit\", n.gibbs = 1000, tol = 0.005) #>  #>  #> Coefficients: #>             Estimate Std. Error z value Pr(>|z|)   #> (Intercept) -6.24306    2.86818  -2.177   0.0295 * #> x            0.08670    0.05982   1.450   0.1472   #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> Number of Gibbs samples generated in each E step: 1000 #> Number of iterations in EM algorithm: 3 #>"},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.opChar.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for operating characteristics results — summary.opChar","title":"Summary method for operating characteristics results — summary.opChar","text":"Produce summary list objects class \"opChar\" returned operatingCharacteristics1 (opChar1) operatingCharacteristics2 (opChar2).","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.opChar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for operating characteristics results — summary.opChar","text":"","code":"# S3 method for class 'opChar' summary(object, ...)"},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.opChar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for operating characteristics results — summary.opChar","text":"object object class \"opChar\", providing calculated operating characteristics group testing algorithm. ... currently used.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.opChar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for operating characteristics results — summary.opChar","text":"summary.opChar returns object class \"summary.opChar\", list containing: Algorithm character string specifying name group testing algorithm. Configuration matrix detailing configuration object. hierarchical testing, includes group sizes stage testing. array testing, includes array dimension (row/column size) array size (total number individuals array). Tests matrix detailing expected number tests expected number tests per individual object . Accuracy list containing: Individual matrix detailing accuracy measures individual object (objects returned opChar1). Disease 1 Individual matrix detailing accuracy measures pertaining disease 1 individual object (objects returned opChar2). Disease 2 Individual matrix detailing accuracy measures pertaining disease 2 individual object (objects returned opChar2). Overall matrix detailing overall accuracy measures algorithm object.","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.opChar.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summary method for operating characteristics results — summary.opChar","text":"function produces summary list objects class \"opChar\" returned operatingCharacteristics1 (opChar1) operatingCharacteristics2 (opChar2). formats testing configuration, expected number tests, expected number tests per individual, accuracy measures. Configuration component result gives testing configuration, may include group sizes stage hierarchical testing algorithm row/column size array size array testing algorithm. Tests component result gives expected number tests expected number tests per individual algorithm. Accuracy component gives individual accuracy measures individual object overall accuracy measures algorithm. Accuracy measures included pooling sensitivity, pooling specificity, pooling positive predictive value, pooling negative predictive value. overall accuracy measures displayed weighted averages corresponding individual accuracy measures individuals algorithm. Expressions averages provided Supplementary Material Hitt et al. (2019). information, see Details' section operatingCharacteristics1 (opChar1) operatingCharacteristics2 (opChar2) function.","code":""},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.opChar.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summary method for operating characteristics results — summary.opChar","text":"Brianna D. Hitt","code":""},{"path":"https://bdhitt.github.io/binGroup2/reference/summary.opChar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary method for operating characteristics results — summary.opChar","text":"","code":"# Calculate the operating characteristics for #   non-informative four-stage hierarchical testing. config.mat <- matrix(data = c(rep(1, 24), rep(1, 16),                               rep(2, 8), rep(1, 8),                               rep(2, 8), rep(3, 4),                               rep(4, 2), rep(5, 2), 1:24),                      nrow = 4, ncol = 24, byrow = TRUE) calc1 <- opChar1(algorithm = \"D4\", p = 0.01,                  Se = 0.99, Sp = 0.99,                  hier.config = config.mat,                  a = c(1, 9, 17, 21, 23)) #>  #>  Number of minutes running:  0  #>   summary(calc1) #>  #> Algorithm: Non-informative four-stage hierarchical testing  #>  #> Testing configuration: #> Stage 1: 24 #> Stage 2: 16,8 #> Stage 3: 8,8,4,2,2 #>  #> Expected number of tests: 3.41 #> Expected number of tests per individual: 0.1420 #>  #> Accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.9606 0.9993 0.9357 0.9996         1,9 #> 2 0.9606 0.9997 0.9708 0.9996          17 #> 3 0.9606 0.9999 0.9895 0.9996       21,23 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9606 0.9995 0.9501 0.9996 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value.  # Calculate the operating characteristics for #   informative array testing without master pooling. calc2 <- opChar1(algorithm = \"IA2\", p = 0.025, alpha = 0.5,                  Se = 0.95, Sp = 0.99, rowcol.sz = 10) #>  #>  Number of minutes running:  0.01  #>   summary(calc2) #>  #> Algorithm: Informative array testing without master pooling  #>  #> Testing configuration: #> Row/column size: 10 #> Array size: 100 #>  #> Expected number of tests: 25.62 #> Expected number of tests per individual: 0.2562 #>  #> Accuracy for individuals: #>        PSe    PSp   PPPV   PNPV Individuals #> 1   0.8732 0.9990 0.9947 0.9729           1 #> 2   0.8690 0.9990 0.9836 0.9908           2 #> 3   0.8679 0.9992 0.9795 0.9944           3 #> 4   0.8674 0.9994 0.9768 0.9963           4 #> 5   0.8670 0.9996 0.9746 0.9976           5 #> 6   0.8668 0.9997 0.9708 0.9985           6 #> 7   0.8666 0.9998 0.9681 0.9991           7 #> 8   0.8665 0.9999 0.9452 0.9997           8 #> 9   0.8665 0.9999 0.9254 0.9998           9 #> 10  0.8664 0.9999 0.8113 0.9999          10 #> 11  0.8730 0.9990 0.9931 0.9794          11 #> 12  0.8687 0.9991 0.9849 0.9913          12 #> 13  0.8677 0.9993 0.9812 0.9946          13 #> 14  0.8671 0.9995 0.9786 0.9964          14 #> 15  0.8668 0.9996 0.9765 0.9977          15 #> 16  0.8665 0.9997 0.9731 0.9985          16 #> 17  0.8664 0.9998 0.9675 0.9992          17 #> 18  0.8663 0.9999 0.9502 0.9997          18 #> 19  0.8662 0.9999 0.9143 0.9999          19 #> 20  0.8662 0.9999 0.7098 1.0000          20 #> 21  0.8728 0.9990 0.9920 0.9826          21 #> 22  0.8686 0.9992 0.9853 0.9917          22 #> 23  0.8675 0.9994 0.9818 0.9948          23 #> 24  0.8670 0.9995 0.9794 0.9966          24 #> 25  0.8666 0.9997 0.9773 0.9977          25 #> 26  0.8664 0.9998 0.9749 0.9985          26 #> 27  0.8662 0.9998 0.9678 0.9993          27 #> 28  0.8661 0.9999 0.9516 0.9997          28 #> 29  0.8661 0.9999 0.9159 0.9999          29 #> 30  0.8660 0.9999 0.5402 1.0000          30 #> 31  0.8727 0.9990 0.9912 0.9846          31 #> 32  0.8685 0.9992 0.9855 0.9922          32 #> 33  0.8674 0.9994 0.9822 0.9950          33 #> 34  0.8669 0.9996 0.9798 0.9967          34 #> 35  0.8665 0.9997 0.9777 0.9978          35 #> 36  0.8663 0.9998 0.9738 0.9987          36 #> 37  0.8661 0.9998 0.9675 0.9993          37 #> 38  0.8660 0.9999 0.9520 0.9997          38 #> 39  0.8660 0.9999 0.9112 0.9999          39 #> 40  0.8659 0.9999 0.3256 1.0000          40 #> 41  0.8726 0.9991 0.9905 0.9861          41 #> 42  0.8684 0.9993 0.9855 0.9925          42 #> 43  0.8673 0.9994 0.9824 0.9952          43 #> 44  0.8668 0.9996 0.9800 0.9969          44 #> 45  0.8664 0.9997 0.9779 0.9979          45 #> 46  0.8662 0.9998 0.9749 0.9987          46 #> 47  0.8660 0.9999 0.9670 0.9993          47 #> 48  0.8659 0.9999 0.9506 0.9997          48 #> 49  0.8659 0.9999 0.8952 0.9999          49 #> 50  0.8659 0.9999 0.1430 1.0000          50 #> 51  0.8726 0.9991 0.9900 0.9873          51 #> 52  0.8684 0.9993 0.9856 0.9929          52 #> 53  0.8673 0.9995 0.9826 0.9954          53 #> 54  0.8667 0.9996 0.9802 0.9970          54 #> 55  0.8664 0.9997 0.9782 0.9980          55 #> 56  0.8661 0.9998 0.9732 0.9988          56 #> 57  0.8660 0.9999 0.9642 0.9994          57 #> 58  0.8659 0.9999 0.9520 0.9997          58 #> 59  0.8658 0.9999 0.8939 0.9999          59 #> 60  0.8658 0.9999 0.0453 1.0000          60 #> 61  0.8725 0.9991 0.9896 0.9883          61 #> 62  0.8683 0.9993 0.9856 0.9932          62 #> 63  0.8672 0.9995 0.9828 0.9956          63 #> 64  0.8666 0.9996 0.9794 0.9972          64 #> 65  0.8663 0.9997 0.9766 0.9982          65 #> 66  0.8661 0.9998 0.9737 0.9989          66 #> 67  0.8659 0.9999 0.9651 0.9994          67 #> 68  0.8658 0.9999 0.9503 0.9997          68 #> 69  0.8658 0.9999 0.8848 0.9999          69 #> 70  0.8657 0.9999 0.0105 1.0000          70 #> 71  0.8724 0.9992 0.9891 0.9891          71 #> 72  0.8682 0.9994 0.9856 0.9936          72 #> 73  0.8672 0.9995 0.9828 0.9958          73 #> 74  0.8666 0.9996 0.9795 0.9973          74 #> 75  0.8662 0.9997 0.9748 0.9984          75 #> 76  0.8660 0.9998 0.9748 0.9989          76 #> 77  0.8659 0.9999 0.9663 0.9994          77 #> 78  0.8657 0.9999 0.9474 0.9998          78 #> 79  0.8657 0.9999 0.8743 0.9999          79 #> 80  0.8657 0.9999 0.0018 1.0000          80 #> 81  0.8724 0.9992 0.9888 0.9898          81 #> 82  0.8682 0.9994 0.9855 0.9938          82 #> 83  0.8671 0.9995 0.9828 0.9960          83 #> 84  0.8666 0.9997 0.9804 0.9973          84 #> 85  0.8662 0.9997 0.9754 0.9984          85 #> 86  0.8660 0.9998 0.9709 0.9990          86 #> 87  0.8658 0.9999 0.9660 0.9995          87 #> 88  0.8657 0.9999 0.9405 0.9998          88 #> 89  0.8657 0.9999 0.8598 0.9999          89 #> 90  0.8656 0.9999 0.0002 1.0000          90 #> 91  0.8724 0.9992 0.9884 0.9905          91 #> 92  0.8682 0.9994 0.9855 0.9941          92 #> 93  0.8671 0.9996 0.9828 0.9961          93 #> 94  0.8665 0.9997 0.9803 0.9974          94 #> 95  0.8662 0.9998 0.9763 0.9984          95 #> 96  0.8659 0.9998 0.9715 0.9991          96 #> 97  0.8658 0.9999 0.9564 0.9996          97 #> 98  0.8657 0.9999 0.9381 0.9998          98 #> 99  0.8656 0.9999 0.8583 0.9999          99 #> 100 0.8656 1.0000 0.0000 1.0000         100 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8697 0.9997 0.9846 0.9967 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value.  # Calculate the operating characteristics for #   informative two-stage hierarchical testing #   with a multiplex assay for two diseases. config.mat <- matrix(data = c(rep(1, 5), rep(2, 4),                               1, 1:10),                      nrow = 2, ncol = 10, byrow = TRUE) Se <- matrix(data = c(rep(0.95, 2), rep(0.99, 2)),              nrow = 2, ncol = 2, byrow = FALSE) Sp <- matrix(data = c(rep(0.96, 2), rep(0.98, 2)),              nrow = 2, ncol = 2, byrow = FALSE) calc3 <- opChar2(algorithm = \"ID2\",                  alpha = c(18.25, 0.75, 0.75, 0.25),                  Se = Se, Sp = Sp,                  hier.config = config.mat) #>  #>  Number of minutes running:  0  #>   summary(calc3) #>  #> Algorithm: Informative two-stage hierarchical testing  #>  #> Testing configuration: #> Block size: 10 #> Group sizes: 6,4 #>  #> Expected number of tests: 5.38 #> Expected number of tests per individual: 0.5375 #>  #> Disease 1 accuracy for individuals: #>       PSe    PSp   PPPV   PNPV Individuals #> 1  0.9656 0.9887 0.0129 1.0000           1 #> 2  0.9622 0.9864 0.0714 1.0000           2 #> 3  0.9648 0.9040 0.2140 0.9989           3 #> 4  0.9599 0.9283 0.2893 0.9987           4 #> 5  0.9592 0.9603 0.2751 0.9993           5 #> 6  0.9736 0.9662 0.6921 0.9979           6 #> 7  0.9833 0.9761 0.6345 0.9993           7 #> 8  0.9583 0.9881 0.2530 0.9998           8 #> 9  0.9663 0.9486 0.7296 0.9949           9 #> 10 0.9562 0.9617 0.3706 0.9989          10 #>  #> Disease 2 accuracy for individuals: #>       PSe    PSp   PPPV   PNPV Individuals #> 1  0.9560 0.9808 0.2658 0.9997           1 #> 2  0.9560 0.9708 0.3404 0.9993           2 #> 3  0.9735 0.9446 0.1316 0.9998           3 #> 4  0.9554 0.9850 0.2075 0.9998           4 #> 5  0.9553 0.9614 0.4048 0.9987           5 #> 6  0.9797 0.9705 0.6294 0.9989           6 #> 7  0.9691 0.9524 0.6349 0.9972           7 #> 8  0.9558 0.9191 0.6176 0.9935           8 #> 9  0.9813 0.9745 0.6138 0.9992           9 #> 10 0.9551 0.8602 0.4796 0.9930          10 #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.9681 0.9611 0.4657 0.9988 #> 2 0.9628 0.9532 0.5027 0.9981 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value.  # Calculate the operating characteristics for #   non-informative array testing with master pooling #   with a multiplex assay for two diseases. calc4 <- opChar2(algorithm = \"A2M\",                  p.vec = c(0.92, 0.05, 0.02, 0.01),                  Se = rep(0.95, 2), Sp = rep(0.99, 2),                  rowcol.sz = 8) #>  #>  Number of minutes running:  0  #>   summary(calc4) #>  #> Algorithm: Non-informative array testing with master pooling  #>  #> Testing configuration: #> Row/column size: 8 #> Array size: 64 #>  #> Expected number of tests: 30.29 #> Expected number of tests per individual: 0.4733 #>  #> Disease 1 accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.8704 0.9983 0.9709 0.9918         All #>  #> Disease 2 accuracy for individuals: #>      PSe    PSp   PPPV   PNPV Individuals #> 1 0.9004 0.9981 0.9366 0.9969         All #>  #> Overall accuracy of the algorithm: #>      PSe    PSp   PPPV   PNPV #> 1 0.8704 0.9983 0.9709 0.9918 #> 2 0.9004 0.9981 0.9366 0.9969 #>  #> PSe denotes the pooling sensitivity. #> PSp denotes the pooling specificity. #> PPPV denotes the pooling positive predictive value. #> PNPV denotes the pooling negative predictive value."},{"path":[]},{"path":"https://bdhitt.github.io/binGroup2/news/index.html","id":"minor-improvements-and-bug-fixes-1-3-2","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"binGroup2 1.3.2","text":"Added Github repository URL Fixed small error calculation E(T) array testing master pools","code":""}]
